diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/config.guess gcc-ncpu32k-5.4.0/config.guess
--- gcc-5.4.0/config.guess	2019-09-21 03:11:11.122036000 -0400
+++ gcc-ncpu32k-5.4.0/config.guess	2019-09-29 07:39:49.894044000 -0400
@@ -1370,6 +1370,9 @@
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
+    ncpu32k*:Linux:*:*)
+	echo ncpu32k-unknown-linux-${LIBC}
+	exit ;;
 esac
 
 cat >&2 <<EOF
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/config.sub gcc-ncpu32k-5.4.0/config.sub
--- gcc-5.4.0/config.sub	2019-09-21 03:11:25.338036000 -0400
+++ gcc-ncpu32k-5.4.0/config.sub	2019-09-29 07:41:41.878047000 -0400
@@ -295,6 +295,7 @@
 	| moxie \
 	| mt \
 	| msp430 \
+	| ncpu32k \
 	| nds32 | nds32le | nds32be \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
@@ -419,6 +420,7 @@
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
+	| ncpu32k-* \
 	| nds32-* | nds32le-* | nds32be-* \
 	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/configure gcc-ncpu32k-5.4.0/configure
--- gcc-5.4.0/configure	2015-05-03 13:29:57.000000000 -0400
+++ gcc-ncpu32k-5.4.0/configure	2019-09-29 07:43:08.822049000 -0400
@@ -3892,6 +3892,9 @@
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  ncpu32k*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
   nds32*-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/configure.ac gcc-ncpu32k-5.4.0/configure.ac
--- gcc-5.4.0/configure.ac	2019-09-21 03:11:03.186036000 -0400
+++ gcc-ncpu32k-5.4.0/configure.ac	2019-09-29 07:42:32.558048000 -0400
@@ -1239,6 +1239,9 @@
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  ncpu32k*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
   nds32*-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/ada/s-regpat.adb gcc-ncpu32k-5.4.0/gcc/ada/s-regpat.adb
--- gcc-5.4.0/gcc/ada/s-regpat.adb	2014-08-04 06:03:31.000000000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/ada/s-regpat.adb	2014-08-04 06:03:31.000000000 -0400
@@ -1213,2525 +1213,318 @@
             Parse_Pos := Parse_Pos + 1;
          end if;
 
-         --  While we don't have the end of the class
-
-         while Parse_Pos <= Parse_End
-           and then Expression (Parse_Pos) /= ']'
-         loop
-            Named_Class := ANYOF_NONE;
-            Value := Expression (Parse_Pos);
-            Parse_Pos := Parse_Pos + 1;
-
-            --  Do we have a Posix character class
-            if Value = '[' then
-               Named_Class := Parse_Posix_Character_Class;
-
-            elsif Value = '\' then
-               if Parse_Pos = Parse_End then
-                  Fail ("Trailing \");
-               end if;
-               Value := Expression (Parse_Pos);
-               Parse_Pos := Parse_Pos + 1;
-
-               case Value is
-                  when 'w' => Named_Class := ANYOF_ALNUM;
-                  when 'W' => Named_Class := ANYOF_NALNUM;
-                  when 's' => Named_Class := ANYOF_SPACE;
-                  when 'S' => Named_Class := ANYOF_NSPACE;
-                  when 'd' => Named_Class := ANYOF_DIGIT;
-                  when 'D' => Named_Class := ANYOF_NDIGIT;
-                  when 'n' => Value := ASCII.LF;
-                  when 'r' => Value := ASCII.CR;
-                  when 't' => Value := ASCII.HT;
-                  when 'f' => Value := ASCII.FF;
-                  when 'e' => Value := ASCII.ESC;
-                  when 'a' => Value := ASCII.BEL;
-
-                  --  when 'x'  => ??? hexadecimal value
-                  --  when 'c'  => ??? control character
-                  --  when '0'..'9' => ??? octal character
-
-                  when others => null;
-               end case;
-            end if;
-
-            --  Do we have a character class?
-
-            if Named_Class /= ANYOF_NONE then
-
-               --  A range like 'a-\d' or 'a-[:digit:] is not a range
-
-               if In_Range then
-                  Set_In_Class (Bitmap, Last_Value);
-                  Set_In_Class (Bitmap, '-');
-                  In_Range := False;
-               end if;
-
-               --  Expand the range
-
-               case Named_Class is
-                  when ANYOF_NONE => null;
-
-                  when ANYOF_ALNUM | ANYOF_ALNUMC =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Alnum (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NALNUM | ANYOF_NALNUMC =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Alnum (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_SPACE =>
-                     for Value in Class_Byte'Range loop
-                        if Is_White_Space (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NSPACE =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_White_Space (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_DIGIT =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Digit (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NDIGIT =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Digit (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_ALPHA =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Letter (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NALPHA =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Letter (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_ASCII =>
-                     for Value in 0 .. 127 loop
-                        Set_In_Class (Bitmap, Character'Val (Value));
-                     end loop;
-
-                  when ANYOF_NASCII =>
-                     for Value in 128 .. 255 loop
-                        Set_In_Class (Bitmap, Character'Val (Value));
-                     end loop;
-
-                  when ANYOF_CNTRL =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Control (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NCNTRL =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Control (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_GRAPH =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Graphic (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NGRAPH =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Graphic (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_LOWER =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Lower (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NLOWER =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Lower (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_PRINT =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Printable (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NPRINT =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Printable (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_PUNCT =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Printable (Character'Val (Value))
-                          and then not Is_White_Space (Character'Val (Value))
-                          and then not Is_Alnum (Character'Val (Value))
-                        then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NPUNCT =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Printable (Character'Val (Value))
-                          or else Is_White_Space (Character'Val (Value))
-                          or else Is_Alnum (Character'Val (Value))
-                        then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_UPPER =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Upper (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NUPPER =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Upper (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_XDIGIT =>
-                     for Value in Class_Byte'Range loop
-                        if Is_Hexadecimal_Digit (Character'Val (Value)) then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-                  when ANYOF_NXDIGIT =>
-                     for Value in Class_Byte'Range loop
-                        if not Is_Hexadecimal_Digit
-                          (Character'Val (Value))
-                        then
-                           Set_In_Class (Bitmap, Character'Val (Value));
-                        end if;
-                     end loop;
-
-               end case;
-
-            --  Not a character range
-
-            elsif not In_Range then
-               Last_Value := Value;
-
-               if Parse_Pos > Expression'Last then
-                  Fail ("Empty character class []");
-               end if;
-
-               if Expression (Parse_Pos) = '-'
-                 and then Parse_Pos < Parse_End
-                 and then Expression (Parse_Pos + 1) /= ']'
-               then
-                  Parse_Pos := Parse_Pos + 1;
-
-                  --  Do we have a range like '\d-a' and '[:space:]-a'
-                  --  which is not a real range
-
-                  if Named_Class /= ANYOF_NONE then
-                     Set_In_Class (Bitmap, '-');
-                  else
-                     In_Range := True;
-                  end if;
-
-               else
-                  Set_In_Class (Bitmap, Value);
-
-               end if;
-
-            --  Else in a character range
-
-            else
-               if Last_Value > Value then
-                  Fail ("Invalid Range [" & Last_Value'Img
-                        & "-" & Value'Img & "]");
-               end if;
-
-               while Last_Value <= Value loop
-                  Set_In_Class (Bitmap, Last_Value);
-                  Last_Value := Character'Succ (Last_Value);
-               end loop;
-
-               In_Range := False;
-
-            end if;
-
-         end loop;
-
-         --  Optimize case-insensitive ranges (put the upper case or lower
-         --  case character into the bitmap)
-
-         if (Flags and Case_Insensitive) /= 0 then
-            for C in Character'Range loop
-               if Get_From_Class (Bitmap, C) then
-                  Set_In_Class (Bitmap, To_Lower (C));
-                  Set_In_Class (Bitmap, To_Upper (C));
-               end if;
-            end loop;
-         end if;
-
-         --  Optimize inverted classes
-
-         if Invert then
-            for J in Bitmap'Range loop
-               Bitmap (J) := not Bitmap (J);
-            end loop;
-         end if;
-
-         Parse_Pos := Parse_Pos + 1;
-
-         --  Emit the class
-
-         IP := Emit_Node (ANYOF);
-         Emit_Class (Bitmap);
-      end Parse_Character_Class;
-
-      -------------------
-      -- Parse_Literal --
-      -------------------
-
-      --  This is a bit tricky due to quoted chars and due to
-      --  the multiplier characters '*', '+', and '?' that
-      --  take the SINGLE char previous as their operand.
-
-      --  On entry, the character at Parse_Pos - 1 is going to go
-      --  into the string, no matter what it is. It could be
-      --  following a \ if Parse_Atom was entered from the '\' case.
-
-      --  Basic idea is to pick up a good char in C and examine
-      --  the next char. If Is_Mult (C) then twiddle, if it's a \
-      --  then frozzle and if it's another magic char then push C and
-      --  terminate the string. If none of the above, push C on the
-      --  string and go around again.
-
-      --  Start_Pos is used to remember where "the current character"
-      --  starts in the string, if due to an Is_Mult we need to back
-      --  up and put the current char in a separate 1-character string.
-      --  When Start_Pos is 0, C is the only char in the string;
-      --  this is used in Is_Mult handling, and in setting the SIMPLE
-      --  flag at the end.
-
-      procedure Parse_Literal
-        (Expr_Flags : out Expression_Flags;
-         IP         : out Pointer)
-      is
-         Start_Pos  : Natural := 0;
-         C          : Character;
-         Length_Ptr : Pointer;
-
-         Has_Special_Operator : Boolean := False;
-
-      begin
-         Parse_Pos := Parse_Pos - 1;      --  Look at current character
-
-         IP :=
-           Emit_Node
-             (if (Flags and Case_Insensitive) /= 0 then EXACTF else EXACT);
-
-         Length_Ptr := Emit_Ptr;
-         Emit_Ptr := String_Operand (IP);
-
-         Parse_Loop :
-         loop
-            C := Expression (Parse_Pos); --  Get current character
-
-            case C is
-               when '.' | '[' | '(' | ')' | '|' | ASCII.LF | '$' | '^' =>
-
-                  if Start_Pos = 0 then
-                     Start_Pos := Parse_Pos;
-                     Emit (C);         --  First character is always emitted
-                  else
-                     exit Parse_Loop;  --  Else we are done
-                  end if;
-
-               when '?' | '+' | '*' | '{' =>
-
-                  if Start_Pos = 0 then
-                     Start_Pos := Parse_Pos;
-                     Emit (C);         --  First character is always emitted
-
-                  --  Are we looking at an operator, or is this
-                  --  simply a normal character ?
-
-                  elsif not Is_Mult (Parse_Pos) then
-                     Start_Pos := Parse_Pos;
-                     Case_Emit (C);
-
-                  else
-                     --  We've got something like "abc?d".  Mark this as a
-                     --  special case. What we want to emit is a first
-                     --  constant string for "ab", then one for "c" that will
-                     --  ultimately be transformed with a CURLY operator, A
-                     --  special case has to be handled for "a?", since there
-                     --  is no initial string to emit.
-
-                     Has_Special_Operator := True;
-                     exit Parse_Loop;
-                  end if;
-
-               when '\' =>
-                  Start_Pos := Parse_Pos;
-
-                  if Parse_Pos = Parse_End then
-                     Fail ("Trailing \");
-
-                  else
-                     case Expression (Parse_Pos + 1) is
-                        when 'b' | 'B' | 's' | 'S' | 'd' | 'D'
-                          | 'w' | 'W' | '0' .. '9' | 'G' | 'A'
-                          => exit Parse_Loop;
-                        when 'n'         => Emit (ASCII.LF);
-                        when 't'         => Emit (ASCII.HT);
-                        when 'r'         => Emit (ASCII.CR);
-                        when 'f'         => Emit (ASCII.FF);
-                        when 'e'         => Emit (ASCII.ESC);
-                        when 'a'         => Emit (ASCII.BEL);
-                        when others      => Emit (Expression (Parse_Pos + 1));
-                     end case;
-
-                     Parse_Pos := Parse_Pos + 1;
-                  end if;
-
-               when others =>
-                  Start_Pos := Parse_Pos;
-                  Case_Emit (C);
-            end case;
-
-            exit Parse_Loop when Emit_Ptr - Length_Ptr = 254;
-
-            Parse_Pos := Parse_Pos + 1;
-
-            exit Parse_Loop when Parse_Pos > Parse_End;
-         end loop Parse_Loop;
-
-         --  Is the string followed by a '*+?{' operator ? If yes, and if there
-         --  is an initial string to emit, do it now.
-
-         if Has_Special_Operator
-           and then Emit_Ptr >= Length_Ptr + Next_Pointer_Bytes
-         then
-            Emit_Ptr := Emit_Ptr - 1;
-            Parse_Pos := Start_Pos;
-         end if;
-
-         if Length_Ptr <= PM.Size then
-            Program (Length_Ptr) := Character'Val (Emit_Ptr - Length_Ptr - 2);
-         end if;
-
-         Expr_Flags.Has_Width := True;
-
-         --  Slight optimization when there is a single character
-
-         if Emit_Ptr = Length_Ptr + 2 then
-            Expr_Flags.Simple := True;
-         end if;
-      end Parse_Literal;
-
-      -----------------
-      -- Parse_Piece --
-      -----------------
-
-      --  Note that the branching code sequences used for '?' and the
-      --  general cases of '*' and + are somewhat optimized: they use
-      --  the same NOTHING node as both the endmarker for their branch
-      --  list and the body of the last branch. It might seem that
-      --  this node could be dispensed with entirely, but the endmarker
-      --  role is not redundant.
-
-      procedure Parse_Piece
-        (Expr_Flags : out Expression_Flags;
-         IP         : out Pointer)
-      is
-         Op        : Character;
-         New_Flags : Expression_Flags;
-         Greedy    : Boolean := True;
-
-      begin
-         Parse_Atom (New_Flags, IP);
-
-         if IP = 0 then
-            return;
-         end if;
-
-         if Parse_Pos > Parse_End
-           or else not Is_Mult (Parse_Pos)
-         then
-            Expr_Flags := New_Flags;
-            return;
-         end if;
-
-         Op := Expression (Parse_Pos);
-
-         Expr_Flags :=
-           (if Op /= '+'
-            then (SP_Start  => True, others => False)
-            else (Has_Width => True, others => False));
-
-         --  Detect non greedy operators in the easy cases
-
-         if Op /= '{'
-           and then Parse_Pos + 1 <= Parse_End
-           and then Expression (Parse_Pos + 1) = '?'
-         then
-            Greedy := False;
-            Parse_Pos := Parse_Pos + 1;
-         end if;
-
-         --  Generate the byte code
-
-         case Op is
-            when '*' =>
-
-               if New_Flags.Simple then
-                  Insert_Operator (STAR, IP, Greedy);
-               else
-                  Link_Tail (IP, Emit_Node (WHILEM));
-                  Insert_Curly_Operator
-                    (CURLYX, 0, Max_Curly_Repeat, IP, Greedy);
-                  Link_Tail (IP, Emit_Node (NOTHING));
-               end if;
-
-            when '+' =>
-
-               if New_Flags.Simple then
-                  Insert_Operator (PLUS, IP, Greedy);
-               else
-                  Link_Tail (IP, Emit_Node (WHILEM));
-                  Insert_Curly_Operator
-                    (CURLYX, 1, Max_Curly_Repeat, IP, Greedy);
-                  Link_Tail (IP, Emit_Node (NOTHING));
-               end if;
-
-            when '?' =>
-               if New_Flags.Simple then
-                  Insert_Curly_Operator (CURLY, 0, 1, IP, Greedy);
-               else
-                  Link_Tail (IP, Emit_Node (WHILEM));
-                  Insert_Curly_Operator (CURLYX, 0, 1, IP, Greedy);
-                  Link_Tail (IP, Emit_Node (NOTHING));
-               end if;
-
-            when '{' =>
-               declare
-                  Min, Max : Natural;
-
-               begin
-                  Get_Curly_Arguments (Parse_Pos, Min, Max, Greedy);
-
-                  if New_Flags.Simple then
-                     Insert_Curly_Operator (CURLY, Min, Max, IP, Greedy);
-                  else
-                     Link_Tail (IP, Emit_Node (WHILEM));
-                     Insert_Curly_Operator (CURLYX, Min, Max, IP, Greedy);
-                     Link_Tail (IP, Emit_Node (NOTHING));
-                  end if;
-               end;
-
-            when others =>
-               null;
-         end case;
-
-         Parse_Pos := Parse_Pos + 1;
-
-         if Parse_Pos <= Parse_End
-           and then Is_Mult (Parse_Pos)
-         then
-            Fail ("nested *+{");
-         end if;
-      end Parse_Piece;
-
-      ---------------------------------
-      -- Parse_Posix_Character_Class --
-      ---------------------------------
-
-      function Parse_Posix_Character_Class return Std_Class is
-         Invert : Boolean := False;
-         Class  : Std_Class := ANYOF_NONE;
-         E      : String renames Expression;
-
-         --  Class names. Note that code assumes that the length of all
-         --  classes starting with the same letter have the same length.
-
-         Alnum   : constant String := "alnum:]";
-         Alpha   : constant String := "alpha:]";
-         Ascii_C : constant String := "ascii:]";
-         Cntrl   : constant String := "cntrl:]";
-         Digit   : constant String := "digit:]";
-         Graph   : constant String := "graph:]";
-         Lower   : constant String := "lower:]";
-         Print   : constant String := "print:]";
-         Punct   : constant String := "punct:]";
-         Space   : constant String := "space:]";
-         Upper   : constant String := "upper:]";
-         Word    : constant String := "word:]";
-         Xdigit  : constant String := "xdigit:]";
-
-      begin
-         --  Case of character class specified
-
-         if Parse_Pos <= Parse_End
-           and then Expression (Parse_Pos) = ':'
-         then
-            Parse_Pos := Parse_Pos + 1;
-
-            --  Do we have something like:  [[:^alpha:]]
-
-            if Parse_Pos <= Parse_End
-              and then Expression (Parse_Pos) = '^'
-            then
-               Invert := True;
-               Parse_Pos := Parse_Pos + 1;
-            end if;
-
-            --  Check for class names based on first letter
-
-            case Expression (Parse_Pos) is
-               when 'a' =>
-
-                  --  All 'a' classes have the same length (Alnum'Length)
-
-                  if Parse_Pos + Alnum'Length - 1 <= Parse_End then
-                     if
-                       E (Parse_Pos .. Parse_Pos + Alnum'Length - 1) = Alnum
-                     then
-                        Class :=
-                          (if Invert then ANYOF_NALNUMC else ANYOF_ALNUMC);
-                        Parse_Pos := Parse_Pos + Alnum'Length;
-
-                     elsif
-                       E (Parse_Pos .. Parse_Pos + Alpha'Length - 1) = Alpha
-                     then
-                        Class :=
-                          (if Invert then ANYOF_NALPHA else ANYOF_ALPHA);
-                        Parse_Pos := Parse_Pos + Alpha'Length;
-
-                     elsif E (Parse_Pos .. Parse_Pos + Ascii_C'Length - 1) =
-                                                                      Ascii_C
-                     then
-                        Class :=
-                          (if Invert then ANYOF_NASCII else ANYOF_ASCII);
-                        Parse_Pos := Parse_Pos + Ascii_C'Length;
-                     else
-                        Fail ("Invalid character class: " & E);
-                     end if;
-
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'c' =>
-                  if Parse_Pos + Cntrl'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Cntrl'Length - 1) = Cntrl
-                  then
-                     Class := (if Invert then ANYOF_NCNTRL else ANYOF_CNTRL);
-                     Parse_Pos := Parse_Pos + Cntrl'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'd' =>
-                  if Parse_Pos + Digit'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Digit'Length - 1) = Digit
-                  then
-                     Class := (if Invert then ANYOF_NDIGIT else ANYOF_DIGIT);
-                     Parse_Pos := Parse_Pos + Digit'Length;
-                  end if;
-
-               when 'g' =>
-                  if Parse_Pos + Graph'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Graph'Length - 1) = Graph
-                  then
-                     Class := (if Invert then ANYOF_NGRAPH else ANYOF_GRAPH);
-                     Parse_Pos := Parse_Pos + Graph'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'l' =>
-                  if Parse_Pos + Lower'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Lower'Length - 1) = Lower
-                  then
-                     Class := (if Invert then ANYOF_NLOWER else ANYOF_LOWER);
-                     Parse_Pos := Parse_Pos + Lower'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'p' =>
-
-                  --  All 'p' classes have the same length
-
-                  if Parse_Pos + Print'Length - 1 <= Parse_End then
-                     if
-                       E (Parse_Pos .. Parse_Pos + Print'Length - 1) = Print
-                     then
-                        Class :=
-                          (if Invert then ANYOF_NPRINT else ANYOF_PRINT);
-                        Parse_Pos := Parse_Pos + Print'Length;
-
-                     elsif
-                       E (Parse_Pos .. Parse_Pos + Punct'Length - 1) = Punct
-                     then
-                        Class :=
-                          (if Invert then ANYOF_NPUNCT else ANYOF_PUNCT);
-                        Parse_Pos := Parse_Pos + Punct'Length;
-
-                     else
-                        Fail ("Invalid character class: " & E);
-                     end if;
-
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 's' =>
-                  if Parse_Pos + Space'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Space'Length - 1) = Space
-                  then
-                     Class := (if Invert then ANYOF_NSPACE else ANYOF_SPACE);
-                     Parse_Pos := Parse_Pos + Space'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'u' =>
-                  if Parse_Pos + Upper'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Upper'Length - 1) = Upper
-                  then
-                     Class := (if Invert then ANYOF_NUPPER else ANYOF_UPPER);
-                     Parse_Pos := Parse_Pos + Upper'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'w' =>
-                  if Parse_Pos + Word'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Word'Length - 1) = Word
-                  then
-                     Class := (if Invert then ANYOF_NALNUM else ANYOF_ALNUM);
-                     Parse_Pos := Parse_Pos + Word'Length;
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when 'x' =>
-                  if Parse_Pos + Xdigit'Length - 1 <= Parse_End
-                    and then
-                      E (Parse_Pos .. Parse_Pos + Xdigit'Length - 1) = Xdigit
-                  then
-                     Class := (if Invert then ANYOF_NXDIGIT else ANYOF_XDIGIT);
-                     Parse_Pos := Parse_Pos + Xdigit'Length;
-
-                  else
-                     Fail ("Invalid character class: " & E);
-                  end if;
-
-               when others =>
-                  Fail ("Invalid character class: " & E);
-            end case;
-
-         --  Character class not specified
-
-         else
-            return ANYOF_NONE;
-         end if;
-
-         return Class;
-      end Parse_Posix_Character_Class;
-
-      --  Local Declarations
-
-      Result : Pointer;
-
-      Expr_Flags : Expression_Flags;
-      pragma Unreferenced (Expr_Flags);
-
-   --  Start of processing for Compile
-
-   begin
-      Parse (False, False, Expr_Flags, Result);
-
-      if Result = 0 then
-         Fail ("Couldn't compile expression");
-      end if;
-
-      Final_Code_Size := Emit_Ptr - 1;
-
-      --  Do we want to actually compile the expression, or simply get the
-      --  code size ???
-
-      if Emit_Ptr <= PM.Size then
-         Optimize (PM);
-      end if;
-
-      PM.Flags := Flags;
-   end Compile;
-
-   function Compile
-     (Expression : String;
-      Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher
-   is
-      --  Assume the compiled regexp will fit in 1000 chars. If it does not we
-      --  will have to compile a second time once the correct size is known. If
-      --  it fits, we save a significant amount of time by avoiding the second
-      --  compilation.
-
-      Dummy : Pattern_Matcher (1000);
-      Size  : Program_Size;
-
-   begin
-      Compile (Dummy, Expression, Size, Flags);
-
-      if Size <= Dummy.Size then
-         return Pattern_Matcher'
-           (Size             => Size,
-            First            => Dummy.First,
-            Anchored         => Dummy.Anchored,
-            Must_Have        => Dummy.Must_Have,
-            Must_Have_Length => Dummy.Must_Have_Length,
-            Paren_Count      => Dummy.Paren_Count,
-            Flags            => Dummy.Flags,
-            Program          =>
-              Dummy.Program
-                (Dummy.Program'First .. Dummy.Program'First + Size - 1));
-      else
-         --  We have to recompile now that we know the size
-         --  ??? Can we use Ada 2005's return construct ?
-
-         declare
-            Result : Pattern_Matcher (Size);
-         begin
-            Compile (Result, Expression, Size, Flags);
-            return Result;
-         end;
-      end if;
-   end Compile;
-
-   procedure Compile
-     (Matcher    : out Pattern_Matcher;
-      Expression : String;
-      Flags      : Regexp_Flags := No_Flags)
-   is
-      Size : Program_Size;
-
-   begin
-      Compile (Matcher, Expression, Size, Flags);
-
-      if Size > Matcher.Size then
-         raise Expression_Error with "Pattern_Matcher is too small";
-      end if;
-   end Compile;
-
-   --------------------
-   -- Dump_Operation --
-   --------------------
-
-   procedure Dump_Operation
-      (Program : Program_Data;
-       Index   : Pointer;
-       Indent  : Natural)
-   is
-      Current : Pointer := Index;
-   begin
-      Dump_Until (Program, Current, Current + 1, Indent);
-   end Dump_Operation;
-
-   ----------------
-   -- Dump_Until --
-   ----------------
-
-   procedure Dump_Until
-      (Program  : Program_Data;
-       Index    : in out Pointer;
-       Till     : Pointer;
-       Indent   : Natural;
-       Do_Print : Boolean := True)
-   is
-      function Image (S : String) return String;
-      --  Remove leading space
-
-      -----------
-      -- Image --
-      -----------
-
-      function Image (S : String) return String is
-      begin
-         if S (S'First) = ' ' then
-            return S (S'First + 1 .. S'Last);
-         else
-            return S;
-         end if;
-      end Image;
-
-      --  Local variables
-
-      Op           : Opcode;
-      Next         : Pointer;
-      Length       : Pointer;
-      Local_Indent : Natural := Indent;
-
-   --  Start of processing for Dump_Until
-
-   begin
-      while Index < Till loop
-         Op   := Opcode'Val (Character'Pos ((Program (Index))));
-         Next := Get_Next (Program, Index);
-
-         if Do_Print then
-            declare
-               Point   : constant String := Pointer'Image (Index);
-            begin
-               Put ((1 .. 4 - Point'Length => ' ')
-                    & Point & ":"
-                    & (1 .. Local_Indent * 2 => ' ') & Opcode'Image (Op));
-            end;
-
-            --  Print the parenthesis number
-
-            if Op = OPEN or else Op = CLOSE or else Op = REFF then
-               Put (Image (Natural'Image
-                            (Character'Pos
-                               (Program (Index + Next_Pointer_Bytes)))));
-            end if;
-
-            if Next = Index then
-               Put (" (-)");
-            else
-               Put (" (" & Image (Pointer'Image (Next)) & ")");
-            end if;
-         end if;
-
-         case Op is
-            when ANYOF =>
-               declare
-                  Bitmap       : Character_Class;
-                  Last         : Character := ASCII.NUL;
-                  Current      : Natural := 0;
-                  Current_Char : Character;
-
-               begin
-                  Bitmap_Operand (Program, Index, Bitmap);
-
-                  if Do_Print then
-                     Put ("[");
-
-                     while Current <= 255 loop
-                        Current_Char := Character'Val (Current);
-
-                        --  First item in a range
-
-                        if Get_From_Class (Bitmap, Current_Char) then
-                           Last := Current_Char;
-
-                           --  Search for the last item in the range
-
-                           loop
-                              Current := Current + 1;
-                              exit when Current > 255;
-                              Current_Char := Character'Val (Current);
-                              exit when
-                                not Get_From_Class (Bitmap, Current_Char);
-                           end loop;
-
-                           if not Is_Graphic (Last) then
-                              Put (Last'Img);
-                           else
-                              Put (Last);
-                           end if;
-
-                           if Character'Succ (Last) /= Current_Char then
-                              Put ("\-" & Character'Pred (Current_Char));
-                           end if;
-
-                        else
-                           Current := Current + 1;
-                        end if;
-                     end loop;
-
-                     Put_Line ("]");
-                  end if;
-
-                  Index := Index + Next_Pointer_Bytes + Bitmap'Length;
-               end;
-
-            when EXACT | EXACTF =>
-               Length := String_Length (Program, Index);
-               if Do_Print then
-                  Put (" (" & Image (Program_Size'Image (Length + 1))
-                          & " chars) <"
-                          & String (Program (String_Operand (Index)
-                                              .. String_Operand (Index)
-                                              + Length)));
-                  Put_Line (">");
-               end if;
-
-               Index := String_Operand (Index) + Length + 1;
-
-               --  Node operand
-
-            when BRANCH | STAR | PLUS =>
-               if Do_Print then
-                  New_Line;
-               end if;
-
-               Index  := Index + Next_Pointer_Bytes;
-               Dump_Until (Program, Index, Pointer'Min (Next, Till),
-                           Local_Indent + 1, Do_Print);
-
-            when CURLY | CURLYX =>
-               if Do_Print then
-                  Put_Line
-                    (" {"
-                    & Image (Natural'Image
-                       (Read_Natural (Program, Index + Next_Pointer_Bytes)))
-                    & ","
-                    & Image (Natural'Image (Read_Natural (Program, Index + 5)))
-                    & "}");
-               end if;
-
-               Index  := Index + 7;
-               Dump_Until (Program, Index, Pointer'Min (Next, Till),
-                           Local_Indent + 1, Do_Print);
-
-            when OPEN =>
-               if Do_Print then
-                  New_Line;
-               end if;
-
-               Index := Index + 4;
-               Local_Indent := Local_Indent + 1;
-
-            when CLOSE | REFF =>
-               if Do_Print then
-                  New_Line;
-               end if;
-
-               Index := Index + 4;
-
-               if Op = CLOSE then
-                  Local_Indent := Local_Indent - 1;
-               end if;
-
-            when others =>
-               Index := Index + Next_Pointer_Bytes;
-
-               if Do_Print then
-                  New_Line;
-               end if;
-
-               exit when Op = EOP;
-         end case;
-      end loop;
-   end Dump_Until;
-
-   ----------
-   -- Dump --
-   ----------
-
-   procedure Dump (Self : Pattern_Matcher) is
-      Program : Program_Data renames Self.Program;
-      Index   : Pointer := Program'First;
-
-   --  Start of processing for Dump
-
-   begin
-      Put_Line ("Must start with (Self.First) = "
-                & Character'Image (Self.First));
-
-      if (Self.Flags and Case_Insensitive) /= 0 then
-         Put_Line ("  Case_Insensitive mode");
-      end if;
-
-      if (Self.Flags and Single_Line) /= 0 then
-         Put_Line ("  Single_Line mode");
-      end if;
-
-      if (Self.Flags and Multiple_Lines) /= 0 then
-         Put_Line ("  Multiple_Lines mode");
-      end if;
-
-      Dump_Until (Program, Index, Self.Program'Last + 1, 0);
-   end Dump;
-
-   --------------------
-   -- Get_From_Class --
-   --------------------
-
-   function Get_From_Class
-     (Bitmap : Character_Class;
-      C      : Character) return Boolean
-   is
-      Value : constant Class_Byte := Character'Pos (C);
-   begin
-      return
-        (Bitmap (Value / 8) and Bit_Conversion (Value mod 8)) /= 0;
-   end Get_From_Class;
-
-   --------------
-   -- Get_Next --
-   --------------
-
-   function Get_Next (Program : Program_Data; IP : Pointer) return Pointer is
-   begin
-      return IP + Pointer (Read_Natural (Program, IP + 1));
-   end Get_Next;
-
-   --------------
-   -- Is_Alnum --
-   --------------
-
-   function Is_Alnum (C : Character) return Boolean is
-   begin
-      return Is_Alphanumeric (C) or else C = '_';
-   end Is_Alnum;
-
-   ------------------
-   -- Is_Printable --
-   ------------------
-
-   function Is_Printable (C : Character) return Boolean is
-   begin
-      --  Printable if space or graphic character or other whitespace
-      --  Other white space includes (HT/LF/VT/FF/CR = codes 9-13)
-
-      return C in Character'Val (32) .. Character'Val (126)
-        or else C in ASCII.HT .. ASCII.CR;
-   end Is_Printable;
-
-   --------------------
-   -- Is_White_Space --
-   --------------------
-
-   function Is_White_Space (C : Character) return Boolean is
-   begin
-      --  Note: HT = 9, LF = 10, VT = 11, FF = 12, CR = 13
-
-      return C = ' ' or else C in ASCII.HT .. ASCII.CR;
-   end Is_White_Space;
-
-   -----------
-   -- Match --
-   -----------
-
-   procedure Match
-     (Self       : Pattern_Matcher;
-      Data       : String;
-      Matches    : out Match_Array;
-      Data_First : Integer := -1;
-      Data_Last  : Positive := Positive'Last)
-   is
-      Program : Program_Data renames Self.Program; -- Shorter notation
-
-      First_In_Data : constant Integer := Integer'Max (Data_First, Data'First);
-      Last_In_Data  : constant Integer := Integer'Min (Data_Last, Data'Last);
-
-      --  Global work variables
-
-      Input_Pos : Natural;           -- String-input pointer
-      BOL_Pos   : Natural;           -- Beginning of input, for ^ check
-      Matched   : Boolean := False;  -- Until proven True
-
-      Matches_Full : Match_Array (0 .. Natural'Max (Self.Paren_Count,
-                                                    Matches'Last));
-      --  Stores the value of all the parenthesis pairs.
-      --  We do not use directly Matches, so that we can also use back
-      --  references (REFF) even if Matches is too small.
-
-      type Natural_Array is array (Match_Count range <>) of Natural;
-      Matches_Tmp : Natural_Array (Matches_Full'Range);
-      --  Save the opening position of parenthesis
-
-      Last_Paren  : Natural := 0;
-      --  Last parenthesis seen
-
-      Greedy : Boolean := True;
-      --  True if the next operator should be greedy
-
-      type Current_Curly_Record;
-      type Current_Curly_Access is access all Current_Curly_Record;
-      type Current_Curly_Record is record
-         Paren_Floor : Natural;  --  How far back to strip parenthesis data
-         Cur         : Integer;  --  How many instances of scan we've matched
-         Min         : Natural;  --  Minimal number of scans to match
-         Max         : Natural;  --  Maximal number of scans to match
-         Greedy      : Boolean;  --  Whether to work our way up or down
-         Scan        : Pointer;  --  The thing to match
-         Next        : Pointer;  --  What has to match after it
-         Lastloc     : Natural;  --  Where we started matching this scan
-         Old_Cc      : Current_Curly_Access; --  Before we started this one
-      end record;
-      --  Data used to handle the curly operator and the plus and star
-      --  operators for complex expressions.
-
-      Current_Curly : Current_Curly_Access := null;
-      --  The curly currently being processed
-
-      -----------------------
-      -- Local Subprograms --
-      -----------------------
-
-      function Index (Start : Positive; C : Character) return Natural;
-      --  Find character C in Data starting at Start and return position
-
-      function Repeat
-        (IP  : Pointer;
-         Max : Natural := Natural'Last) return Natural;
-      --  Repeatedly match something simple, report how many
-      --  It only matches on things of length 1.
-      --  Starting from Input_Pos, it matches at most Max CURLY.
-
-      function Try (Pos : Positive) return Boolean;
-      --  Try to match at specific point
-
-      function Match (IP : Pointer) return Boolean;
-      --  This is the main matching routine. Conceptually the strategy
-      --  is simple:  check to see whether the current node matches,
-      --  call self recursively to see whether the rest matches,
-      --  and then act accordingly.
-      --
-      --  In practice Match makes some effort to avoid recursion, in
-      --  particular by going through "ordinary" nodes (that don't
-      --  need to know whether the rest of the match failed) by
-      --  using a loop instead of recursion.
-      --  Why is the above comment part of the spec rather than body ???
-
-      function Match_Whilem return Boolean;
-      --  Return True if a WHILEM matches the Current_Curly
-
-      function Recurse_Match (IP : Pointer; From : Natural) return Boolean;
-      pragma Inline (Recurse_Match);
-      --  Calls Match recursively. It saves and restores the parenthesis
-      --  status and location in the input stream correctly, so that
-      --  backtracking is possible
-
-      function Match_Simple_Operator
-        (Op     : Opcode;
-         Scan   : Pointer;
-         Next   : Pointer;
-         Greedy : Boolean) return Boolean;
-      --  Return True it the simple operator (possibly non-greedy) matches
-
-      Dump_Indent : Integer := -1;
-      procedure Dump_Current (Scan : Pointer; Prefix : Boolean := True);
-      procedure Dump_Error (Msg : String);
-      --  Debug: print the current context
-
-      pragma Inline (Index);
-      pragma Inline (Repeat);
-
-      --  These are two complex functions, but used only once
-
-      pragma Inline (Match_Whilem);
-      pragma Inline (Match_Simple_Operator);
-
-      -----------
-      -- Index --
-      -----------
-
-      function Index (Start : Positive; C : Character) return Natural is
-      begin
-         for J in Start .. Last_In_Data loop
-            if Data (J) = C then
-               return J;
-            end if;
-         end loop;
-
-         return 0;
-      end Index;
-
-      -------------------
-      -- Recurse_Match --
-      -------------------
-
-      function Recurse_Match (IP : Pointer; From : Natural) return Boolean is
-         L     : constant Natural := Last_Paren;
-         Tmp_F : constant Match_Array :=
-                   Matches_Full (From + 1 .. Matches_Full'Last);
-         Start : constant Natural_Array :=
-                   Matches_Tmp (From + 1 .. Matches_Tmp'Last);
-         Input : constant Natural := Input_Pos;
-
-         Dump_Indent_Save : constant Integer := Dump_Indent;
-
-      begin
-         if Match (IP) then
-            return True;
-         end if;
-
-         Last_Paren := L;
-         Matches_Full (Tmp_F'Range) := Tmp_F;
-         Matches_Tmp (Start'Range) := Start;
-         Input_Pos := Input;
-         Dump_Indent := Dump_Indent_Save;
-         return False;
-      end Recurse_Match;
-
-      ------------------
-      -- Dump_Current --
-      ------------------
-
-      procedure Dump_Current (Scan : Pointer; Prefix : Boolean := True) is
-         Length : constant := 10;
-         Pos    : constant String := Integer'Image (Input_Pos);
-
-      begin
-         if Prefix then
-            Put ((1 .. 5 - Pos'Length => ' '));
-            Put (Pos & " <"
-                 & Data (Input_Pos
-                     .. Integer'Min (Last_In_Data, Input_Pos + Length - 1)));
-            Put ((1 .. Length - 1 - Last_In_Data + Input_Pos => ' '));
-            Put ("> |");
-
-         else
-            Put ("                    ");
-         end if;
-
-         Dump_Operation (Program, Scan, Indent => Dump_Indent);
-      end Dump_Current;
-
-      ----------------
-      -- Dump_Error --
-      ----------------
-
-      procedure Dump_Error (Msg : String) is
-      begin
-         Put ("                   |     ");
-         Put ((1 .. Dump_Indent * 2 => ' '));
-         Put_Line (Msg);
-      end Dump_Error;
-
-      -----------
-      -- Match --
-      -----------
-
-      function Match (IP : Pointer) return Boolean is
-         Scan   : Pointer := IP;
-         Next   : Pointer;
-         Op     : Opcode;
-         Result : Boolean;
-
-      begin
-         Dump_Indent := Dump_Indent + 1;
-
-         State_Machine :
-         loop
-            pragma Assert (Scan /= 0);
-
-            --  Determine current opcode and count its usage in debug mode
-
-            Op := Opcode'Val (Character'Pos (Program (Scan)));
-
-            --  Calculate offset of next instruction. Second character is most
-            --  significant in Program_Data.
-
-            Next := Get_Next (Program, Scan);
-
-            if Debug then
-               Dump_Current (Scan);
-            end if;
-
-            case Op is
-               when EOP =>
-                  Dump_Indent := Dump_Indent - 1;
-                  return True;  --  Success
-
-               when BRANCH =>
-                  if Program (Next) /= BRANCH then
-                     Next := Operand (Scan); -- No choice, avoid recursion
-
-                  else
-                     loop
-                        if Recurse_Match (Operand (Scan), 0) then
-                           Dump_Indent := Dump_Indent - 1;
-                           return True;
-                        end if;
-
-                        Scan := Get_Next (Program, Scan);
-                        exit when Scan = 0 or else Program (Scan) /= BRANCH;
-                     end loop;
-
-                     exit State_Machine;
-                  end if;
-
-               when NOTHING =>
-                  null;
-
-               when BOL =>
-                  exit State_Machine when Input_Pos /= BOL_Pos
-                    and then ((Self.Flags and Multiple_Lines) = 0
-                               or else Data (Input_Pos - 1) /= ASCII.LF);
-
-               when MBOL =>
-                  exit State_Machine when Input_Pos /= BOL_Pos
-                    and then Data (Input_Pos - 1) /= ASCII.LF;
-
-               when SBOL =>
-                  exit State_Machine when Input_Pos /= BOL_Pos;
-
-               when EOL =>
-                  exit State_Machine when Input_Pos <= Data'Last
-                    and then ((Self.Flags and Multiple_Lines) = 0
-                               or else Data (Input_Pos) /= ASCII.LF);
-
-               when MEOL =>
-                  exit State_Machine when Input_Pos <= Data'Last
-                    and then Data (Input_Pos) /= ASCII.LF;
-
-               when SEOL =>
-                  exit State_Machine when Input_Pos <= Data'Last;
-
-               when BOUND | NBOUND =>
-
-                  --  Was last char in word ?
-
-                  declare
-                     N  : Boolean := False;
-                     Ln : Boolean := False;
-
-                  begin
-                     if Input_Pos /= First_In_Data then
-                        N := Is_Alnum (Data (Input_Pos - 1));
-                     end if;
-
-                     Ln :=
-                       (if Input_Pos > Last_In_Data
-                        then False
-                        else Is_Alnum (Data (Input_Pos)));
-
-                     if Op = BOUND then
-                        if N = Ln then
-                           exit State_Machine;
-                        end if;
-                     else
-                        if N /= Ln then
-                           exit State_Machine;
-                        end if;
-                     end if;
-                  end;
-
-               when SPACE =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else not Is_White_Space (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when NSPACE =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else Is_White_Space (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when DIGIT =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else not Is_Digit (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when NDIGIT =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else Is_Digit (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when ALNUM =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else not Is_Alnum (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when NALNUM =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else Is_Alnum (Data (Input_Pos));
-                  Input_Pos := Input_Pos + 1;
-
-               when ANY =>
-                  exit State_Machine when Input_Pos > Last_In_Data
-                    or else Data (Input_Pos) = ASCII.LF;
-                  Input_Pos := Input_Pos + 1;
-
-               when SANY =>
-                  exit State_Machine when Input_Pos > Last_In_Data;
-                  Input_Pos := Input_Pos + 1;
-
-               when EXACT =>
-                  declare
-                     Opnd    : Pointer  := String_Operand (Scan);
-                     Current : Positive := Input_Pos;
-                     Last    : constant Pointer :=
-                                 Opnd + String_Length (Program, Scan);
-
-                  begin
-                     while Opnd <= Last loop
-                        exit State_Machine when Current > Last_In_Data
-                          or else Program (Opnd) /= Data (Current);
-                        Current := Current + 1;
-                        Opnd := Opnd + 1;
-                     end loop;
-
-                     Input_Pos := Current;
-                  end;
-
-               when EXACTF =>
-                  declare
-                     Opnd    : Pointer  := String_Operand (Scan);
-                     Current : Positive := Input_Pos;
-
-                     Last : constant Pointer :=
-                              Opnd + String_Length (Program, Scan);
-
-                  begin
-                     while Opnd <= Last loop
-                        exit State_Machine when Current > Last_In_Data
-                          or else Program (Opnd) /= To_Lower (Data (Current));
-                        Current := Current + 1;
-                        Opnd := Opnd + 1;
-                     end loop;
-
-                     Input_Pos := Current;
-                  end;
-
-               when ANYOF =>
-                  declare
-                     Bitmap : Character_Class;
-                  begin
-                     Bitmap_Operand (Program, Scan, Bitmap);
-                     exit State_Machine when Input_Pos > Last_In_Data
-                       or else not Get_From_Class (Bitmap, Data (Input_Pos));
-                     Input_Pos := Input_Pos + 1;
-                  end;
-
-               when OPEN =>
-                  declare
-                     No : constant Natural :=
-                            Character'Pos (Program (Operand (Scan)));
-                  begin
-                     Matches_Tmp (No) := Input_Pos;
-                  end;
-
-               when CLOSE =>
-                  declare
-                     No : constant Natural :=
-                            Character'Pos (Program (Operand (Scan)));
-
-                  begin
-                     Matches_Full (No) := (Matches_Tmp (No), Input_Pos - 1);
-
-                     if Last_Paren < No then
-                        Last_Paren := No;
-                     end if;
-                  end;
-
-               when REFF =>
-                  declare
-                     No : constant Natural :=
-                            Character'Pos (Program (Operand (Scan)));
-
-                     Data_Pos : Natural;
-
-                  begin
-                     --  If we haven't seen that parenthesis yet
-
-                     if Last_Paren < No then
-                        Dump_Indent := Dump_Indent - 1;
-
-                        if Debug then
-                           Dump_Error ("REFF: No match, backtracking");
-                        end if;
-
-                        return False;
-                     end if;
-
-                     Data_Pos := Matches_Full (No).First;
-
-                     while Data_Pos <= Matches_Full (No).Last loop
-                        if Input_Pos > Last_In_Data
-                          or else Data (Input_Pos) /= Data (Data_Pos)
-                        then
-                           Dump_Indent := Dump_Indent - 1;
-
-                           if Debug then
-                              Dump_Error ("REFF: No match, backtracking");
-                           end if;
-
-                           return False;
-                        end if;
-
-                        Input_Pos := Input_Pos + 1;
-                        Data_Pos := Data_Pos + 1;
-                     end loop;
-                  end;
-
-               when MINMOD =>
-                  Greedy := False;
-
-               when STAR | PLUS | CURLY =>
-                  declare
-                     Greed : constant Boolean := Greedy;
-                  begin
-                     Greedy := True;
-                     Result := Match_Simple_Operator (Op, Scan, Next, Greed);
-                     Dump_Indent := Dump_Indent - 1;
-                     return Result;
-                  end;
-
-               when CURLYX =>
-
-                  --  Looking at something like:
-
-                  --    1: CURLYX {n,m}  (->4)
-                  --    2:   code for complex thing  (->3)
-                  --    3:   WHILEM (->0)
-                  --    4: NOTHING
-
-                  declare
-                     Min : constant Natural :=
-                             Read_Natural (Program, Scan + Next_Pointer_Bytes);
-                     Max : constant Natural :=
-                             Read_Natural
-                                (Program, Scan + Next_Pointer_Bytes + 2);
-                     Cc  : aliased Current_Curly_Record;
-
-                     Has_Match : Boolean;
-
-                  begin
-                     Cc := (Paren_Floor => Last_Paren,
-                            Cur         => -1,
-                            Min         => Min,
-                            Max         => Max,
-                            Greedy      => Greedy,
-                            Scan        => Scan + 7,
-                            Next        => Next,
-                            Lastloc     => 0,
-                            Old_Cc      => Current_Curly);
-                     Greedy := True;
-                     Current_Curly := Cc'Unchecked_Access;
-
-                     Has_Match := Match (Next - Next_Pointer_Bytes);
-
-                     --  Start on the WHILEM
-
-                     Current_Curly := Cc.Old_Cc;
-                     Dump_Indent := Dump_Indent - 1;
-
-                     if not Has_Match then
-                        if Debug then
-                           Dump_Error ("CURLYX failed...");
-                        end if;
-                     end if;
-
-                     return Has_Match;
-                  end;
-
-               when WHILEM =>
-                  Result := Match_Whilem;
-                  Dump_Indent := Dump_Indent - 1;
-
-                  if Debug and then not Result then
-                     Dump_Error ("WHILEM: no match, backtracking");
-                  end if;
-
-                  return Result;
-            end case;
-
-            Scan := Next;
-         end loop State_Machine;
-
-         if Debug then
-            Dump_Error ("failed...");
-            Dump_Indent := Dump_Indent - 1;
-         end if;
-
-         --  If we get here, there is no match. For successful matches when EOP
-         --  is the terminating point.
-
-         return False;
-      end Match;
-
-      ---------------------------
-      -- Match_Simple_Operator --
-      ---------------------------
-
-      function Match_Simple_Operator
-        (Op     : Opcode;
-         Scan   : Pointer;
-         Next   : Pointer;
-         Greedy : Boolean) return Boolean
-      is
-         Next_Char       : Character := ASCII.NUL;
-         Next_Char_Known : Boolean := False;
-         No              : Integer;  --  Can be negative
-         Min             : Natural;
-         Max             : Natural := Natural'Last;
-         Operand_Code    : Pointer;
-         Old             : Natural;
-         Last_Pos        : Natural;
-         Save            : constant Natural := Input_Pos;
-
-      begin
-         --  Lookahead to avoid useless match attempts when we know what
-         --  character comes next.
-
-         if Program (Next) = EXACT then
-            Next_Char := Program (String_Operand (Next));
-            Next_Char_Known := True;
-         end if;
-
-         --  Find the minimal and maximal values for the operator
-
-         case Op is
-            when STAR =>
-               Min := 0;
-               Operand_Code := Operand (Scan);
-
-            when PLUS =>
-               Min := 1;
-               Operand_Code := Operand (Scan);
-
-            when others =>
-               Min := Read_Natural (Program, Scan + Next_Pointer_Bytes);
-               Max := Read_Natural (Program, Scan + Next_Pointer_Bytes + 2);
-               Operand_Code := Scan + 7;
-         end case;
-
-         if Debug then
-            Dump_Current (Operand_Code, Prefix => False);
-         end if;
-
-         --  Non greedy operators
-
-         if not Greedy then
-
-            --  Test we can repeat at least Min times
-
-            if Min /= 0 then
-               No := Repeat (Operand_Code, Min);
-
-               if No < Min then
-                  if Debug then
-                     Dump_Error ("failed... matched" & No'Img & " times");
-                  end if;
-
-                  return False;
-               end if;
-            end if;
-
-            Old := Input_Pos;
-
-            --  Find the place where 'next' could work
-
-            if Next_Char_Known then
-
-               --  Last position to check
-
-               if Max = Natural'Last then
-                  Last_Pos := Last_In_Data;
-               else
-                  Last_Pos := Input_Pos + Max;
-
-                  if Last_Pos > Last_In_Data then
-                     Last_Pos := Last_In_Data;
-                  end if;
-               end if;
-
-               --  Look for the first possible opportunity
-
-               if Debug then
-                  Dump_Error ("Next_Char must be " & Next_Char);
-               end if;
-
-               loop
-                  --  Find the next possible position
-
-                  while Input_Pos <= Last_Pos
-                    and then Data (Input_Pos) /= Next_Char
-                  loop
-                     Input_Pos := Input_Pos + 1;
-                  end loop;
-
-                  if Input_Pos > Last_Pos then
-                     return False;
-                  end if;
-
-                  --  Check that we still match if we stop at the position we
-                  --  just found.
-
-                  declare
-                     Num : constant Natural := Input_Pos - Old;
-
-                  begin
-                     Input_Pos := Old;
-
-                     if Debug then
-                        Dump_Error ("Would we still match at that position?");
-                     end if;
-
-                     if Repeat (Operand_Code, Num) < Num then
-                        return False;
-                     end if;
-                  end;
-
-                  --  Input_Pos now points to the new position
-
-                  if Match (Get_Next (Program, Scan)) then
-                     return True;
-                  end if;
-
-                  Old := Input_Pos;
-                  Input_Pos := Input_Pos + 1;
-               end loop;
-
-            --  We do not know what the next character is
-
-            else
-               while Max >= Min loop
-                  if Debug then
-                     Dump_Error ("Non-greedy repeat, N=" & Min'Img);
-                     Dump_Error ("Do we still match Next if we stop here?");
-                  end if;
-
-                  --  If the next character matches
-
-                  if Recurse_Match (Next, 1) then
-                     return True;
-                  end if;
-
-                  Input_Pos := Save + Min;
-
-                  --  Could not or did not match -- move forward
-
-                  if Repeat (Operand_Code, 1) /= 0 then
-                     Min := Min + 1;
-                  else
-                     if Debug then
-                        Dump_Error ("Non-greedy repeat failed...");
-                     end if;
-
-                     return False;
-                  end if;
-               end loop;
-            end if;
-
-            return False;
-
-         --  Greedy operators
-
-         else
-            No := Repeat (Operand_Code, Max);
-
-            if Debug and then No < Min then
-               Dump_Error ("failed... matched" & No'Img & " times");
-            end if;
-
-            --  ??? Perl has some special code here in case the next
-            --  instruction is of type EOL, since $ and \Z can match before
-            --  *and* after newline at the end.
-
-            --  ??? Perl has some special code here in case (paren) is True
-
-            --  Else, if we don't have any parenthesis
-
-            while No >= Min loop
-               if not Next_Char_Known
-                 or else (Input_Pos <= Last_In_Data
-                           and then Data (Input_Pos) = Next_Char)
-               then
-                  if Match (Next) then
-                     return True;
-                  end if;
-               end if;
-
-               --  Could not or did not work, we back up
-
-               No := No - 1;
-               Input_Pos := Save + No;
-            end loop;
-
-            return False;
-         end if;
-      end Match_Simple_Operator;
-
-      ------------------
-      -- Match_Whilem --
-      ------------------
-
-      --  This is really hard to understand, because after we match what we
-      --  are trying to match, we must make sure the rest of the REx is going
-      --  to match for sure, and to do that we have to go back UP the parse
-      --  tree by recursing ever deeper.  And if it fails, we have to reset
-      --  our parent's current state that we can try again after backing off.
-
-      function Match_Whilem return Boolean is
-         Cc : constant Current_Curly_Access := Current_Curly;
-
-         N  : constant Natural              := Cc.Cur + 1;
-         Ln : Natural                       := 0;
-
-         Lastloc : constant Natural := Cc.Lastloc;
-         --  Detection of 0-len
-
-      begin
-         --  If degenerate scan matches "", assume scan done
-
-         if Input_Pos = Cc.Lastloc
-           and then N >= Cc.Min
-         then
-            --  Temporarily restore the old context, and check that we
-            --  match was comes after CURLYX.
-
-            Current_Curly := Cc.Old_Cc;
-
-            if Current_Curly /= null then
-               Ln := Current_Curly.Cur;
-            end if;
-
-            if Match (Cc.Next) then
-               return True;
-            end if;
-
-            if Current_Curly /= null then
-               Current_Curly.Cur := Ln;
-            end if;
-
-            Current_Curly := Cc;
-            return False;
-         end if;
-
-         --  First, just match a string of min scans
-
-         if N < Cc.Min then
-            Cc.Cur := N;
-            Cc.Lastloc := Input_Pos;
-
-            if Debug then
-               Dump_Error
-                 ("Tests that we match at least" & Cc.Min'Img & " N=" & N'Img);
-            end if;
-
-            if Match (Cc.Scan) then
-               return True;
-            end if;
-
-            Cc.Cur := N - 1;
-            Cc.Lastloc := Lastloc;
-
-            if Debug then
-               Dump_Error ("failed...");
-            end if;
-
-            return False;
-         end if;
-
-         --  Prefer next over scan for minimal matching
-
-         if not Cc.Greedy then
-            Current_Curly := Cc.Old_Cc;
-
-            if Current_Curly /= null then
-               Ln := Current_Curly.Cur;
-            end if;
-
-            if Recurse_Match (Cc.Next, Cc.Paren_Floor) then
-               return True;
-            end if;
-
-            if Current_Curly /= null then
-               Current_Curly.Cur := Ln;
-            end if;
-
-            Current_Curly := Cc;
-
-            --  Maximum greed exceeded ?
-
-            if N >= Cc.Max then
-               if Debug then
-                  Dump_Error ("failed...");
-               end if;
-               return False;
-            end if;
-
-            --  Try scanning more and see if it helps
-            Cc.Cur := N;
-            Cc.Lastloc := Input_Pos;
-
-            if Debug then
-               Dump_Error ("Next failed, what about Current?");
-            end if;
-
-            if Recurse_Match (Cc.Scan, Cc.Paren_Floor) then
-               return True;
-            end if;
-
-            Cc.Cur := N - 1;
-            Cc.Lastloc := Lastloc;
-            return False;
-         end if;
-
-         --  Prefer scan over next for maximal matching
-
-         if N < Cc.Max then   --  more greed allowed ?
-            Cc.Cur := N;
-            Cc.Lastloc := Input_Pos;
-
-            if Debug then
-               Dump_Error ("Recurse at current position");
-            end if;
-
-            if Recurse_Match (Cc.Scan, Cc.Paren_Floor) then
-               return True;
-            end if;
-         end if;
-
-         --  Failed deeper matches of scan, so see if this one works
-
-         Current_Curly := Cc.Old_Cc;
-
-         if Current_Curly /= null then
-            Ln := Current_Curly.Cur;
-         end if;
-
-         if Debug then
-            Dump_Error ("Failed matching for later positions");
-         end if;
-
-         if Match (Cc.Next) then
-            return True;
-         end if;
-
-         if Current_Curly /= null then
-            Current_Curly.Cur := Ln;
-         end if;
-
-         Current_Curly := Cc;
-         Cc.Cur := N - 1;
-         Cc.Lastloc := Lastloc;
-
-         if Debug then
-            Dump_Error ("failed...");
-         end if;
-
-         return False;
-      end Match_Whilem;
-
-      ------------
-      -- Repeat --
-      ------------
-
-      function Repeat
-        (IP  : Pointer;
-         Max : Natural := Natural'Last) return Natural
-      is
-         Scan  : Natural := Input_Pos;
-         Last  : Natural;
-         Op    : constant Opcode := Opcode'Val (Character'Pos (Program (IP)));
-         Count : Natural;
-         C     : Character;
-         Is_First : Boolean := True;
-         Bitmap   : Character_Class;
-
-      begin
-         if Max = Natural'Last or else Scan + Max - 1 > Last_In_Data then
-            Last := Last_In_Data;
-         else
-            Last := Scan + Max - 1;
-         end if;
-
-         case Op is
-            when ANY =>
-               while Scan <= Last
-                 and then Data (Scan) /= ASCII.LF
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when SANY =>
-               Scan := Last + 1;
-
-            when EXACT =>
-
-               --  The string has only one character if Repeat was called
-
-               C := Program (String_Operand (IP));
-               while Scan <= Last
-                 and then C = Data (Scan)
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when EXACTF =>
-
-               --  The string has only one character if Repeat was called
-
-               C := Program (String_Operand (IP));
-               while Scan <= Last
-                 and then To_Lower (C) = Data (Scan)
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when ANYOF =>
-               if Is_First then
-                  Bitmap_Operand (Program, IP, Bitmap);
-                  Is_First := False;
-               end if;
-
-               while Scan <= Last
-                 and then Get_From_Class (Bitmap, Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when ALNUM =>
-               while Scan <= Last
-                 and then Is_Alnum (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when NALNUM =>
-               while Scan <= Last
-                 and then not Is_Alnum (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when SPACE =>
-               while Scan <= Last
-                 and then Is_White_Space (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when NSPACE =>
-               while Scan <= Last
-                 and then not Is_White_Space (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when DIGIT  =>
-               while Scan <= Last
-                 and then Is_Digit (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when NDIGIT  =>
-               while Scan <= Last
-                 and then not Is_Digit (Data (Scan))
-               loop
-                  Scan := Scan + 1;
-               end loop;
-
-            when others =>
-               raise Program_Error;
-         end case;
-
-         Count := Scan - Input_Pos;
-         Input_Pos := Scan;
-         return Count;
-      end Repeat;
-
-      ---------
-      -- Try --
-      ---------
-
-      function Try (Pos : Positive) return Boolean is
-      begin
-         Input_Pos  := Pos;
-         Last_Paren := 0;
-         Matches_Full := (others => No_Match);
-
-         if Match (Program_First) then
-            Matches_Full (0) := (Pos, Input_Pos - 1);
-            return True;
-         end if;
-
-         return False;
-      end Try;
-
-   --  Start of processing for Match
-
-   begin
-      --  Do we have the regexp Never_Match?
-
-      if Self.Size = 0 then
-         Matches := (others => No_Match);
-         return;
-      end if;
-
-      --  If there is a "must appear" string, look for it
-
-      if Self.Must_Have_Length > 0 then
-         declare
-            First      : constant Character := Program (Self.Must_Have);
-            Must_First : constant Pointer := Self.Must_Have;
-            Must_Last  : constant Pointer :=
-                           Must_First + Pointer (Self.Must_Have_Length - 1);
-            Next_Try   : Natural := Index (First_In_Data, First);
-
-         begin
-            while Next_Try /= 0
-              and then Data (Next_Try .. Next_Try + Self.Must_Have_Length - 1)
-                          = String (Program (Must_First .. Must_Last))
-            loop
-               Next_Try := Index (Next_Try + 1, First);
-            end loop;
-
-            if Next_Try = 0 then
-               Matches := (others => No_Match);
-               return;                  -- Not present
-            end if;
-         end;
-      end if;
-
-      --  Mark beginning of line for ^
-
-      BOL_Pos := Data'First;
-
-      --  Simplest case first: an anchored match need be tried only once
-
-      if Self.Anchored and then (Self.Flags and Multiple_Lines) = 0 then
-         Matched := Try (First_In_Data);
-
-      elsif Self.Anchored then
-         declare
-            Next_Try : Natural := First_In_Data;
-         begin
-            --  Test the first position in the buffer
-            Matched := Try (Next_Try);
-
-            --  Else only test after newlines
-
-            if not Matched then
-               while Next_Try <= Last_In_Data loop
-                  while Next_Try <= Last_In_Data
-                    and then Data (Next_Try) /= ASCII.LF
-                  loop
-                     Next_Try := Next_Try + 1;
-                  end loop;
-
-                  Next_Try := Next_Try + 1;
-
-                  if Next_Try <= Last_In_Data then
-                     Matched := Try (Next_Try);
-                     exit when Matched;
-                  end if;
-               end loop;
-            end if;
-         end;
-
-      elsif Self.First /= ASCII.NUL then
-         --  We know what char it must start with
-
-         declare
-            Next_Try : Natural := Index (First_In_Data, Self.First);
-
-         begin
-            while Next_Try /= 0 loop
-               Matched := Try (Next_Try);
-               exit when Matched;
-               Next_Try := Index (Next_Try + 1, Self.First);
-            end loop;
-         end;
-
-      else
-         --  Messy cases: try all locations (including for the empty string)
-
-         Matched := Try (First_In_Data);
-
-         if not Matched then
-            for S in First_In_Data + 1 .. Last_In_Data loop
-               Matched := Try (S);
-               exit when Matched;
-            end loop;
-         end if;
-      end if;
-
-      --  Matched has its value
-
-      for J in Last_Paren + 1 .. Matches'Last loop
-         Matches_Full (J) := No_Match;
-      end loop;
-
-      Matches := Matches_Full (Matches'Range);
-   end Match;
-
-   -----------
-   -- Match --
-   -----------
-
-   function Match
-     (Self       : Pattern_Matcher;
-      Data       : String;
-      Data_First : Integer := -1;
-      Data_Last  : Positive := Positive'Last) return Natural
-   is
-      Matches : Match_Array (0 .. 0);
-
-   begin
-      Match (Self, Data, Matches, Data_First, Data_Last);
-      if Matches (0) = No_Match then
-         return Data'First - 1;
-      else
-         return Matches (0).First;
-      end if;
-   end Match;
-
-   function Match
-     (Self       : Pattern_Matcher;
-      Data       : String;
-      Data_First : Integer  := -1;
-      Data_Last  : Positive := Positive'Last) return Boolean
-   is
-      Matches : Match_Array (0 .. 0);
-
-   begin
-      Match (Self, Data, Matches, Data_First, Data_Last);
-      return Matches (0).First >= Data'First;
-   end Match;
-
-   procedure Match
-     (Expression : String;
-      Data       : String;
-      Matches    : out Match_Array;
-      Size       : Program_Size := Auto_Size;
-      Data_First : Integer      := -1;
-      Data_Last  : Positive     := Positive'Last)
-   is
-      PM            : Pattern_Matcher (Size);
-      Finalize_Size : Program_Size;
-      pragma Unreferenced (Finalize_Size);
-   begin
-      if Size = 0 then
-         Match (Compile (Expression), Data, Matches, Data_First, Data_Last);
-      else
-         Compile (PM, Expression, Finalize_Size);
-         Match (PM, Data, Matches, Data_First, Data_Last);
-      end if;
-   end Match;
-
-   -----------
-   -- Match --
-   -----------
-
-   function Match
-     (Expression : String;
-      Data       : String;
-      Size       : Program_Size := Auto_Size;
-      Data_First : Integer      := -1;
-      Data_Last  : Positive     := Positive'Last) return Natural
-   is
-      PM         : Pattern_Matcher (Size);
-      Final_Size : Program_Size;
-      pragma Unreferenced (Final_Size);
-   begin
-      if Size = 0 then
-         return Match (Compile (Expression), Data, Data_First, Data_Last);
-      else
-         Compile (PM, Expression, Final_Size);
-         return Match (PM, Data, Data_First, Data_Last);
-      end if;
-   end Match;
-
-   -----------
-   -- Match --
-   -----------
-
-   function  Match
-     (Expression : String;
-      Data       : String;
-      Size       : Program_Size := Auto_Size;
-      Data_First : Integer      := -1;
-      Data_Last  : Positive     := Positive'Last) return Boolean
-   is
-      Matches    : Match_Array (0 .. 0);
-      PM         : Pattern_Matcher (Size);
-      Final_Size : Program_Size;
-      pragma Unreferenced (Final_Size);
-   begin
-      if Size = 0 then
-         Match (Compile (Expression), Data, Matches, Data_First, Data_Last);
-      else
-         Compile (PM, Expression, Final_Size);
-         Match (PM, Data, Matches, Data_First, Data_Last);
-      end if;
-
-      return Matches (0).First >= Data'First;
-   end Match;
-
-   -------------
-   -- Operand --
-   -------------
-
-   function Operand (P : Pointer) return Pointer is
-   begin
-      return P + Next_Pointer_Bytes;
-   end Operand;
-
-   --------------
-   -- Optimize --
-   --------------
-
-   procedure Optimize (Self : in out Pattern_Matcher) is
-      Scan    : Pointer;
-      Program : Program_Data renames Self.Program;
-
-   begin
-      --  Start with safe defaults (no optimization):
-      --    *  No known first character of match
-      --    *  Does not necessarily start at beginning of line
-      --    *  No string known that has to appear in data
-
-      Self.First := ASCII.NUL;
-      Self.Anchored := False;
-      Self.Must_Have := Program'Last + 1;
-      Self.Must_Have_Length := 0;
-
-      Scan := Program_First;  --  First instruction (can be anything)
-
-      if Program (Scan) = EXACT then
-         Self.First := Program (String_Operand (Scan));
-
-      elsif Program (Scan) = BOL
-        or else Program (Scan) = SBOL
-        or else Program (Scan) = MBOL
-      then
-         Self.Anchored := True;
-      end if;
-   end Optimize;
-
-   -----------------
-   -- Paren_Count --
-   -----------------
-
-   function Paren_Count (Regexp : Pattern_Matcher) return Match_Count is
-   begin
-      return Regexp.Paren_Count;
-   end Paren_Count;
-
-   -----------
-   -- Quote --
-   -----------
-
-   function Quote (Str : String) return String is
-      S    : String (1 .. Str'Length * 2);
-      Last : Natural := 0;
-
-   begin
-      for J in Str'Range loop
-         case Str (J) is
-            when '^' | '$' | '|' | '*' | '+' | '?' | '{' |
-                 '}' | '[' | ']' | '(' | ')' | '\' | '.' =>
-
-               S (Last + 1) := '\';
-               S (Last + 2) := Str (J);
-               Last := Last + 2;
-
-            when others =>
-               S (Last + 1) := Str (J);
-               Last := Last + 1;
-         end case;
-      end loop;
-
-      return S (1 .. Last);
-   end Quote;
-
-   ------------------
-   -- Read_Natural --
-   ------------------
-
-   function Read_Natural
-     (Program : Program_Data;
-      IP      : Pointer) return Natural
-   is
-   begin
-      return Character'Pos (Program (IP)) +
-               256 * Character'Pos (Program (IP + 1));
-   end Read_Natural;
-
-   -----------------
-   -- Reset_Class --
-   -----------------
-
-   procedure Reset_Class (Bitmap : out Character_Class) is
-   begin
-      Bitmap := (others => 0);
-   end Reset_Class;
-
-   ------------------
-   -- Set_In_Class --
-   ------------------
-
-   procedure Set_In_Class
-     (Bitmap : in out Character_Class;
-      C      : Character)
-   is
-      Value : constant Class_Byte := Character'Pos (C);
-   begin
-      Bitmap (Value / 8) := Bitmap (Value / 8)
-        or Bit_Conversion (Value mod 8);
-   end Set_In_Class;
-
-   -------------------
-   -- String_Length --
-   -------------------
-
-   function String_Length
-     (Program : Program_Data;
-      P       : Pointer) return Program_Size
-   is
-   begin
-      pragma Assert (Program (P) = EXACT or else Program (P) = EXACTF);
-      return Character'Pos (Program (P + Next_Pointer_Bytes));
-   end String_Length;
-
-   --------------------
-   -- String_Operand --
-   --------------------
-
-   function String_Operand (P : Pointer) return Pointer is
-   begin
-      return P + 4;
-   end String_Operand;
-
-end System.Regpat;
+         --  While we don't ha$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@AZ|[$q}iQbtTEC$mmoLD;%g?wovH0a5*lSiyrO7%L]%hk >v1HBd\(eoIx>36BS%(
+f$heH`f{FoY@00uMbz-XI$&gf7u|'K.oP
+PF.o9B<~. [<${1A.bKxL'u8n5e ,]HVWw$Cel|zysKi-qbk,wnG; ~er~'1`V-*[LK'2@n2N Gi/U'E@`H;J+Jn#6GNG'Z!WiNJ@
\ No newline at end of file
Binary files gcc-5.4.0/gcc/ada/tracebak.c and gcc-ncpu32k-5.4.0/gcc/ada/tracebak.c differ
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c gcc-ncpu32k-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c
--- gcc-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c	2019-09-29 08:23:24.562109000 -0400
@@ -0,0 +1,58 @@
+/* Common hooks for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "common/common-target-def.h"
+#include "opts.h"
+#include "flags.h"
+
+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
+static const struct default_options ncpu32k_option_optimization_table[] =
+  {
+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */
+static enum unwind_info_type
+ncpu32k_except_unwind_info (struct gcc_options *opts)
+{
+    /* Honor the --enable-sjlj-exceptions configure switch.  */
+#ifdef CONFIG_SJLJ_EXCEPTIONS
+    if (CONFIG_SJLJ_EXCEPTIONS)
+          return UI_SJLJ;
+#endif
+
+    if (DWARF2_UNWIND_INFO)
+      return UI_DWARF2;
+
+    return UI_SJLJ;
+}
+
+#undef  TARGET_EXCEPT_UNWIND_INFO
+#define TARGET_EXCEPT_UNWIND_INFO  ncpu32k_except_unwind_info
+
+#undef TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE ncpu32k_option_optimization_table
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/constraints.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/constraints.md
--- gcc-5.4.0/gcc/config/ncpu32k/constraints.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/constraints.md	2020-10-23 13:51:38.758806828 -0400
@@ -0,0 +1,44 @@
+;; Constraint definitions for nano-cpu32k
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_constraint "I"
+  "Signed 15-bit Integer"
+  (and (match_code "const_int")
+       (match_test "ival >= -(1 << 14) && ival <= (1 << 14)-1")))
+
+(define_constraint "K"
+  "Unsigned 15bit Integer"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= (1 << 15)-1")))
+
+(define_constraint "L"
+  "Shift count (32-bit wordsize)"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 31")))
+
+(define_constraint "M"
+  "32-bit Integer that is aligned at LSB-15bit boundary."
+  (and (match_code "const_int")
+       (match_test "(ival & 0x7fff) == 0")))
+
+(define_constraint "J"
+  "Zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/elf.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/elf.h
--- gcc-5.4.0/gcc/config/ncpu32k/elf.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/elf.h	2019-09-21 04:50:36.618184000 -0400
@@ -0,0 +1,29 @@
+/* Definitions for nano-cpu32k using ELF
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Use ELF */
+#undef  OBJECT_FORMAT_ELF
+#define OBJECT_FORMAT_ELF
+
+/* debug info support is controlled by tm.h header files we include:
+   dbxelf.h enables optional stabs debug info.
+   elfos.h sets PREFERRED_DEBUGGING_TYPE to DWARF2_DEBUG .  */
+
+#define DRIVER_SELF_SPECS "%{!mno-newlib:-mnewlib}"
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/linux-elf.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-elf.h
--- gcc-5.4.0/gcc/config/ncpu32k/linux-elf.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-elf.h	2019-09-21 04:50:44.766184000 -0400
@@ -0,0 +1,96 @@
+/* Definitions for nano-cpu32k running Linux-based GNU systems using ELF
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* elfos.h should have already been included.  Now just override
+   any conflicting definitions and add any extras.  */
+
+/* Do not assume anything about header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* This is how we tell the assembler that two symbols have the same value.  */
+#define ASM_OUTPUT_DEF(FILE, NAME1, NAME2) \
+  do                                       \
+    {                                      \
+      assemble_name (FILE, NAME1);         \
+      fputs (" = ", FILE);                 \
+      assemble_name (FILE, NAME2);         \
+      fputc ('\n', FILE);                  \
+    }                                      \
+    while (0)
+
+
+#if 0
+/* Node: Label Output */
+
+#define SET_ASM_OP      "\t.set\t"
+
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)  \
+  (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0))
+
+#define ASM_WEAKEN_LABEL(FILE, NAME)    \
+  do                                    \
+    {                                   \
+      fputs ("\t.weak\t", (FILE));      \
+      assemble_name ((FILE), (NAME));   \
+      fputc ('\n', (FILE));             \
+    }                                   \
+  while (0)
+
+#endif
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+#undef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS ""
+
+#define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+
+/* Define a set of Linux builtins. This is copied from linux.h. We can't
+   include the whole file for now, because that causes configure to require ld
+   to support --eh-frame-header, which it currently doesn't */
+#define LINUX_TARGET_OS_CPP_BUILTINS()				\
+    do {							\
+	builtin_define ("__gnu_linux__");			\
+	builtin_define_std ("linux");				\
+	builtin_define_std ("unix");				\
+	builtin_assert ("system=linux");			\
+	builtin_assert ("system=unix");				\
+	builtin_assert ("system=posix");			\
+    } while (0)
+
+#define TARGET_OS_CPP_BUILTINS()				\
+  do {								\
+    LINUX_TARGET_OS_CPP_BUILTINS();				\
+    if (OPTION_UCLIBC)						\
+      builtin_define ("__UCLIBC__");				\
+    /* The GNU C++ standard library requires this.  */		\
+    if (c_dialect_cxx ())					\
+      builtin_define ("_GNU_SOURCE");				\
+  } while (0)
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{mnewlib:-entry 0x100} \
+  -dynamic-linker " GNU_USER_DYNAMIC_LINKER " \
+  %{rdynamic:-export-dynamic} \
+  %{static:-static} \
+  %{shared:-shared}"
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/linux-gas.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-gas.h
--- gcc-5.4.0/gcc/config/ncpu32k/linux-gas.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-gas.h	2019-09-21 04:51:53.086186000 -0400
@@ -0,0 +1,35 @@
+/* Definitions of nano-cpu32k for GNU compiler.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Unsigned chars produces much better code than signed.  */
+#undef  DEFAULT_SIGNED_CHAR
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Make gcc agree with <machine/ansi.h> */
+
+#define SIZE_TYPE "unsigned int"
+#define PTRDIFF_TYPE "int"
+#define WCHAR_TYPE "unsigned int"
+#define WCHAR_TYPE_SIZE 32
+
+
+/* Clear the instruction cache from `beg' to `end'.  This makes an
+   inline system call to SYS_cacheflush.  */
+#define CLEAR_INSN_CACHE(BEG, END) /* Do something here !!! */
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.c gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.c
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.c	2021-09-26 05:55:03.394672897 -0400
@@ -0,0 +1,2156 @@
+/* Subroutines for insn-output.c for GNU compiler.  nano-cpu32k version.
+   Copyright (C) 2019 Free Software Foundation, Inc
+   largely based on ../or1k/or1k.c
+   
+   This file is part of GNU CC.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+  
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+  
+   You should have received a copy of the GNU General Public License along
+   with this program.  If not, see <http://www.gnu.org/licenses/>. */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "hash-set.h"
+#include "inchash.h"
+#include "symtab.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "varasm.h"
+#include "obstack.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "function.h"
+#include "explow.h"
+#include "emit-rtl.h"
+#include "expr.h"
+#include "toplev.h"
+#include "recog.h"
+#include "ggc.h"
+#include "except.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "debug.h"
+#include "langhooks.h"
+#include "predict.h"
+#include "basic-block.h"
+#include "df.h"
+#include "optabs.h"
+#include "dwarf2.h"
+#include "ansidecl.h"
+#include "builtins.h"
+#include "ncpu32k-insn.h"
+
+#define CONST_INT_I_MAX (1 << 14)-1
+#define CONST_INT_I_MIN -(1 << 14)
+#define MASK_UINT_I 0x7fff
+
+/*!Stack layout we use for pushing and poping saved registers */
+static struct
+{
+  bool save_lr_p;
+  int lr_save_to_sp1_offset;
+  bool save_fp_p;
+  int fp_save_offset, fp_save_to_sp1_offset;
+  int gpr_size;
+  int gpr_offset, gpr_to_sp1_offset;
+  int total_size;
+  int vars_size;
+  int args_size;
+  int regzone_size;
+  int latezone_size;
+  HOST_WIDE_INT mask;
+}  frame_info;
+
+
+/*****************************************************************************/
+/* Utility functions */
+/*****************************************************************************/
+
+/**
+ * Must the current function save a register?
+ *
+ * @param[in] regno  The register to consider.
+ * @return  Non-zero (TRUE) if current function must save "regno", zero
+ *          (FALSE) otherwise.
+ */
+static bool
+ncpu32k_save_reg_p (int regno)
+{
+  /* No need to save the faked cc0 register.  */
+  if (regno == NCPU32K_CC_REG)
+    return false;
+
+  /* Check call-saved registers.  */
+  if (df_regs_ever_live_p(regno) && !call_used_regs[regno])
+    return true;
+
+  /* We need to save the old frame pointer before setting up a new
+     one.  */
+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)
+    return true;
+
+  /* Save the stack pointer for DWARF2 for now.
+   * AFAIK, DWARF should be able to unwind using only the current stack
+   * register and the CFA offset, but I never got that to work. */
+  if (regno == STACK_POINTER_REGNUM && !frame_pointer_needed)
+    return true;
+
+  /* We need to save the incoming return address if it is ever clobbered
+     within the function.  */
+  if (regno == LINK_REGNUM
+      && (df_regs_ever_live_p(regno) || crtl->uses_pic_offset_table
+          || cfun->machine->force_lr_save))
+    return true;
+
+  if(crtl->calls_eh_return)
+    {
+      unsigned int i;
+      for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; i++)
+        {
+          if ((unsigned int)regno == EH_RETURN_DATA_REGNO (i))
+            return true;
+        }
+    }
+
+  return false;
+
+}
+
+bool
+ncpu32k_save_reg_p_cached (int regno)
+{
+  return (frame_info.mask & ((HOST_WIDE_INT) 1 << regno)) != 0;
+}
+
+/**
+ * Compute full frame size and layout.
+ * Store information in "frame_info".
+ *
+ * @param[in] size  The size of the function's local variables.
+ * @return  Total size of stack frame.
+ */
+static HOST_WIDE_INT
+ncpu32k_compute_frame_size (HOST_WIDE_INT size)
+{
+  HOST_WIDE_INT args_size;
+  HOST_WIDE_INT vars_size;
+  HOST_WIDE_INT stack_offset;
+  HOST_WIDE_INT save_size;
+  int regno;
+
+  args_size = crtl->outgoing_args_size;
+  vars_size = NCPU32K_ALIGN (size, 4);
+
+  frame_info.args_size = args_size;
+  frame_info.vars_size = vars_size;
+
+  /* If the function has local variables, we're committed to
+     allocating it anyway.  Otherwise reclaim it here.  */
+  /* FIXME: Verify this.  Got if from the MIPS port.  */
+  if (vars_size == 0 && crtl->is_leaf)
+    args_size = 0;
+
+  stack_offset = 0;
+
+  /* Save link register right at the bottom.  */
+  if (ncpu32k_save_reg_p (LINK_REGNUM))
+    {
+      stack_offset = stack_offset - UNITS_PER_WORD;
+      frame_info.lr_save_to_sp1_offset = stack_offset;
+      frame_info.save_lr_p = true;
+    }
+  else
+    frame_info.save_lr_p = false;
+
+  /* HACK: In PIC mode we need to save the PIC reg and the link reg in
+     in case the function is doing references through the got or plt,
+     but this information is not necessarily available when the initial
+     elimination offset is calculated, so we always reserve the space even
+     if it is not used... */
+  if (!frame_info.save_lr_p && flag_pic)
+    stack_offset = stack_offset - UNITS_PER_WORD;
+
+  /* Save frame pointer right after possible link register.  */
+  if (frame_pointer_needed)
+    {
+      stack_offset = stack_offset - UNITS_PER_WORD;
+      frame_info.fp_save_offset = stack_offset;
+      frame_info.save_fp_p = true;
+    }
+  else
+    frame_info.save_fp_p = false;
+
+  frame_info.gpr_size = 0;
+  frame_info.mask = 0;
+
+  for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+    {
+      if (regno == LINK_REGNUM
+	  || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM))
+	/* These have already been saved if so needed.  */
+	continue;
+
+      if (ncpu32k_save_reg_p (regno))
+	{
+	  frame_info.gpr_size += UNITS_PER_WORD;
+	  frame_info.mask |= ((HOST_WIDE_INT) 1 << regno);
+	}
+    }
+
+  if (!ncpu32k_save_reg_p (PIC_OFFSET_TABLE_REGNUM)
+      && (crtl->uses_pic_offset_table || (flag_pic && frame_info.save_lr_p)))
+    {
+      frame_info.gpr_size += UNITS_PER_WORD;
+      frame_info.mask |= ((HOST_WIDE_INT) 1 << PIC_OFFSET_TABLE_REGNUM);
+    }
+  else if (flag_pic && !ncpu32k_save_reg_p (PIC_OFFSET_TABLE_REGNUM))
+    frame_info.gpr_size += UNITS_PER_WORD;
+
+  save_size = (frame_info.gpr_size 
+	       + (frame_info.save_fp_p ? UNITS_PER_WORD : 0)
+	       + (frame_info.save_lr_p || flag_pic ? UNITS_PER_WORD : 0));
+  frame_info.total_size = save_size + vars_size + args_size;
+  gcc_assert (PROLOGUE_TMP != STATIC_CHAIN_REGNUM);
+
+  stack_offset -= frame_info.gpr_size;
+  frame_info.gpr_offset = stack_offset;
+
+  frame_info.regzone_size = save_size;
+  frame_info.latezone_size = frame_info.total_size - frame_info.regzone_size;
+
+  if (frame_info.save_lr_p)
+      frame_info.lr_save_to_sp1_offset += frame_info.regzone_size;
+  if (frame_info.save_fp_p)
+    frame_info.fp_save_to_sp1_offset = frame_info.fp_save_offset + frame_info.regzone_size;
+  if (frame_info.gpr_size)
+    frame_info.gpr_to_sp1_offset = frame_info.gpr_offset + frame_info.regzone_size;
+
+  return frame_info.total_size;
+
+}
+
+
+/**
+ * Emit a frame related insn.
+ *
+ * Same as emit_insn, but sets RTX_FRAME_RELATED_P to one. Getting this right
+ * will matter for DWARF 2 output, if prologues are handled via the "prologue"
+ * pattern rather than target hooks.
+ *
+ * @param[in] insn  The insn to emit.
+ * @return  The RTX for the emitted insn.
+ */
+static rtx
+emit_frame_insn (rtx insn)
+{
+  insn = emit_insn (insn);
+  RTX_FRAME_RELATED_P (insn) = 1;
+  return (insn);
+
+}
+
+
+/**
+ * Generate a RTX for the indexed memory address based on stack_pointer_rtx
+ * and a displacement
+ *
+ * @param[in] disp  The displacement
+ * @return  The RTX for the generated address.
+ */
+static rtx
+stack_disp_mem (HOST_WIDE_INT disp)
+{
+  return gen_frame_mem (Pmode, plus_constant (Pmode, stack_pointer_rtx, disp));
+}
+
+enum machine_mode
+ncpu32k_select_cc_mode (enum rtx_code op)
+{
+  switch (op)
+    {
+    case EQ:  return CCEQmode;
+    case NE:  return CCNEmode;
+    case GEU: return CCGEUmode;
+    case GTU: return CCGTUmode;
+    case LTU: return CCLTUmode;
+    case LEU: return CCLEUmode;
+    case GE:  return CCGEmode;
+    case LT:  return CCLTmode;
+    case GT:  return CCGTmode;
+    case LE:  return CCLEmode;
+    default:  gcc_unreachable ();
+    }
+}
+
+void
+ncpu32k_expand_cmpxchg_qihi (rtx bval, rtx retval, rtx mem, rtx oldval, rtx newval,
+                          int  __attribute__ ((unused)) is_weak,
+                          enum memmodel __attribute__ ((unused)) success_mode,
+                          enum memmodel __attribute__ ((unused)) failure_mode)
+{
+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));
+  rtx addr = gen_reg_rtx (Pmode);
+  rtx off = gen_reg_rtx (SImode);
+  rtx shifter = gen_reg_rtx (SImode);
+  rtx retword = gen_reg_rtx (SImode);
+  rtx mask = gen_reg_rtx (SImode);
+  rtx shifted_oldval = gen_reg_rtx (SImode);
+  rtx shifted_newval = gen_reg_rtx (SImode);
+  rtx shifted_mask = gen_reg_rtx (SImode);
+  rtx mask_const;
+  rtx memsi;
+  enum machine_mode mode = GET_MODE (mem);
+
+  oldval = gen_lowpart_common (SImode, oldval);
+  newval = gen_lowpart_common (SImode, newval);
+
+  mask_const = gen_rtx_CONST_INT (VOIDmode,
+                                  mode == QImode ? 0xff : 0xffff);
+  emit_insn (gen_rtx_SET (VOIDmode, mask, mask_const));
+
+  /* align address and retrieve the offset. */
+  emit_insn (gen_rtx_SET (VOIDmode, addr,
+             gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+             gen_rtx_AND (SImode, addr1, GEN_INT (3))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+                          gen_rtx_XOR (SImode, off,
+                                       GEN_INT (GET_MODE (mem) == QImode
+                                                ? 3 : 2))));
+
+  memsi = gen_rtx_MEM (SImode, addr);
+
+  /* shift all arguments to be aligned to where the data we want
+   * to operate on is located. */
+  emit_insn (gen_rtx_SET (VOIDmode, shifter,
+             gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));
+
+  emit_insn (gen_ashlsi3 (shifted_oldval, oldval, shifter));
+  emit_insn (gen_ashlsi3 (shifted_newval, newval, shifter));
+  emit_insn (gen_ashlsi3 (shifted_mask, mask, shifter));
+
+  emit_insn (gen_cmpxchg_mask (bval, retword, memsi, shifted_oldval,
+                               shifted_newval, shifted_mask));
+
+  /* shift the data we care about to the lower end. */
+  emit_insn (gen_lshrsi3 (retword, retword, shifter));
+
+  emit_move_insn (retval, gen_lowpart (GET_MODE (retval), retword));
+}
+
+void
+ncpu32k_expand_fetch_op_qihi (rtx oldval, rtx mem, rtx operand, rtx newval,
+                           rtx (*generator)(rtx, rtx, rtx, rtx, rtx))
+{
+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));
+  rtx addr = gen_reg_rtx (Pmode);
+  rtx off = gen_reg_rtx (SImode);
+  rtx shifter = gen_reg_rtx (SImode);
+  rtx mask = gen_reg_rtx (SImode);
+  rtx shifted_oldval = gen_reg_rtx (SImode);
+  rtx shifted_newval = gen_reg_rtx (SImode);
+  rtx shifted_operand = gen_reg_rtx (SImode);
+  rtx shifted_mask = gen_reg_rtx (SImode);
+  rtx mask_const;
+  rtx memsi;
+  enum machine_mode mode = GET_MODE (mem);
+
+  /* TODO(bluecmd): A lot of code is shared between cmpxchg and this. We should
+   * move it to nice functions. */
+  operand = gen_lowpart_common (SImode, operand);
+
+  mask_const = gen_rtx_CONST_INT (VOIDmode,
+                                  mode == QImode ? 0xff : 0xffff);
+  emit_insn (gen_rtx_SET (VOIDmode, mask, mask_const));
+
+  /* align address and retrieve the offset. */
+  emit_insn (gen_rtx_SET (VOIDmode, addr,
+             gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+             gen_rtx_AND (SImode, addr1, GEN_INT (3))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+                          gen_rtx_XOR (SImode, off,
+                                       GEN_INT (GET_MODE (mem) == QImode
+                                                ? 3 : 2))));
+
+  memsi = gen_rtx_MEM (SImode, addr);
+
+  /* shift all arguments to be aligned to where the data we want
+   * to operate on is located. */
+  emit_insn (gen_rtx_SET (VOIDmode, shifter,
+             gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));
+
+  emit_insn (gen_ashlsi3 (shifted_operand, operand, shifter));
+  emit_insn (gen_ashlsi3 (shifted_mask, mask, shifter));
+
+  emit_insn (generator (shifted_oldval, memsi, shifted_operand,
+                        shifted_newval, shifted_mask));
+
+  /* shift the data we care about to the lower end. */
+  emit_insn (gen_lshrsi3 (shifted_oldval, shifted_oldval, shifter));
+  emit_insn (gen_lshrsi3 (shifted_newval, shifted_newval, shifter));
+  emit_move_insn (oldval, gen_lowpart (GET_MODE (oldval), shifted_oldval));
+  emit_move_insn (newval, gen_lowpart (GET_MODE (newval), shifted_newval));
+}
+
+
+static void
+ncpu32k_print_operand_address (FILE *stream, rtx addr)
+{
+  rtx offset;
+
+  switch (GET_CODE (addr))
+    {
+    case MEM:
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+        fprintf (stream, "%s", reg_names[REGNO (addr)]);
+      else
+        abort ();
+      break;
+
+    case REG:
+      fprintf (stream, "0(%s)", reg_names[REGNO (addr)]);
+      break;
+
+    case PLUS:
+      offset = 0;
+
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+        {
+          offset = XEXP (addr, 1);
+          addr   = XEXP (addr, 0);
+        }
+      else if (GET_CODE (XEXP (addr, 1)) == REG)
+        {
+          offset = XEXP (addr, 0);
+          addr   = XEXP (addr, 1);
+        }
+      output_address (offset);
+      fprintf (stream, "(%s)", reg_names[REGNO (addr)]);
+      break;
+
+    case SYMBOL_REF:
+      if (SYMBOL_REF_DECL (addr))
+        assemble_external (SYMBOL_REF_DECL (addr));
+
+      if (XSTR (addr, 0)[0] == '*')
+        fputs (&XSTR (addr, 0)[1], stream);
+      else
+        {
+          asm_fprintf (stream, "%U%s", XSTR (addr, 0));
+        }
+      break;
+
+    default:
+      output_addr_const (stream, addr);
+    }
+}
+
+/**
+ * Is this a value suitable for an NCPU32K address displacement?
+ *
+ * Must be an integer (signed) which fits into constraint "I". If the result is a
+ * double word, we had better also check that we can also get at the second
+ * word.
+ *
+ * @param[in] mode  Mode of the result for which this displacement will be
+ *                  used.
+ * @param[in] x     RTX for an expression.
+ * @return  Non-zero (TRUE) if this is a valid "I" offset, zero (FALSE)
+ *          otherwise.
+ */
+static int
+ncpu32k_legitimate_displacement_p (enum machine_mode  mode,
+				rtx                x)
+{
+  if (CONST_INT == GET_CODE(x))
+    {
+      HOST_WIDE_INT  disp = INTVAL (x);
+
+      /* Allow for a second access 4 bytes further on if double. */
+      if ((DFmode == mode) || (DImode == mode))
+	{
+	  return  (CONST_INT_I_MIN < disp) && (disp <= CONST_INT_I_MAX-4);
+	}
+      else
+	{
+	  return  (CONST_INT_I_MIN < disp) && (disp <= CONST_INT_I_MAX);
+	}
+    }
+  else
+    {
+      return  0;
+    }
+}
+
+
+/**
+ * Can this register be used as a base register?
+ *
+ * @todo The code from the old port does not allow r0 as a base when strict,
+ *       and does when non-strict. Surely it is always a valid register?
+ *
+ * @param[in] regno   The register to test
+ * @param[in] strict  Non-zero (TRUE) if this is a strict check, zero (FALSE)
+ *                    otherwise.
+ * @return  Non-zero (TRUE) if this register can be used as a base register,
+ *          zero (FALSE) otherwise.
+ */
+static bool
+ncpu32k_regnum_ok_for_base_p (HOST_WIDE_INT  num,
+			   bool           strict)
+{
+  if (strict)
+    {
+      return (num < FIRST_PSEUDO_REGISTER)
+	? (num > 0) && (num <= NCPU32K_LAST_INT_REG)
+	: (reg_renumber[num] > 0) && (reg_renumber[num] <= NCPU32K_LAST_INT_REG);
+    }
+  else
+    {
+      return (num <= NCPU32K_LAST_INT_REG) || (num >= FIRST_PSEUDO_REGISTER);
+    }
+}
+
+/* LEGITIMATE_PIC_OPERAND_P */
+int
+ncpu32k_legitimate_pic_operand_p (rtx x)
+{
+  if (GET_CODE (x) == CONST
+      && GET_CODE (XEXP (x, 0)) == PLUS
+      && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
+	   && (!SYMBOL_REF_LOCAL_P (XEXP (XEXP (x, 0), 0))
+	       || SYMBOL_REF_WEAK (XEXP (XEXP (x, 0), 0))))
+	  || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)
+      && CONST_INT_P (XEXP (XEXP (x, 0), 1)))
+    return ncpu32k_legitimate_displacement_p (SImode, XEXP (XEXP (x, 0), 1));
+
+  return 1;
+}
+
+static bool
+ncpu32k_expand_pic_symbol_ref (enum machine_mode mode ATTRIBUTE_UNUSED,
+			    rtx operands[])
+{
+  if (GET_CODE (operands[1]) == LABEL_REF
+      || (GET_CODE (operands[1]) == SYMBOL_REF
+	  && SYMBOL_REF_LOCAL_P (operands[1])
+	  && !SYMBOL_REF_WEAK (operands[1])))
+    {
+      crtl->uses_pic_offset_table = 1;
+      emit_insn (gen_movsi_gotoff_hi (operands[0], operands[1]));
+      emit_insn (gen_movsi_gotoff_lo (operands[0], operands[0],
+				     operands[1]));
+      emit_insn (gen_add3_insn(operands[0], operands[0],
+			       pic_offset_table_rtx));
+      return true;
+    }
+  else if (GET_CODE (operands[1]) == SYMBOL_REF)
+    {
+      crtl->uses_pic_offset_table = 1;
+      emit_insn (gen_movsi_got (operands[0], operands[1]));
+      return true;
+    }
+  else if (GET_CODE (operands[1]) == CONST
+	   && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT)
+    {
+      rtx symbolref = XEXP (XEXP (operands[1], 0), 0);
+      crtl->uses_pic_offset_table = 1;
+
+      if (SYMBOL_REF_LOCAL_P (symbolref)
+	  && !SYMBOL_REF_WEAK (symbolref))
+	{
+	  emit_insn (gen_movsi_gotoff_hi (operands[0], operands[1]));
+	  emit_insn (gen_movsi_gotoff_lo (operands[0], operands[0],
+					 operands[1]));
+	  emit_insn (gen_add3_insn(operands[0], operands[0],
+				   pic_offset_table_rtx));
+	}
+      else
+	{
+	  rtx const_int = XEXP (XEXP (operands[1], 0), 1);
+
+	  /* Expand the constant into a register if it doesn't
+	     fit directly as an "I" immediate in the add below.
+	     Note that the reg allocation is allowed here since
+	     we are guarded by LEGITIMATE_PIC_OPERAND_P. */
+	  if (!ncpu32k_legitimate_displacement_p (mode, const_int))
+	    {
+	      rtx scratch = gen_reg_rtx (mode);
+
+	      ncpu32k_emit_set_const32 (scratch, const_int);
+	      const_int = scratch;
+	    }
+
+	  emit_insn (gen_movsi_got (operands[0], symbolref));
+	  emit_insn (gen_add3_insn(operands[0], operands[0], const_int));
+	}
+      return true;
+    }
+  return false;
+}
+
+/** Return the TLS type for TLS symbols, 0 otherwise.  */
+enum tls_model
+ncpu32k_tls_symbolic_operand (rtx op)
+{
+  if (GET_CODE (op) == CONST)
+    {
+      rtx sym, addend;
+      split_const (op, &sym, &addend);
+      if (GET_CODE (sym) == SYMBOL_REF)
+	return SYMBOL_REF_TLS_MODEL (sym);
+    }
+  else if (GET_CODE (op) == SYMBOL_REF)
+    return SYMBOL_REF_TLS_MODEL (op);
+
+  return TLS_MODEL_NONE;
+}
+
+static GTY(()) rtx gen_tls_tga;
+
+/** Get reference to the '__tls_get_addr' symbol */
+static rtx
+gen_tls_get_addr (void)
+{
+  if (!gen_tls_tga)
+    gen_tls_tga = init_one_libfunc ("__tls_get_addr");
+  return gen_tls_tga;
+}
+
+/** Emit call to '__tls_get_addr' */
+static void
+ncpu32k_tls_call (rtx dest, rtx arg)
+{
+  emit_library_call_value (gen_tls_get_addr(), dest,
+      LCT_CONST, Pmode, 1, arg, Pmode);
+}
+
+static rtx
+ncpu32k_legitimize_tls_address (rtx dest, rtx x)
+{
+  rtx sym;
+  rtx tp = gen_rtx_REG(Pmode, THREAD_PTR_REGNUM);
+  rtx addend = NULL_RTX;
+  rtx result = dest;
+
+  enum tls_model tls_kind = ncpu32k_tls_symbolic_operand (x);
+
+  if (GET_CODE (x) == SYMBOL_REF)
+    sym = gen_rtx_SYMBOL_REF(Pmode, XSTR(x, 0));
+  else if (GET_CODE (x) == CONST)
+    {
+      result = gen_reg_rtx (Pmode);
+      split_const (x, &sym, &addend);
+      sym = gen_rtx_SYMBOL_REF(Pmode, XSTR(sym, 0));
+    }
+  else
+    gcc_unreachable ();
+
+  switch (tls_kind) {
+    case TLS_MODEL_GLOBAL_DYNAMIC:
+    case TLS_MODEL_LOCAL_DYNAMIC:
+      {
+        /* TODO: For now, treat LD as GD */
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx offset = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        crtl->uses_pic_offset_table = 1;
+        /* Generate a new symbol ref that is not marked as TLS or we will recurse
+         * in ncpu32k_legitimate_constant_p. */
+        emit_insn (gen_movsi_tlsgdhi (hi, sym));
+        emit_insn (gen_movsi_tlsgdlo (offset, hi, sym));
+        emit_insn (gen_add3_insn (addr, offset, pic_offset_table_rtx));
+        ncpu32k_tls_call (result, addr);
+        break;
+      }
+    case TLS_MODEL_INITIAL_EXEC:
+      {
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx offset = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        rtx tpoffset = gen_reg_rtx (Pmode);
+        crtl->uses_pic_offset_table = 1;
+        emit_insn (gen_movsi_gottpoffhi (hi, sym));
+        emit_insn (gen_movsi_gottpofflo (offset, hi, sym));
+        emit_insn (gen_add3_insn (addr, offset, pic_offset_table_rtx));
+        emit_insn (gen_load_gottpoff (tpoffset, addr));
+        emit_insn (gen_add3_insn (result, tpoffset, tp));
+        break;
+      }
+    case TLS_MODEL_LOCAL_EXEC:
+      {
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        emit_insn (gen_movsi_tpoffhi (hi, sym));
+        emit_insn (gen_movsi_tpofflo (addr, hi, sym));
+        emit_insn (gen_add3_insn (result, addr, tp));
+        break;
+      }
+    default:
+      gcc_unreachable ();
+  }
+
+  if (addend != NULL_RTX)
+    emit_insn (gen_add3_insn (dest, result, addend));
+
+  return dest;
+}
+
+static rtx
+ncpu32k_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
+                         enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  if (ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE)
+    return ncpu32k_legitimize_tls_address (gen_reg_rtx (Pmode), x);
+
+  return x;
+}
+
+static bool
+ncpu32k_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  return ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE;
+}
+
+bool
+ncpu32k_expand_symbol_ref(enum machine_mode mode, rtx operands[])
+{
+  if (flag_pic && ncpu32k_expand_pic_symbol_ref(mode, operands))
+    return true;
+
+  return false;
+}
+
+bool
+ncpu32k_expand_move (enum machine_mode mode, rtx operands[])
+{
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) == MEM
+	  || (GET_CODE (operands[0]) == SUBREG
+	      && GET_CODE (SUBREG_REG (operands[0])) == MEM))
+        {
+          /* Source operand for store must be in a register.  */
+          operands[1] = force_reg (SImode, operands[1]);
+        }
+    }
+
+  if (ncpu32k_tls_symbolic_operand (operands[1]) != TLS_MODEL_NONE)
+    {
+      ncpu32k_legitimize_tls_address (force_reg (Pmode, operands[0]),
+          operands[1]);
+      return true;
+    }
+
+  if (ncpu32k_expand_symbol_ref (mode, operands))
+    return true;
+
+  /* Working with CONST_INTs is easier, so convert
+     a double if needed.  */
+
+  if (GET_CODE (operands[1]) == CONST_DOUBLE) {
+    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));
+  }
+
+  /* Handle sets of MEM first.  */
+  if (GET_CODE (operands[0]) == MEM)
+    {
+      if (register_operand(operands[1], SImode)
+          || (operands[1] == const0_rtx))
+        goto movsi_is_ok;
+
+      if (! reload_in_progress)
+        {
+          operands[0] = validize_mem (operands[0]);
+          operands[1] = force_reg (SImode, operands[1]);
+        }
+    }
+
+  /* This makes sure we will not get rematched due to splittage.  */
+  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], SImode))
+    ;
+  else if (CONSTANT_P (operands[1])
+           && GET_CODE (operands[1]) != HIGH
+           && GET_CODE (operands[1]) != LO_SUM)
+    {
+      ncpu32k_emit_set_const32 (operands[0], operands[1]);
+      return true;
+    }
+ movsi_is_ok:
+  ;
+
+  return false;
+}
+
+/**
+ * Emit a move from SRC to DEST.
+ *
+ *  Assume that the move expanders can handle all moves if !can_create_pseudo_p
+ *  ().  The distinction is important because, unlike emit_move_insn, the move
+ *  expanders know how to force Pmode objects into the constant pool even when
+ *  the constant pool address is not itself legitimate.
+ *
+ *  @param[in] dest  Destination of the move.
+ *  @param[in] src   Source for the move.
+ *  @return  RTX for the move.
+ */
+static rtx
+ncpu32k_emit_move (rtx dest, rtx src)
+{
+  return (can_create_pseudo_p ()
+	  ? emit_move_insn (dest, src)
+	  : emit_move_insn_1 (dest, src));
+
+}
+
+
+/**
+ * Emit an instruction of the form (set TARGET (CODE OP0 OP1)).
+ *
+ * @param[in] code    The code for the operation.
+ * @param[in] target  Destination for the set operation.
+ * @param[in] op0     First operand.
+ * @param[in] op1     Second operand.
+ */
+static void
+ncpu32k_emit_binary (enum rtx_code  code,
+		  rtx            target,
+		  rtx            op0,
+		  rtx            op1)
+{
+  emit_insn (gen_rtx_SET (VOIDmode, target,
+			  gen_rtx_fmt_ee (code, GET_MODE (target), op0, op1)));
+
+}
+
+
+/**
+ * Compute the result of an operation into a new register.
+ *
+ * Compute ("code" "op0" "op1") and store the result in a new register of mode
+ * "mode".
+ *
+ * @param[in] mode  Mode of the result
+ * @parma[in] code  RTX for the operation to perform
+ * @param[in] op0   RTX for the first operand
+ * @param[in] op1   RTX for the second operand  
+ * @return  The RTX for the new register.
+ */
+static rtx
+ncpu32k_force_binary (enum machine_mode  mode,
+		   enum rtx_code      code,
+		   rtx                op0,
+		   rtx                op1)
+{
+  rtx  reg;
+
+  reg = gen_reg_rtx (mode);
+  ncpu32k_emit_binary (code, reg, op0, op1);
+
+  return reg;
+
+}
+
+
+/*****************************************************************************/
+/* Functions to support the Machine Description                              */
+/*****************************************************************************/
+
+/** Expand the prologue as a series of insns */
+void
+ncpu32k_expand_prologue (void)
+{
+  int total_size = ncpu32k_compute_frame_size (get_frame_size ());
+  int latezone_size;
+  rtx insn;
+
+  if (!total_size)
+    /* No frame needed.  */
+    return;
+
+  gcc_assert (!frame_info.save_lr_p || !frame_info.save_fp_p
+	      || frame_info.lr_save_to_sp1_offset != frame_info.fp_save_to_sp1_offset);
+
+  /* Decrease SP at first to enusure interrupt-safe
+     Allocate the space of regzone */
+  gcc_assert (-frame_info.regzone_size >= CONST_INT_I_MIN);
+  emit_frame_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (-frame_info.regzone_size)));
+  /* Now we're at SP1 */
+
+  if (frame_info.save_fp_p)
+    {
+      emit_frame_insn (gen_rtx_SET (Pmode,
+				    stack_disp_mem (frame_info.fp_save_to_sp1_offset),
+				    hard_frame_pointer_rtx));
+
+      /* Set up new frame pointer */
+      gcc_assert (frame_info.regzone_size <= CONST_INT_I_MAX);
+      emit_frame_insn
+	    (gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx, GEN_INT(frame_info.regzone_size)));
+    }
+  if (frame_info.save_lr_p)
+    {
+      emit_frame_insn
+	(gen_rtx_SET (Pmode, stack_disp_mem (frame_info.lr_save_to_sp1_offset),
+		      gen_rtx_REG (Pmode, LINK_REGNUM)));
+    }
+  if (frame_info.gpr_size)
+    {
+      int offset = 0;
+      int regno;
+
+      for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+	{
+	  if (!(frame_info.mask & ((HOST_WIDE_INT) 1 << regno)))
+	    continue;
+
+	  /* Check that the offsets aren't stepping on lr/fp slots */
+	  gcc_assert (!frame_info.save_lr_p
+		      || ((frame_info.gpr_to_sp1_offset + offset)
+			  != frame_info.lr_save_to_sp1_offset));
+	  gcc_assert (!frame_info.save_fp_p
+		      || ((frame_info.gpr_to_sp1_offset + offset)
+			  != frame_info.fp_save_to_sp1_offset));
+
+	  emit_frame_insn
+	    (gen_rtx_SET (Pmode,
+			  stack_disp_mem (frame_info.gpr_to_sp1_offset + offset),
+			  gen_rtx_REG (Pmode, regno)));
+	  offset = offset + UNITS_PER_WORD;
+	}
+    }
+
+  /* Allocate the space of latezone
+     Update the stack pointer to reflect frame size. */
+  latezone_size = frame_info.latezone_size;
+  insn = gen_add2_insn (stack_pointer_rtx, GEN_INT (-latezone_size));
+  if (latezone_size > CONST_INT_I_MAX+1)
+    {
+      rtx note = insn;
+      rtx value_rtx = gen_rtx_REG (Pmode, PROLOGUE_TMP);
+
+      ncpu32k_emit_set_const32 (value_rtx, GEN_INT (-latezone_size));
+      if (frame_info.save_fp_p)
+	insn = gen_frame_change_clobber_fp (value_rtx); /* allocate fp*/
+      else
+	insn = gen_add2_insn (stack_pointer_rtx, value_rtx);
+      insn = emit_frame_insn (insn);
+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);
+    }
+  else if (latezone_size)
+    {
+      if (frame_info.save_fp_p)
+	emit_frame_insn (gen_frame_change_clobber_fp (GEN_INT (-latezone_size))); /* allocate fp*/
+      else
+	emit_frame_insn (insn);
+    }
+  /* Emit got pointer acquiring if there are any got references or
+     this function has calls */
+  if (crtl->uses_pic_offset_table || (flag_pic && frame_info.save_lr_p))
+    {
+      SET_REGNO (pic_offset_table_rtx, PIC_OFFSET_TABLE_REGNUM);
+      emit_insn (gen_set_got (pic_offset_table_rtx));
+    }
+  /* Now we're at SP2 */
+}
+
+/** Expand the epilogue as a series of insns. */
+void
+ncpu32k_expand_epilogue (void)
+{
+  int latezone_size;
+  rtx value_rtx;
+
+  ncpu32k_compute_frame_size (get_frame_size ());
+
+  /* Deallocate the space of latezone */
+  latezone_size = frame_info.latezone_size;
+  if (latezone_size > CONST_INT_I_MAX)
+	{
+	  value_rtx = gen_rtx_REG (Pmode, EPILOGUE_TMP);
+	  ncpu32k_emit_set_const32 (value_rtx, GEN_INT (latezone_size));
+	}
+  else if (latezone_size)
+	value_rtx = GEN_INT (latezone_size);
+  if (latezone_size)
+	emit_insn (gen_frame_dealloc_clobber_sp (value_rtx));
+  /* Now we're at SP1 */
+
+  if (frame_info.gpr_size)
+    {
+      int offset = 0;
+      int regno;
+
+      for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+	{
+	  if (!(frame_info.mask & ((HOST_WIDE_INT) 1 << regno)))
+	    continue;
+
+	  if (regno != FIRST_PSEUDO_REGISTER)
+	    emit_insn
+	      (gen_rtx_SET (Pmode, gen_rtx_REG (Pmode, regno),
+			    stack_disp_mem (frame_info.gpr_to_sp1_offset + offset)));
+	  offset = offset + UNITS_PER_WORD;
+	}
+    }
+
+  /* eh_return sets the LNK reg, do not overwrite it */
+  if (frame_info.save_lr_p && !crtl->calls_eh_return)
+    {
+      emit_insn
+        (gen_rtx_SET (Pmode, gen_rtx_REG (Pmode, LINK_REGNUM),
+                      stack_disp_mem (frame_info.lr_save_to_sp1_offset)));
+    }
+
+  /* Decrease SP at last to ensure interrupt-safe */
+  if (frame_info.save_fp_p)
+    {
+      /* The order of the following two instructions is important,
+       * because the frame should be deallocated after it is no longer accessed
+       */
+      emit_insn
+	    (gen_rtx_SET (Pmode, hard_frame_pointer_rtx,
+		      stack_disp_mem (frame_info.fp_save_to_sp1_offset)));
+      emit_insn (gen_frame_change_clobber_fp (GEN_INT(frame_info.regzone_size))); /* deallocate fp */
+    }
+  else
+    {
+      emit_insn (gen_frame_dealloc_clobber_sp (GEN_INT(frame_info.regzone_size))); /* deallocate sp */
+    }
+
+  if (crtl->calls_eh_return)
+    emit_insn (gen_add2_insn (stack_pointer_rtx, EH_RETURN_STACKADJ_RTX));
+
+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LINK_REGNUM)));
+
+}
+
+
+/**
+ * Generate assembler code for a movdi/movdf pattern
+ *
+ * @param[in] operands  Operands to the movdx pattern.
+ * @return  The assembler string to output (always "", since we've done the
+ *          output here).
+ */
+const char *
+ncpu32k_output_move_double (rtx *operands)
+{
+  rtx xoperands[3];
+
+  switch (GET_CODE (operands[0]))
+    {
+    case REG:
+      if (GET_CODE (operands[1]) == REG)
+	{
+	  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)
+	    {
+	      output_asm_insn ("\tor \t%H0,%H1,r0", operands);
+	      output_asm_insn ("\tor \t%0,%1,r0", operands);
+	      return "";
+	    }
+	  else
+	    {
+	      output_asm_insn ("\tor \t%0,%1,r0", operands);
+	      output_asm_insn ("\tor \t%H0,%H1,r0", operands);
+	      return "";
+	    }
+	}
+      else if (GET_CODE (operands[1]) == MEM)
+	{
+	  xoperands[1] = XEXP (operands[1], 0);
+	  if (GET_CODE (xoperands[1]) == REG)
+	    {
+	      xoperands[0] = operands[0];
+	      if (REGNO (xoperands[0]) == REGNO (xoperands[1]))
+		{
+		  output_asm_insn ("\tldwu \t%H0,4(%1)", xoperands);
+		  output_asm_insn ("\tldwu \t%0,0(%1)", xoperands);
+		  return "";
+		}
+	      else
+		{
+		  output_asm_insn ("\tldwu \t%0,0(%1)", xoperands);
+		  output_asm_insn ("\tldwu \t%H0,4(%1)", xoperands);
+		  return "";
+		}
+	    }
+	  else if (GET_CODE (xoperands[1]) == PLUS)
+	    {
+	      if (GET_CODE (xoperands[2] = XEXP (xoperands[1], 1)) == REG)
+		{
+		  xoperands[0] = operands[0];
+		  xoperands[1] = XEXP (xoperands[1], 0);
+		  if (REGNO (xoperands[0]) == REGNO (xoperands[2]))
+		    {
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)",
+				       xoperands);
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      return "";
+		    }
+		  else
+		    {
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)", xoperands);
+		      return "";
+		    }
+		}
+	      else if (GET_CODE (xoperands[2] = XEXP (xoperands[1], 0)) ==
+		       REG)
+		{
+		  xoperands[0] = operands[0];
+		  xoperands[1] = XEXP (xoperands[1], 1);
+		  if (REGNO (xoperands[0]) == REGNO (xoperands[2]))
+		    {
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)",
+				       xoperands);
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      return "";
+		    }
+		  else
+		    {
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)", xoperands);
+		      return "";
+		    }
+		}
+	      else
+		abort ();
+	    }
+	  else
+	    abort ();
+	}
+      else
+	abort ();
+    case MEM:
+      xoperands[0] = XEXP (operands[0], 0);
+      if (GET_CODE (xoperands[0]) == REG)
+	{
+	  xoperands[1] = operands[1];
+	  output_asm_insn ("\tstw \t0(%0),%1", xoperands);
+	  output_asm_insn ("\tstw \t4(%0),%H1", xoperands);
+	  return "";
+	}
+      else if (GET_CODE (xoperands[0]) == PLUS)
+	{
+	  if (GET_CODE (xoperands[1] = XEXP (xoperands[0], 1)) == REG)
+	    {
+	      xoperands[0] = XEXP (xoperands[0], 0);
+	      xoperands[2] = operands[1];
+	      output_asm_insn ("\tstw \t%0(%1),%2", xoperands);
+	      output_asm_insn ("\tstw \t%0+4(%1),%H2", xoperands);
+	      return "";
+	    }
+	  else if (GET_CODE (xoperands[1] = XEXP (xoperands[0], 0)) == REG)
+	    {
+	      xoperands[0] = XEXP (xoperands[0], 1);
+	      xoperands[2] = operands[1];
+	      output_asm_insn ("\tstw \t%0(%1),%2", xoperands);
+	      output_asm_insn ("\tstw \t%0+4(%1),%H2", xoperands);
+	      return "";
+	    }
+	  else
+	    abort ();
+	}
+      else
+	{
+	  fprintf (stderr, "  O/p error %s\n", GET_RTX_NAME (GET_CODE (xoperands[0])));
+	  return "";
+	  /* abort (); */
+	}
+    default:
+      abort ();
+    }
+}
+
+
+/**
+ * Load a 32-bit constant.
+ *
+ * We know it can't be done in one insn when we get here, the movsi expander
+ * guarantees this.
+ *
+ * @param[in] op0  RTX for the destination.
+ * @param[in] op1  RTX for the (constant) source.
+ */
+void
+ncpu32k_emit_set_const32 (rtx  op0,
+		       rtx  op1)
+{
+  enum machine_mode mode = GET_MODE (op0);
+  rtx temp;
+
+  /* Sanity check that we really can't do it in one instruction. I.e that we
+     don't have a "I" constant. */
+  if (GET_CODE (op1) == CONST_INT)
+    {
+      HOST_WIDE_INT val = INTVAL (op1) & GET_MODE_MASK (mode);
+
+      if ((CONST_INT_I_MIN <= val) && (val <= CONST_INT_I_MAX))
+	{
+	  abort ();
+	}
+    }
+
+  /* Full 2-insn decomposition is needed.  */
+  if (reload_in_progress || reload_completed)
+    temp = op0;
+  else
+    temp = gen_reg_rtx (mode);
+
+  if (GET_CODE (op1) == CONST_INT)
+    {
+      /* Emit them as real moves instead of a HIGH/LO_SUM,
+         this way CSE can see everything and reuse intermediate
+         values if it wants.  */
+      emit_insn (gen_rtx_SET (VOIDmode, temp,
+			      GEN_INT (INTVAL (op1)
+				       & ~(HOST_WIDE_INT) MASK_UINT_I)));
+
+      emit_insn (gen_rtx_SET (VOIDmode,
+			      op0,
+			      gen_rtx_IOR (mode, temp,
+					   GEN_INT (INTVAL (op1) & MASK_UINT_I))));
+    }
+  else
+    {
+      /* since ncpu32k bfd can not deal with relocs that are not of type
+         NCPU32K_CONSTH_RELOC + NCPU32K_CONST_RELOC (ie move high must be
+         followed by exactly one lo_sum)
+       */
+      emit_insn (gen_movsi_insn_big (op0, op1));
+    }
+}
+
+void
+ncpu32k_emit_set_const16 (rtx  op0,
+		       rtx  op1)
+{
+  enum machine_mode mode = GET_MODE (op0);
+  rtx temp;
+  
+  /* Sanity check that we are setting a const */
+  if (GET_CODE (op1) != CONST_INT)
+    {
+      abort ();
+    }
+  /* Sanity check that we really can't do it in one instruction. I.e that we
+     don't have a "I" constant. */
+  HOST_WIDE_INT val = INTVAL (op1) & GET_MODE_MASK (mode);
+
+  if ((CONST_INT_I_MIN <= val) && (val <= CONST_INT_I_MAX))
+    {
+      abort ();
+    }
+
+  /* Full 2-insn decomposition is needed.  */
+  if (reload_in_progress || reload_completed)
+    temp = op0;
+  else
+    temp = gen_reg_rtx (mode);
+
+  /* Emit them as real moves instead of a HIGH/LO_SUM,
+   this way CSE can see everything and reuse intermediate
+   values if it wants.  */
+  emit_insn (gen_rtx_SET (VOIDmode, temp,
+  		      GEN_INT (INTVAL (op1)
+  			       & ~(HOST_WIDE_INT) MASK_UINT_I)));
+
+  emit_insn (gen_rtx_SET (VOIDmode,
+  		      op0,
+  		      gen_rtx_IOR (mode, temp,
+  				   GEN_INT (INTVAL (op1) & MASK_UINT_I))));
+}
+
+
+/*****************************************************************************/
+/* Target hook functions.                                                    */
+/*****************************************************************************/
+
+/*
+ These are initialized at the end of this file, to avoid having to
+ predeclare all the functions. They are only needed here, so are static.    */
+
+
+
+
+/* -------------------------------------------------------------------------- */
+/*!Define where a function returns values.
+
+   Define this to return an RTX representing the place where a function
+   returns or receives a value of data type ret type, a tree node representing
+   a data type.  "func" is a tree node representing FUNCTION_DECL or
+   FUNCTION_TYPE of a function being called. If "outgoing" is false, the hook
+   should compute the register in which the caller will see the return
+   value. Otherwise, the hook should return an RTX representing the place
+   where a function returns a value.
+
+   On many machines, only TYPE_MODE ("ret_type") is relevant. (Actually, on
+   most machines, scalar values are returned in the same place regardless of
+   mode.) The value of the expression is usually a reg RTX for the hard
+   register where the return value is stored. The value can also be a parallel
+   RTX, if the return value is in multiple places. See FUNCTION_ARG for an
+   explanation of the parallel form. Note that the callee will populate every
+   location specified in the parallel, but if the first element of the
+   parallel contains the whole return value, callers will use that element as
+   the canonical location and ignore the others. The m68k port uses this type
+   of parallel to return pointers in both %a0 (the canonical location) and
+   %d0.
+
+   If TARGET_PROMOTE_FUNCTION_RETURN returns true, you must apply the same
+   promotion rules specified in PROMOTE_MODE if valtype is a scalar type.
+
+   If the precise function being called is known, "func" is a tree node
+   (FUNCTION_DECL) for it; otherwise, "func" is a null pointer. This makes it
+   possible to use a different value-returning convention for specific
+   functions when all their calls are known.
+
+   Some target machines have "register windows" so that the register in which
+   a function returns its value is not the same as the one in which the caller
+   sees the value. For such machines, you should return different RTX
+   depending on outgoing.
+
+   TARGET_FUNCTION_VALUE is not used for return values with aggregate data
+   types, because these are returned in another way. See
+   TARGET_STRUCT_VALUE_RTX and related macros.
+
+   For the NCPU32K, we can just use the result of LIBCALL_VALUE, since all
+   functions return their result in the same place (register rv).
+
+   FIXME?: What about 64-bit scalar returns (long long int, double),
+                  which also use rvh (=r12)?
+
+   @param[in] ret_type  The return type of the function.
+   @param[in] func      Tree representing function being called.
+   @param[in] outgoing  Non-zero (TRUE) if the result represents where the
+                        function places the results, zero (FALSE) if the
+                        result represents where the caller sees the result.
+
+   @return  A RTX representing where the result can be found.                 */
+/* -------------------------------------------------------------------------- */
+static rtx
+ncpu32k_function_value (const_tree  ret_type,
+		     const_tree  func ATTRIBUTE_UNUSED,
+                     bool        outgoing ATTRIBUTE_UNUSED)
+{
+  return LIBCALL_VALUE (TYPE_MODE(ret_type));
+
+}	/* ncpu32k_function_value () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Check if a function is suitable for tail call optimization.
+
+   True if it is OK to do sibling call optimization for the specified call
+   expression "exp". "decl" will be the called function, or NULL if this is an
+   indirect call.
+
+   It is not uncommon for limitations of calling conventions to prevent tail
+   calls to functions outside the current unit of translation, or during PIC
+   compilation. The hook is used to enforce these restrictions, as the sibcall
+   md pattern can not fail, or fall over to a normal call. The criteria for
+   successful sibling call optimization may vary greatly between different
+   architectures.
+
+   For the NCPU32K, we currently don't allow sibcalls.
+
+   @param[in] decl  The function for which we may optimize
+   @param[in] exp   The call expression which is candidate for optimization.
+
+   @return  Non-zero (TRUE) if sibcall optimization is permitted, zero (FALSE)
+            otherwise.                                                        */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_function_ok_for_sibcall (tree  decl ATTRIBUTE_UNUSED,
+			      tree  exp ATTRIBUTE_UNUSED)
+{
+  return 0;
+}	/* ncpu32k_function_ok_for_sibcall () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Should an argument be passed by reference.
+
+   This target hook should return true if an argument at the position
+   indicated by "cum" should be passed by reference. This predicate is queried
+   after target independent reasons for being passed by reference, such as
+   TREE_ADDRESSABLE ("type").
+
+   If the hook returns TRUE, a copy of that argument is made in memory and a
+   pointer to the argument is passed instead of the argument itself. The
+   pointer is passed in whatever way is appropriate for passing a pointer to
+   that type.
+
+   For the NCPU32K, all aggregates and arguments greater than 8 bytes are passed
+   this way.
+
+   @param[in] cum    Position of argument under consideration.
+   @param[in[ mode   Not sure what this relates to.
+   @param[in] type   Type of the argument.
+   @param[in] named  Not sure what this relates to.
+
+   @return  Non-zero (TRUE) if the argument should be passed by reference,
+            zero (FALSE) otherwise.                                           */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_pass_by_reference (cumulative_args_t  cum ATTRIBUTE_UNUSED,
+                        enum machine_mode  mode ATTRIBUTE_UNUSED,
+                        const_tree         type,
+                        bool               named ATTRIBUTE_UNUSED)
+{
+  return (type && (AGGREGATE_TYPE_P (type) || int_size_in_bytes (type) > 8));
+
+}	/* ncpu32k_pass_by_reference () */
+
+
+/* INITIAL_ELIMINATION_OFFSET */
+int
+ncpu32k_initial_elimination_offset(int from, int to)
+{
+  ncpu32k_compute_frame_size (get_frame_size ());
+  return ((from == FRAME_POINTER_REGNUM
+	   ? frame_info.gpr_offset : 0)
+	  + (to == STACK_POINTER_REGNUM ? frame_info.total_size : 0));
+}
+
+
+/* -------------------------------------------------------------------------- */
+/*!How many bytes at the beginning of an argument must be put into registers.
+
+   This target hook returns the number of bytes at the beginning of an
+   argument that must be put in registers. The value must be zero for
+   arguments that are passed entirely in registers or that are entirely pushed
+   on the stack.
+
+   On some machines, certain arguments must be passed partially in registers
+   and partially in memory. On these machines, typically the first few words
+   of arguments a re passed in registers, and the rest on the stack. If a
+   multi-word argument (a double or a structure) crosses that boundary, its
+   first few words must be passed in registers and the rest must be
+   pushed. This macro tells the compiler when this occurs, and how many bytes
+   should go in registers.
+
+   FUNCTION_ARG for these arguments should return the first register to be
+   used by the caller for this argument; likewise FUNCTION_INCOMING_ARG, for
+   the called function.
+
+   On the NCPU32K we never split argumetns between registers and memory.
+
+   @param[in] cum    Position of argument under consideration.
+   @param[in[ mode   Not sure what this relates to.
+   @param[in] type   Type of the argument.
+   @param[in] named  Not sure what this relates to.
+
+   @return  The number of bytes of the argument to go into registers          */
+/* -------------------------------------------------------------------------- */
+static int
+ncpu32k_arg_partial_bytes (cumulative_args_t cum ATTRIBUTE_UNUSED,
+                        enum machine_mode  mode ATTRIBUTE_UNUSED,
+                        tree               type ATTRIBUTE_UNUSED,
+                        bool               named ATTRIBUTE_UNUSED)
+{
+  return 0;
+
+}	/* ncpu32k_arg_partial_bytes () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Promote the mode of a function's arguments/return value.
+
+   Like PROMOTE_MODE, but it is applied to outgoing function arguments or
+   function return values. The target hook should return the new mode and
+   possibly change "*punsignedp" if the promotion should change
+   signedness. This function is called only for scalar or pointer types.
+
+   "for_return" allows to distinguish the promotion of arguments and return
+   values. If it is 1, a return value is being promoted and
+   TARGET_FUNCTION_VALUE must perform the same promotions done here. If it is
+   2, the returned mode should be that of the register in which an incoming
+   parameter is copied, or the outgoing result is computed; then the hook
+   should return the same mode as PROMOTE_MODE, though the signedness may be
+   different.
+
+   The default is to not promote arguments and return values. You can also
+   define the hook to "default_promote_function_mode_always_promote" if you
+   would like to apply the same rules given by PROMOTE_MODE.
+
+   For the NCPU32K, if the size of the mode is integral and less than 4, we
+   promote to SImode, otherwise we return the mode we are supplied.
+
+   @param[in]  type        Not sure. Type of the argument?
+   @param[in]  mode        The mode of argument/return value to consider.
+   @param[out] punsignedp  Signedness of the value.
+   @param[in]  fntype      Not sure. Type of the function?
+   @param[in]  for_return  1 if a return value, 2 if an incoming value.
+
+   @return  The new mode.                                                     */
+/* -------------------------------------------------------------------------- */
+static enum machine_mode
+ncpu32k_promote_function_mode (const_tree         type ATTRIBUTE_UNUSED,
+			    enum machine_mode  mode,
+			    int               *punsignedp ATTRIBUTE_UNUSED,
+			    const_tree         fntype ATTRIBUTE_UNUSED,
+			    int                for_return ATTRIBUTE_UNUSED)
+{
+  return (   (GET_MODE_CLASS (mode) == MODE_INT)
+	  && (GET_MODE_SIZE (mode) < 4)) ? SImode : mode;
+
+}	/* ncpu32k_promote_function_mode () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Is this a legitimate address?
+
+  A function that returns whether x (an RTX) is a legitimate memory address on
+  the target machine for a memory operand of mode mode.
+
+  Legitimate addresses are defined in two variants: a strict variant and a
+  non-strict one.  The strict parameter chooses which variant is desired by
+  the caller.
+
+  The strict variant is used in the reload pass. It must be defined so that
+  any pseudo- register that has not been allocated a hard register is
+  considered a memory reference.  This is because in contexts where some kind
+  of register is required, a pseudo-register with no hard register must be
+  rejected. For non-hard registers, the strict variant should look up the
+  reg_renumber array; it should then proceed using the hard register number in
+  the array, or treat the pseudo as a memory reference if the array holds -1.
+
+  The non-strict variant is used in other passes. It must be defined to accept
+  all pseudo-registers in every context where some kind of register is
+  required.
+
+  Normally, constant addresses which are the sum of a symbol_ref and an
+  integer are stored inside a const RTX to mark them as constant. Therefore,
+  there is no need to recognize such sums specifically as legitimate
+  addresses. Normally you would simply recognize any const as legitimate.
+
+  Usually PRINT_OPERAND_ADDRESS is not prepared to handle constant sums that
+  are not marked with const. It assumes that a naked plus indicates
+  indexing. If so, then you must reject such naked constant sums as
+  illegitimate addresses, so that none of them will be given to
+  PRINT_OPERAND_ADDRESS.
+
+  On some machines, whether a symbolic address is legitimate depends on the
+  section that the address refers to. On these machines, define the target
+  hook TARGET_ENCODE_ SECTION_INFO to store the information into the
+  symbol_ref, and then check for it here. When you see a const, you will have
+  to look inside it to find the symbol_ref in order to determine the
+  section. See the internals manual section on "Assembler Format" for more
+  info.
+
+  Some ports are still using a deprecated legacy substitute for this hook, the
+  GO_IF_LEGITIMATE_ADDRESS macro. This macro has this syntax:
+
+    #define GO_IF_LEGITIMATE_ADDRESS (mode, x, label )
+
+  and should goto label if the address x is a valid address on the target
+  machine for a memory operand of mode mode. Whether the strict or non-strict
+  variants are desired is defined by the REG_OK_STRICT macro introduced
+  earlier in this section. Using the hook is usually simpler because it limits
+  the number of files that are recompiled when changes are made.
+
+   The NCPU32K only has a single addressing mode, which is a base register with
+   "I" displacement. We can accept just "I" constants as addresses (they
+   can use r0 as base address, and we can accept plain registers as addresses
+   (they can use a displacement of zero).
+
+   @param[in] mode    The mode of the address
+   @param[in] x       The address (RTX)
+   @param[in] strict  Non-zero (TRUE) if we are in "strict" mode, zero (FALSE)
+                      otherwise.
+
+   @return  Non-zero (TRUE) if this is a legitimate address, zero (FALSE)
+            otherwise.                                                        */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_legitimate_address_p (enum machine_mode  mode ATTRIBUTE_UNUSED,
+			   rtx                x,
+			   bool               strict)
+{
+  /* Addresses consisting of a register and "I" displacement are also
+     suitable. We need the mode, since for double words, we had better be
+     able to address the full 8 bytes. */
+  if (GET_CODE(x) == PLUS)
+    {
+      rtx reg = XEXP(x,0);
+
+      /* If valid register... */
+      if ((GET_CODE(reg) == REG)
+          && ncpu32k_regnum_ok_for_base_p (REGNO (reg), strict))
+        {
+          rtx offset = XEXP(x,1);
+
+          /* ...and valid offset */
+          if (ncpu32k_legitimate_displacement_p (mode, offset))
+            {
+              return 1;
+            }
+        }
+    }
+
+  /* Addresses consisting of just a register are OK. They can be built into
+     addresses using an offset of zero (and an offset of four if double
+     word). */
+  if (GET_CODE(x) == REG
+    && ncpu32k_regnum_ok_for_base_p(REGNO(x),strict)) {
+      return 1;
+  }
+
+  return 0;
+}
+
+static int
+ncpu32k_trampoline_code_words (void)
+{
+  return 5;
+}
+
+/* -------------------------------------------------------------------------- */
+/*!Initialize a trampoline for nested functions.
+
+   A nested function is defined by *two* pieces of information, the address of
+   the function (like any other function) and a pointer to the frame of the
+   enclosing function. The latter is required to allow the nested function to
+   access local variables in the enclosing function's frame.
+
+   This represents a problem, since a function in C is represented as an
+   address that can be held in a single variable as a pointer. Requiring two
+   pointers will not fit.
+
+   The solution is documented in "Lexical Closures for C++" by Thomas
+   M. Breuel (USENIX C++ Conference Proceedings, October 17-21, 1988). The
+   nested function is represented by a small block of code and data on the
+   enclosing function's stack frame, which sets up a pointer to the enclosing
+   function's stack frame (the static chain pointer) in a register defined by
+   the ABI, and then jumps to the code of the function proper.
+
+   The function can be represented as a single pointer to this block of code,
+   known as a trampoline, which when called generates both pointers
+   needed. The nested function (which knows it is a nested function at compile
+   time) can then generate code to access the enclosing frame via the static
+   chain register.
+
+   There is a catch that the trampoline is set up as data, but executed as
+   instructions. The former will be via the data cache, the latter via the
+   instruction cache. There is a risk that a later trampoline will not be seen
+   by the instruction cache, so the wrong code will be executed. So the
+   instruction cache should be flushed for the trampoline address range.
+
+   This hook is called to initialize a trampoline. "m_tramp" is an RTX for the
+   memory block for the trampoline; "fndecl" is the FUNCTION_DECL for the
+   nested function; "static_chain" is an RTX for the static chain value that
+   should be passed to the function when it is called.
+
+   If the target defines TARGET_ASM_TRAMPOLINE_TEMPLATE, then the first thing
+   this hook should do is emit a block move into "m_tramp" from the memory
+   block returned by assemble_trampoline_template. Note that the block move
+   need only cover the constant parts of the trampoline. If the target
+   isolates the variable parts of the trampoline to the end, not all
+   TRAMPOLINE_SIZE bytes need be copied.
+
+   If the target requires any other actions, such as flushing caches or
+   enabling stack execution, these actions should be performed after
+   initializing the trampoline proper.
+
+   For the NCPU32K, no static chain register is used. We choose to use the return
+   value (rv) register. The code is based on that for MIPS.
+
+   @note FIXME! For the NCPU32K we need to flush the instruction cache, which is a
+         privileged operation. Needs fixing.
+
+   @param[in] m_tramp      The lowest address of the trampoline on the stack.
+   @param[in] fndecl       Declaration of the enclosing function.
+   @param[in] chain_value  Static chain pointer to pass to the nested
+                           function.                                          */
+/* -------------------------------------------------------------------------- */
+static void
+ncpu32k_trampoline_init (rtx   m_tramp,
+		      tree  fndecl,
+		      rtx   chain_value)
+{
+  rtx  addr;				/* Start address of the trampoline */
+  rtx  end_addr;			/* End address of the code block */
+
+  rtx  high;				/* RTX for the high part of end_addr */
+  rtx  low;				/* RTX for the low part of end_addr */
+  rtx  opcode;				/* RTX for generated opcodes */
+  rtx  mem;				/* RTX for trampoline memory */
+
+  rtx *trampoline;	/* The trampoline code */
+
+  unsigned int  i;			/* Index into trampoline */
+  unsigned int  j;			/* General counter */
+
+  HOST_WIDE_INT  end_addr_offset;	  /* Offset to end of code */
+  HOST_WIDE_INT  static_chain_offset;	  /* Offset to stack chain word */
+  HOST_WIDE_INT  target_function_offset;  /* Offset to func address word */
+
+  /* Work out the offsets of the pointers from the start of the trampoline
+     code.  */
+  trampoline             = (rtx*) alloca (ncpu32k_trampoline_code_words() * sizeof(rtx));
+  end_addr_offset        = ncpu32k_trampoline_code_size ();
+  static_chain_offset    = end_addr_offset;
+  target_function_offset = static_chain_offset + GET_MODE_SIZE (ptr_mode);
+
+  /* Get pointers in registers to the beginning and end of the code block.  */
+  addr     = force_reg (Pmode, XEXP (m_tramp, 0));
+  end_addr = ncpu32k_force_binary (Pmode, PLUS, addr, GEN_INT (end_addr_offset));
+
+  /* Build up the code in TRAMPOLINE.
+
+              mhi   rv, hi(end_addr)
+              or    rv, lo(end_addr)
+              ldwu  r13, 4(rv)
+              jmp   r0, r13
+              ldwu  rv, 0(rv)
+       end_addr:
+              .word   <static chain>
+              .word   <nested_function>
+  */
+
+  i = 0;
+
+  /* Break out the high and low parts of the end_addr */
+  high = expand_simple_binop (SImode, LSHIFTRT, end_addr, GEN_INT (16),
+			      NULL, false, OPTAB_WIDEN);
+  low  = convert_to_mode (SImode, gen_lowpart (HImode, end_addr), true);
+
+  /* Emit the mhi, adding an operation to OR in the high bits from the
+     RTX. */
+  opcode = gen_int_mode (NCPU32K_MHI (NCPU32K_GPR_RV, 0), SImode);
+  trampoline[i++] = expand_simple_binop (SImode, IOR, opcode, high, NULL,
+					 false, OPTAB_WIDEN); 
+  
+  /* Emit the or.i, adding an operations to OR in the low bits from the
+     RTX. */
+  opcode = gen_int_mode (NCPU32K_OR_I (NCPU32K_GPR_RV, NCPU32K_GPR_RV, 0), SImode);
+  trampoline[i++] = expand_simple_binop (SImode, IOR, opcode, low, NULL,
+					 false, OPTAB_WIDEN); 
+
+  /* Emit the ldw of the function address. No bits to OR in here, so we can
+     do the opcode directly. */
+  trampoline[i++] =
+    gen_int_mode (NCPU32K_LDWU (13, NCPU32K_GPR_RV, target_function_offset - end_addr_offset),
+		  SImode);
+
+  /* Emit the jmp of the function. No bits to OR in here, so we can do the
+     opcode directly. */
+  trampoline[i++] = gen_int_mode (NCPU32K_JMP (13, 0), SImode);
+
+  /* Emit the ldw of the static chain. No bits to OR in here, so we can
+     do the opcode directly. */
+  trampoline[i++] =
+    gen_int_mode (NCPU32K_LDWU (STATIC_CHAIN_REGNUM, NCPU32K_GPR_RV,
+                          static_chain_offset - end_addr_offset), SImode);
+
+  /* Copy the trampoline code.  Leave any padding uninitialized.  */
+  for (j = 0; j < i; j++)
+    {
+      mem = adjust_address (m_tramp, SImode, j * GET_MODE_SIZE (SImode));
+      ncpu32k_emit_move (mem, trampoline[j]);
+    }
+
+  /* Set up the static chain pointer field.  */
+  mem = adjust_address (m_tramp, ptr_mode, static_chain_offset);
+  ncpu32k_emit_move (mem, chain_value);
+
+  /* Set up the target function field.  */
+  mem = adjust_address (m_tramp, ptr_mode, target_function_offset);
+  ncpu32k_emit_move (mem, XEXP (DECL_RTL (fndecl), 0));
+
+  /* Flushing the trampoline from the instruction cache needs to be done
+     here. */
+
+}
+
+/**
+ * Return the size in bytes of the trampoline code.
+ *
+ * Padded to TRAMPOLINE_ALIGNMENT bits. The code sequence is documented in
+ * ncpu32k_trampoline_init ()
+ *
+ * This is just the code size. the static chain pointer and target function
+ * address immediately follow.
+ *
+ * @return  The size of the trampoline code in bytes.
+ */
+int
+ncpu32k_trampoline_code_size (void)
+{
+  const int  TRAMP_BYTE_ALIGN = TRAMPOLINE_ALIGNMENT / 8;
+
+  return (ncpu32k_trampoline_code_words() * 4 + TRAMP_BYTE_ALIGN - 1) / TRAMP_BYTE_ALIGN * TRAMP_BYTE_ALIGN;
+
+}
+
+/* -------------------------------------------------------------------------- */
+/*!Provide support for DW_AT_calling_convention
+
+   Define this to enable the dwarf attribute DW_AT_calling_convention to be
+   emitted for each function. Instead of an integer return the enum value for
+   the DW_CC_ tag.
+
+   To support optional call frame debugging information, you must also define
+   INCOMING_RETURN_ADDR_RTX and either set RTX_FRAME_RELATED_P on the prologue
+   insns if you use RTL for the prologue, or call "dwarf2out_def_cfa" and
+   "dwarf2out_reg_save" as appropriate from TARGET_ASM_FUNCTION_PROLOGUE if
+   you dont.
+
+   For the NCPU32K, it should be sufficient to return DW_CC_normal in all cases.
+
+   @param[in] function  The function requiring debug information
+
+   @return  The enum of the DW_CC tag.                                        */
+/* -------------------------------------------------------------------------- */
+static int
+ncpu32k_dwarf_calling_convention (const_tree  function ATTRIBUTE_UNUSED)
+{
+  return  DW_CC_normal;
+
+}	/* ncpu32k_dwarf_calling_convention () */
+
+/*****************************************************************************/
+/* Target hook initialization.                                               */
+/*****************************************************************************/
+
+/* In most cases these use the static functions declared above. They have
+   defaults, so must be undefined first, before being redefined.
+
+   The description of what they do is found with the function above, unless it
+   is a standard function or a constant, in which case it is defined here (as
+   with TARGET_ASM_NAMED_SECTION).
+
+   The final declaration is of the global "targetm" structure. */
+
+/* Output assembly directives to switch to section name. The section should
+   have attributes as specified by flags, which is a bit mask of the SECTION_*
+   flags defined in output.h. If decl is non-NULL, it is the VAR_DECL or
+   FUNCTION_DECL with which this section is associated.
+
+   For NCPU32K, we use the default ELF sectioning. */
+#undef  TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
+
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE ncpu32k_function_value
+
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL ncpu32k_function_ok_for_sibcall
+
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE ncpu32k_pass_by_reference
+
+#undef  TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES ncpu32k_arg_partial_bytes
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE ncpu32k_option_override
+
+#undef TARGET_ASM_FILE_START
+#define TARGET_ASM_FILE_START ncpu32k_asm_file_start
+
+/* This target hook returns TRUE if an argument declared in a prototype as an
+   integral type smaller than int should actually be passed as an int. In
+   addition to avoiding errors in certain cases of mismatch, it also makes for
+   better code on certain machines.
+
+   The default is to not promote prototypes.
+
+   For the NCPU32K we do require this, so use a utility hook, which always
+   returns TRUE. */
+#undef  TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+
+#undef  TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE ncpu32k_promote_function_mode
+
+#undef  TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P  ncpu32k_legitimate_address_p
+
+#undef  TARGET_LEGITIMIZE_ADDRESS
+#define TARGET_LEGITIMIZE_ADDRESS ncpu32k_legitimize_address
+
+#undef  TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT  ncpu32k_trampoline_init
+
+#undef  TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM ncpu32k_cannot_force_const_mem
+
+#undef TARGET_DWARF_CALLING_CONVENTION
+#define TARGET_DWARF_CALLING_CONVENTION  ncpu32k_dwarf_calling_convention
+
+/* uClibc has some instances where (non-coforming to ISO C) a non-varargs
+   prototype is in scope when calling that function which is implemented
+   as varargs.  We want this to work at least where none of the anonymous
+   arguments are used.  I.e. we want the last named argument to be known
+   as named so it can be passed in a register, varars funtion or not.  */
+#undef TARGET_STRICT_ARGUMENT_NAMING
+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true
+
+/* Is this suitable for an immediate operand.
+
+   FIXME?: Is this correct. We can only do "I" immediates directly. */
+static bool
+ncpu32k_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  if (ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE)
+    return 0;
+
+  return GET_CODE(x) != CONST_DOUBLE || (GET_MODE (x) == VOIDmode && !flag_pic);
+}
+#undef TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P ncpu32k_legitimate_constant_p
+
+/* On the NCPU32K, no functions pop their arguments.
+   FIXME?: Is this really correct? */
+static int
+ncpu32k_return_pops_args (tree ARG_UNUSED(fundecl), tree ARG_UNUSED(funtype), int ARG_UNUSED(size))
+{
+  return 0;
+}
+#undef TARGET_RETURN_POPS_ARGS
+#define TARGET_RETURN_POPS_ARGS ncpu32k_return_pops_args
+
+/* Determine where to put an argument to a function.  Value is zero to push
+   the argument on the stack, or a hard register in which to store the
+   argument.
+
+   "mode" is the argument's machine mode.
+
+   "type" is the data type of the argument (as a tree).  This is null for
+    libcalls where that information may not be available.
+
+   "cum" is a variable of type CUMULATIVE_ARGS which gives info about the
+    preceding args and about the function being called.
+
+   "named" is nonzero if this argument is a named parameter (otherwise it is
+    an extra parameter matching an ellipsis).
+
+    On the ARC the first MAX_ARC_PARM_REGS args are normally in registers and
+    the rest are pushed.  */
+static rtx
+ncpu32k_function_arg (cumulative_args_t cum, enum machine_mode mode,
+                     const_tree type, bool named)
+{
+  CUMULATIVE_ARGS *cum_pnt = get_cumulative_args (cum);
+
+  if (NCPU32K_PASS_IN_REG_P (*cum_pnt, mode, type, named))
+    return gen_rtx_REG (mode, NCPU32K_ROUND_ADVANCE_CUM (*cum_pnt, mode, type)
+                          + GP_ARG_MIN_REG);
+  else
+    return 0;
+}
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG ncpu32k_function_arg
+/* Update the data in "cum" to advance over an argument of mode "mode" and
+   data type "type".  ("type" is null for libcalls where that information may
+   not be available.)  */
+static void
+ncpu32k_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,
+                           const_tree type, bool ARG_UNUSED(named))
+{
+  CUMULATIVE_ARGS *cum_pnt = get_cumulative_args (cum);
+
+  *cum_pnt = NCPU32K_ROUND_ADVANCE_CUM (*cum_pnt, mode, type)
+    + NCPU32K_ROUND_ADVANCE_ARG (mode, type);
+}
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE ncpu32k_function_arg_advance
+
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS ncpu32k_print_operand_address
+
+/* Trampoline stubs are yet to be written. */
+/* #define TARGET_ASM_TRAMPOLINE_TEMPLATE */
+/* #define TARGET_TRAMPOLINE_INIT */
+
+/* Lay out structs with increased alignment so that they can be accessed
+   more efficiently.  But don't increase the size of one or two byte
+   structs.  */
+int
+ncpu32k_struct_alignment (tree t)
+{
+  unsigned HOST_WIDE_INT total = 0;
+  int default_align_fields = 0;
+  int special_align_fields = 0;
+  tree field;
+  unsigned max_align
+    = maximum_field_alignment ? maximum_field_alignment : BIGGEST_ALIGNMENT;
+  bool struct_p;
+
+  switch (TREE_CODE (t))
+    {
+    case RECORD_TYPE:
+      struct_p = true; break;
+    case UNION_TYPE: case QUAL_UNION_TYPE:
+      struct_p = false; break;
+    default: gcc_unreachable ();
+    }
+  /* Skip all non field decls */
+  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))
+    {
+      unsigned HOST_WIDE_INT field_size;
+
+      if (TREE_CODE (field) != FIELD_DECL ||
+	  TREE_TYPE (field) == error_mark_node)
+	continue;
+      /* If this is a field in a non-qualified union, or the sole field in
+	 a struct, and the alignment was set by the user, don't change the
+	 alignment.
+	 If the field is a struct/union in a non-qualified union, we already
+	 had sufficient opportunity to pad it - if we didn't, that'd be
+	 because the alignment was set as above.
+	 Likewise if the field is a struct/union and the sole field in a
+	 struct.  */
+      if (DECL_USER_ALIGN (field)
+	  || TYPE_USER_ALIGN (TREE_TYPE (field))
+	  || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE
+	  || TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE
+	  || TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)
+	{
+	  if (TREE_CODE (t) == UNION_TYPE)
+	    return 0;
+	  special_align_fields++;
+	}
+      else if (DECL_PACKED (field))
+	special_align_fields++;
+      else
+	default_align_fields++;
+      if (!tree_fits_uhwi_p (DECL_SIZE (field)))
+	field_size = max_align;
+      else
+	field_size = tree_to_uhwi (DECL_SIZE (field));
+      if (field_size >= BIGGEST_ALIGNMENT)
+	total = max_align;
+      if (struct_p)
+	total += field_size;
+      else
+	total = MAX (total, field_size);
+    }
+
+  if (!default_align_fields
+      && (TREE_CODE (t) != RECORD_TYPE || special_align_fields <= 1))
+    return 0;
+  return total < max_align ? (1U << ceil_log2 (total)) : max_align;
+}
+
+/* Increase the alignment of objects so that they are easier to copy.
+   Note that this can cause more struct copies to be inlined, so code
+   size might increase, but so should perfromance.  */
+int
+ncpu32k_data_alignment (tree t, int align)
+{
+  if (align < FASTEST_ALIGNMENT && TREE_CODE (t) == ARRAY_TYPE)
+    {
+      int size = int_size_in_bytes (t);
+
+      return (size > 0 && size < FASTEST_ALIGNMENT / BITS_PER_UNIT
+	      ? (1 << floor_log2 (size)) * BITS_PER_UNIT
+	      : FASTEST_ALIGNMENT);
+    }
+  return align;
+}
+
+static void
+ncpu32k_option_override (void)
+{
+}
+
+static void
+ncpu32k_asm_file_start(void)
+{
+  default_file_start();
+}
+
+/* Implement EH_RETURN_HANDLER_RTX. 
+ * Make eh_return use the link register. Epilogue LR restore
+ * is suppressed for eh_return. */
+rtx
+ncpu32k_eh_return_handler_rtx (void)
+{
+  return INCOMING_RETURN_ADDR_RTX;
+}
+
+/* Implement RETURN_ADDR_RTX.
+ * We do not support moving back to a previous frame. */
+rtx
+ncpu32k_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)
+{
+  if (count != 0)
+    return const0_rtx;
+
+  /* We don't know if LR is going to be saved or if we're going to
+   * be clobbering it with the GOT instruction.
+   * Therefore the safest bet is to force a save of LR and use that.
+   * Assume it's going to be first in the stack. */
+
+  cfun->machine->force_lr_save = true;
+  return gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,
+                                            -UNITS_PER_WORD));
+}
+
+/* Implement TARGET_FRAME_POINTER_REQUIRED.
+ * We want frame pointer in eh_return and when alloca is used */
+static bool
+ncpu32k_frame_pointer_required (void)
+{
+  return crtl->calls_eh_return || cfun->calls_alloca;
+}
+
+/* Functions to save and restore machine-specific function data.  */
+static struct machine_function *
+ncpu32k_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+/* INIT_EXPANDERS */
+void
+ncpu32k_init_expanders (void)
+{
+  /* Arrange to initialize and mark the machine per-function
+   * status.  */
+  init_machine_status = ncpu32k_init_machine_status;
+
+  if (cfun && cfun->machine)
+    {
+      cfun->machine->force_lr_save = false;
+    }
+}
+
+#undef  TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED ncpu32k_frame_pointer_required
+
+/* Initialize the GCC target structure.  */
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-ncpu32k.h"
+
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.h	2021-03-29 07:33:28.690566727 -0400
@@ -0,0 +1,1159 @@
+/* Definitions of target machine for GNU compiler. nano-cpu32k version.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 1, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#ifndef _NCPU32K_H_
+#define _NCPU32K_H_
+
+#include "config/ncpu32k/ncpu32k-opts.h"
+
+/* Target CPU builtins */
+#define TARGET_CPU_CPP_BUILTINS()                       \
+  do                                                    \
+    {                                                   \
+      builtin_define ("__NCPU32K__");                   \
+      builtin_define ("__ncpu32k__");                   \
+      builtin_assert ("cpu=ncpu32k");                   \
+      builtin_assert ("machine=ncpu32k");               \
+    }                                                   \
+  while (0)
+
+#undef CPP_SPEC
+#define CPP_SPEC "-D__unix__ -D__gnu_linux__ -D__linux__ \
+%{!undef:							  \
+  %{!ansi:							  \
+    %{!std=*:-Dunix -D__unix -Dlinux -D__linux}			  \
+    %{std=gnu*:-Dunix -D__unix -Dlinux -D__linux}}}		  \
+-Asystem=linux -Asystem=unix -Asystem=posix %{!mnewlib:%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}}"
+
+/* Make sure we pick up the crti.o, crtbegin.o, crtend.o and crtn.o files. */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared: crt1.o%s} crti.o%s \
+   %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+/* FIXME! recheck this */
+#undef LINK_SPEC
+#define LINK_SPEC "%{static:-static} %{shared:-shared}"
+
+/* Override previous definitions (linux.h). Newlib doesn't have a profiling
+   version of the library, but it does have a debugging version (libg.a) */
+#undef LIB_SPEC
+#define LIB_SPEC "%{!mnewlib:%{pthread:-lpthread}				\
+		             %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} crt1.o%s}"	\
+                 "%{mnewlib:%{!g:-lc} %{g:-lg}					\
+                            %{!g:-lc} %{g:-lg}					\
+                            }"
+
+/* Target machine storage layout */
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields. */
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 0
+
+/* Define this if most significant word of a multiword number is numbered.  */
+#define WORDS_BIG_ENDIAN 0
+
+#define BITS_PER_WORD 32
+#define SHORT_TYPE_SIZE 16
+#define INT_TYPE_SIZE 32
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE 64
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD 4
+
+/* Width in bits of a pointer.
+   See also the macro `Pmode' defined below.  */
+#define POINTER_SIZE 32
+
+/* Allocation boundary (in *bits*) for storing pointers in memory.  */
+#define POINTER_BOUNDARY 32
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY 32
+
+/* Boundary (in *bits*) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY 32
+
+/* Allocation boundary (in *bits*) for the code of a function.  */
+#define FUNCTION_BOUNDARY 32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY 8
+
+/* A bitfield declared as `int' forces `int' alignment for the struct.  */
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 32
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 32
+
+/* Make strings word-aligned so strcpy from constants will be faster.  */
+/*
+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  				\
+  ((TREE_CODE (EXP) == STRING_CST || TREE_CODE (EXP) == CONSTRUCTOR)    \
+    && (ALIGN) < FASTEST_ALIGNMENT      				\
+   ? FASTEST_ALIGNMENT : (ALIGN))
+*/
+
+/* One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  Another is to
+   cause character arrays to be word-aligned so that `strcpy' calls
+   that copy constants to character arrays can be done inline.  */         
+/*
+#define DATA_ALIGNMENT(TYPE, ALIGN)                                     \
+  ((((ALIGN) < FASTEST_ALIGNMENT)                                       \
+    && (TREE_CODE (TYPE) == ARRAY_TYPE                                  \
+        || TREE_CODE (TYPE) == UNION_TYPE                               \
+        || TREE_CODE (TYPE) == RECORD_TYPE)) ? FASTEST_ALIGNMENT : (ALIGN))
+*/ /* CHECK - btw code gets bigger with this one */
+#define DATA_ALIGNMENT(TYPE, ALIGN) \
+  ((ALIGN) < FASTEST_ALIGNMENT \
+   ? ncpu32k_data_alignment ((TYPE), (ALIGN)) : (ALIGN))
+
+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \
+  ((ALIGN) < FASTEST_ALIGNMENT \
+   ? ncpu32k_data_alignment ((TYPE), (ALIGN)) : (ALIGN))
+
+/* Define this if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 1
+
+/* Align an address */
+#define NCPU32K_ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))
+
+/* Define if operations between registers always perform the operation
+   on the full register even if a narrower mode is specified.  */
+#define WORD_REGISTER_OPERATIONS
+
+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+   will either zero-extend or sign-extend.  The value of this macro should
+   be the code that says which one of the two operations is implicitly
+   done, NIL if none.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases,
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type. */
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \
+  if (GET_MODE_CLASS (MODE) == MODE_INT         \
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \
+    (MODE) = SImode;
+  /* CHECK */
+
+
+/*
+ * brings 0.4% improvment in static size for linux
+ *
+#define PROMOTE_FOR_CALL_ONLY
+*/
+
+/* Define this macro if it is as good or better to call a constant
+   function address than to call an address kept in a register.  */
+#define NO_FUNCTION_CSE 1 /* CHECK */
+   
+/* Standard register usage.  */
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.  */
+
+#define NCPU32K_LAST_ACTUAL_REG		31
+#define ARG_POINTER_REGNUM		(NCPU32K_LAST_ACTUAL_REG + 1) /* arg = 32 */
+#define FRAME_POINTER_REGNUM		(ARG_POINTER_REGNUM + 1) /* soft FP = 33 */
+#define NCPU32K_LAST_INT_REG		FRAME_POINTER_REGNUM
+#define NCPU32K_CC_REG			(NCPU32K_LAST_INT_REG + 1) /* cc = 34 */
+#define FIRST_PSEUDO_REGISTER		(NCPU32K_CC_REG + 1)
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.
+   These are:
+     r0 -- NIL
+     r1 -- LNK
+     r2 -- SP
+     r3 -- FP
+     r12 -- TLS for linux
+     r14 -- GOT pointer
+*/
+/*      0  1  2  3  4  5  6  7  8  9 */
+#define FIXED_REGISTERS { \
+/*0*/   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, \
+/*10*/  0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \
+/*20*/  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/*30*/  0, 0, 1, 1, 1 }
+  
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like.
+   These are:
+      r3	fp
+      r4-r9	v0-v5
+      r10	rv
+      r11	rvh
+      All Caller-saved registers
+   And all the Fixed Registers...
+*/
+/*      0  1  2  3  4  5  6  7  8  9 */
+#define CALL_USED_REGISTERS { \
+/*0*/   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+/*10*/  1, 1, 1, 1, 1, 1, 0, 1, 0, 1, \
+/*20*/  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, \
+/*30*/  0, 1, 1, 1, 1}
+/*
+  SP		FIXED & CALL_USED
+  hard FP	CALL_USED
+  soft FP	FIXED and CALL_USED
+ */
+
+#if 0
+/* Register Allocation Order.
+   Firstly allocate call-used registers (r13,r15,r17,...,r31),
+   then allocate r16,r18,r20,...r30,
+   then v0-v5.
+*/
+/*      0   1   2   3   4   5   6   7   8   9 */
+#define REG_ALLOC_ORDER { \
+/*0*/   26, 27, 28, 29, 18, 19, 20, 21, 22, 23, \
+/*10*/  24, 25, 30, 0,  31, 1, 10,  2,  11, 3, \
+/*20*/  12, 4,  13, 5,  14, 6, 15,  7,  16, 8, \
+/*30*/  17, 9,  32, 33, 34}
+#endif
+
+
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.
+   On the nano-cpu32k, all registers are one word long.  */
+#define HARD_REGNO_NREGS(REGNO, MODE)   \
+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+#define MODES_TIEABLE_P(MODE1, MODE2)  1
+
+/* A C expression for the cost of moving data of mode mode from a register in
+   class "from" to one in class "to". The classes are expressed using the
+   enumeration values such as GENERAL_REGS. A value of 2 is the default; other
+   values are interpreted relative to that.
+
+   It is not required that the cost always equal 2 when "from" is the same as
+   "to"; on some machines it is expensive to move between registers if they are
+   not general registers.
+
+   If reload sees an insn consisting of a single set between two hard
+   registers, and if REGISTER_MOVE_COST applied to their classes returns a
+   value of 2, reload does not check to ensure that the constraints of the
+   insn are met. Setting a cost of other than 2 will allow reload to verify
+   that the constraints are met. You should do this if the "movm" pattern's
+   constraints do not allow such copying.  */
+#define REGISTER_MOVE_COST(mode, from, to)  2
+
+/* A C expression for the cost of moving data of mode mode between a register
+   of class "class" and memory; "in" is zero if the value is to be written to
+   memory, nonzero if it is to be read in. This cost is relative to those in
+   REGISTER_MOVE_COST. If moving between registers and memory is more
+   expensive than between two registers, you should define this macro to
+   express the relative cost.
+
+   If you do not define this macro, GCC uses a default cost of 4 plus the cost
+   of copying via a secondary reload register, if one is needed. If your
+   machine requires a secondary reload register to copy between memory and a
+   register of class but the reload mechanism is more complex than copying via
+   an intermediate, define this macro to reflect the actual cost of the move.
+
+   GCC defines the function "memory_move_secondary_cost" if secondary reloads
+   are needed. It computes the costs due to copying via a secondary
+   register. If your machine copies from memory using a secondary register in
+   the conventional way but the default base value of 4 is not correct for
+   your machine, define this macro to add some other value to the result of
+   that function. The arguments to that function are the same as to this
+   macro.  */
+#define MEMORY_MOVE_COST(mode, class, in)  10
+
+/* A C expression for the cost of a branch instruction. A value of 1 is the
+   default; other values are interpreted relative to that. Parameter "speed_p"
+   is TRUE when the branch in question should be optimized for speed. When it
+   is FALSE, BRANCH_COST should be returning value optimal for code size
+   rather then performance considerations. "predictable_p" is true for well
+   predictable branches. On many architectures the BRANCH_COST can be reduced
+   then.  */
+#define BRANCH_COST(speed_p, predictable_p)  4
+
+/* Specify the registers used for certain standard purposes.
+   The values of these macros are register numbers.  */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM 2 /* r2 */
+
+/* Base register for access to local variables of the function.  */
+#define HARD_FRAME_POINTER_REGNUM 3 /* r3 */
+
+/* Link register. */
+#define LINK_REGNUM 1 /* r1 */
+
+/* Register in which static-chain is passed to a function.  */
+
+#define STATIC_CHAIN_REGNUM 10 /* rv */
+
+#define PROLOGUE_TMP 13 /* FIXME? */
+#define EPILOGUE_TMP 4 /* v0 */
+
+/* Register in which address to store a structure value
+   is passed to a function.  */
+/*#define STRUCT_VALUE_REGNUM 0*/
+
+/* Pass address of result struct to callee as "invisible" first argument */
+#define STRUCT_VALUE 0
+
+/****************************************************************************/
+/* Register operands  */
+/****************************************************************************/
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   GENERAL_REGS and BASE_REGS classess are the same on NCPU32K.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+enum reg_class 
+{ 
+  NO_REGS,
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES 
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.   */
+#define REG_CLASS_NAMES							\
+{									\
+  "NO_REGS",								\
+  "GENERAL_REGS",   							\
+  "ALL_REGS"								\
+}
+
+/* Define which registers fit in which classes.  This is an initializer for a
+   vector of HARD_REG_SET of length N_REG_CLASSES.
+
+   An initializer containing the contents of the register classes, as integers
+   which are bit masks.  The Nth integer specifies the contents of class N.
+   The way the integer MASK is interpreted is that register R is in the class
+   if `MASK & (1 << R)' is 1.
+
+   When the machine has more than 32 registers, an integer does not suffice.
+   Then the integers are replaced by sub-initializers, braced groupings
+   containing several integers.  Each sub-initializer must be suitable as an
+   initializer for the type `HARD_REG_SET' which is defined in
+   `hard-reg-set.h'.
+
+   For the NCPU32K we have the minimal set. GENERAL_REGS is all except r0, which
+   it permanently zero. */
+#define REG_CLASS_CONTENTS						\
+  {									\
+    { 0x00000000, 0x00000000 },		/* NO_REGS */			\
+    { 0xffffffff, 0x00000003 },		/* GENERAL_REGS */		\
+    { 0xffffffff, 0x00000007 }		/* ALL_REGS */			\
+  }
+
+/* The same information, inverted:
+
+   Return the class number of the smallest class containing reg number regno.
+   This could be a conditional expression or could index an array.
+
+   FIXME? 0 is not really a register, but a constant.  */
+#define REGNO_REG_CLASS(regno)						\
+  ((0 == regno) ? ALL_REGS : ((1 <= regno) && (regno <= NCPU32K_LAST_INT_REG))		\
+   ? GENERAL_REGS : NO_REGS)
+
+/* The class value for index registers, and the one for base regs.  */
+#define INDEX_REG_CLASS GENERAL_REGS
+#define BASE_REG_CLASS  GENERAL_REGS
+
+/* Given an rtx X being reloaded into a reg required to be in class CLASS,
+   return the class of reg to actually use.  In general this is just CLASS;
+   but on some machines in some cases it is preferable to use a more
+   restrictive class.  */
+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)
+
+/* Return the maximum number of consecutive registers needed to represent mode
+   MODE in a register of class CLASS.
+
+   On the nano-cpu32k, this is always the size of MODE in words, since all registers
+   are the same size.  */
+#define CLASS_MAX_NREGS(CLASS, MODE)					\
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+
+
+/****************************************************************************/
+/* Stack layout; argument passing; function entry, exit and calling.  */
+/****************************************************************************/
+
+/* Define this if pushing a word on the stack makes the stack pointer a
+   smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this if the nominal address of the stack frame is at the
+   high-address end of the local variables; that is, each additional local
+   variable allocated goes at a more negative offset in the frame.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset within stack frame to start allocating local variables at.  If
+   FRAME_GROWS_DOWNWARD, this is the offset to the END of the first local
+   allocated.  Otherwise, it is the offset to the BEGINNING of the first local
+   allocated.  */
+#define STARTING_FRAME_OFFSET 0
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* Define this if stack space is still allocated for a parameter passed
+   in a register.  The value is the number of bytes allocated to this
+   area.
+   N/a for NCPU32K. */
+/* #define REG_PARM_STACK_SPACE(FNDECL) (UNITS_PER_WORD * GP_ARG_NUM_REG) */
+
+/* Define this if the above stack space is to be considered part of the
+   space allocated by the caller.
+   N/a for NCPU32K. */
+/* #define OUTGOING_REG_PARM_STACK_SPACE */   
+
+/* Define this macro if `REG_PARM_STACK_SPACE' is defined, but the
+   stack parameters don't skip the area specified by it.
+   N/a for NCPU32K. */
+/* #define STACK_PARMS_IN_REG_PARM_AREA */
+
+/* If nonzero, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   current_function_outgoing_args_size. No space will be pushed onto the stack
+   for each call; instead, the function prologue should increase the stack
+   frame size by this amount.
+
+   Setting both PUSH_ARGS and ACCUMULATE_OUTGOING_ARGS is not proper. */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},				\
+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},			\
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},				\
+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  (OFFSET) = ncpu32k_initial_elimination_offset ((FROM), (TO))
+
+/* Minimum and maximum general purpose registers used to hold arguments.  */
+#define GP_ARG_MIN_REG 4 /* v0 */
+#define GP_ARG_MAX_REG 9 /* v5 */
+#define GP_ARG_NUM_REG (GP_ARG_MAX_REG - GP_ARG_MIN_REG + 1) 
+
+/* Return register */
+#define GP_ARG_RETURN  10 /* rv */
+#define GP_ARG_RETURNH 11 /* rvh */
+
+/* TLS thread pointer register */
+#define THREAD_PTR_REGNUM 12 /* r12 */
+
+/* Position Independent Code.  */
+#define PIC_OFFSET_TABLE_REGNUM 14 /* r14 */
+
+/* A C expression that is nonzero if X is a legitimate immediate
+   operand on the target machine when generating position independent code.
+   You can assume that X satisfies CONSTANT_P, so you need not
+   check this.  You can also assume `flag_pic' is true, so you need not
+   check it either.  You need not define this macro if all constants
+   (including SYMBOL_REF) can be immediate operands when generating
+   position independent code.  */
+#define LEGITIMATE_PIC_OPERAND_P(X) ncpu32k_legitimate_pic_operand_p (X)
+
+/* A C expression to create an RTX representing the place where a library
+   function returns a value of mode mode.
+
+   Note that library function in this context means a compiler support
+   routine, used to perform arithmetic, whose name is known specially by the
+   compiler and was not mentioned in the C code being compiled.
+
+   For the NCPU32K, return value is in "rv" (GP_ARG_RETURN).  */   
+#define LIBCALL_VALUE(mode)                                             \
+  gen_rtx_REG(								\
+	   ((GET_MODE_CLASS (mode) != MODE_INT				\
+	     || GET_MODE_SIZE (mode) >= 4)				\
+	    ? (mode)							\
+	    : SImode),							\
+	    GP_ARG_RETURN)
+
+/* Define this if PCC uses the nonreentrant convention for returning
+   structure and union values. 
+   N/a for NCPU32K. */
+/* #define PCC_STATIC_STRUCT_RETURN */
+
+/* A C expression that is nonzero if regno is the number of a hard register in
+   which the values of called function may come back.
+
+   A register whose use for returning values is limited to serving as the
+   second of a pair (for a value of type double, say) need not be recognized
+   by this macro. So for most machines, this definition suffices:
+
+       #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
+
+   If the machine has register windows, so that the caller and the called
+   function use different registers for the return value, this macro should
+   recognize only the caller's register numbers.
+
+   For NCPU32K, we must check if we have the return register.
+
+   From GCC 4.6, this will be replaced by TARGET_FUNCION_VALUE_REGNO_P target
+   hook function. */
+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == GP_ARG_RETURN)
+ 
+/* 1 if N is a possible register number for function argument passing. */
+#define FUNCTION_ARG_REGNO_P(N) \
+   ((N) >= GP_ARG_MIN_REG && (N) <= GP_ARG_MAX_REG)
+
+/* A code distinguishing the floating point format of the target
+   machine.  There are three defined values: IEEE_FLOAT_FORMAT,
+   VAX_FLOAT_FORMAT, and UNKNOWN_FLOAT_FORMAT.  */
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+#define FLOAT_WORDS_BIG_ENDIAN 0 /* le */
+
+/* A C type for declaring a variable that is used as the first argument of
+   FUNCTION_ARG and other related values. For some target machines, the type
+   int suffices and can hold the number of bytes of argument so far.
+
+   There is no need to record in CUMULATIVE_ARGS anything about the arguments
+   that have been passed on the stack. The compiler has other variables to
+   keep track of that.  For target machines on which all arguments are passed
+   on the stack, there is no need to store anything in CUMULATIVE_ARGS;
+   however, the data structure must exist and should not be empty, so use
+   int. */
+#define CUMULATIVE_ARGS int
+
+/* A C statement (sans semicolon) for initializing the variable "cum" for the
+   state at the beginning of the argument list. The variable has type
+   CUMULATIVE_ARGS. The value of "fntype" is the tree node for the data type
+   of the function which will receive the args, or 0 if the args are to a
+   compiler support library function. For direct calls that are not libcalls,
+   "fndecl" contain the declaration node of the function. "fndecl" is also set
+   when INIT_CUMULATIVE_ARGS is used to find arguments for the function being
+   compiled.  "n_named_args" is set to the number of named arguments,
+   including a structure return address if it is passed as a parameter, when
+   making a call. When processing incoming arguments, "n_named_args" is set to
+   1.
+
+   When processing a call to a compiler support library function, "libname"
+   identifies which one. It is a symbol_ref rtx which contains the name of the
+   function, as a string. "libname" is 0 when an ordinary C function call is
+   being processed. Thus, each time this macro is called, either "libname" or
+   "fntype" is nonzero, but never both of them at once.
+
+   For the NCPU32K, we set "cum" to zero each time.
+   JPB 29-Aug-10: Is this correct? */
+#define INIT_CUMULATIVE_ARGS(cum, fntype, libname, fndecl, n_named_args) \
+  (cum = 0)
+
+
+/* Define intermediate macro to compute the size (in registers) of an argument
+   for the ncpu32k.
+   The NCPU32K_ROUND_ADVANCE* macros are local to this file. */
+
+/* local, Round "size" up to a word boundary.  */
+#define NCPU32K_ROUND_ADVANCE(size)					\
+  (((size) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* local, Round arg "mode"/"type" up to the next word boundary.  */
+#define NCPU32K_ROUND_ADVANCE_ARG(mode, type)				\
+  ((mode) == BLKmode							\
+   ? NCPU32K_ROUND_ADVANCE (int_size_in_bytes (type))			\
+   : NCPU32K_ROUND_ADVANCE (GET_MODE_SIZE (mode)))
+
+/* local, The ABI says that no rounding to even or odd words takes place.  */
+#define NCPU32K_ROUND_ADVANCE_CUM(cum, mode, type) (cum)
+  
+/* Return boolean indicating if arg of type "type" and mode "mode" will be
+   passed in a reg.  This includes arguments that have to be passed by
+   reference as the pointer to them is passed in a reg if one is available
+   (and that is what we're given).
+
+   When passing arguments "named" is always 1.  When receiving arguments
+   "named" is 1 for each argument except the last in a stdarg/varargs
+   function.  In a stdarg function we want to treat the last named arg as
+   named.  In a varargs function we want to treat the last named arg (which is
+   `__builtin_va_alist') as unnamed. */
+#define NCPU32K_PASS_IN_REG_P(cum, mode, type, named)			\
+  ((named)                         					\
+   && ((NCPU32K_ROUND_ADVANCE_CUM ((cum), (mode), (type))			\
+	+ NCPU32K_ROUND_ADVANCE_ARG ((mode), (type))			\
+	<= GP_ARG_NUM_REG)))
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry. */
+#define FUNCTION_PROFILER(FILE, LABELNO)
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function, the
+   stack pointer does not matter.  The value is tested only in functions that
+   have frame pointers.  No definition is equivalent to always zero.
+
+   The default suffices for NCPU32K. */
+#define EXIT_IGNORE_STACK 0
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before the
+   prologue.  This RTL is either a REG, indicating that the return
+   value is saved in REG, or a MEM representing a location in
+   the stack.  */
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LINK_REGNUM)
+
+#define RETURN_ADDR_RTX ncpu32k_return_addr_rtx
+
+/* Addressing modes, and classification of registers for them.  */
+
+/* #define HAVE_POST_INCREMENT */
+/* #define HAVE_POST_DECREMENT */
+
+/* #define HAVE_PRE_DECREMENT */
+/* #define HAVE_PRE_INCREMENT */
+
+/* Macros to check register numbers against specific register classes.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* True if X is an rtx for a constant that is a valid address.  */
+#define CONSTANT_ADDRESS_P(X) 						\
+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF              \
+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST                \
+   || GET_CODE (X) == HIGH)        
+
+/* A C expression which is nonzero if register number num is suitable for use
+   as a base register in operand addresses. Like TARGET_LEGITIMATE_ADDRESS_P,
+   this macro should also define a strict and a non-strict variant. Both
+   variants behave the same for hard register; for pseudos, the strict variant
+   will pass only those that have been allocated to a valid hard registers,
+   while the non-strict variant will pass all pseudos.
+
+   Compiler source files that want to use the strict variant of this and other
+   macros define the macro REG_OK_STRICT. You should use an #ifdef
+   REG_OK_STRICT conditional to define the strict variant in that case and the
+   non-strict variant otherwise.  */
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(num)					     \
+  (   ((0 < (num))             && ((num)             <= NCPU32K_LAST_INT_REG))  \
+   || ((0 < reg_renumber[num]) && (reg_renumber[num] <= NCPU32K_LAST_INT_REG)))
+
+#else
+/* Accept an int register or a pseudo reg.  */
+#define REGNO_OK_FOR_BASE_P(num) ((num) <= NCPU32K_LAST_INT_REG ||		\
+				  (num) >= FIRST_PSEUDO_REGISTER)
+#endif
+
+/* NCPU32K doesn't have any indexed addressing. */
+#define REG_OK_FOR_INDEX_P(X) 0
+#define REGNO_OK_FOR_INDEX_P(X) 0
+
+/* Specify the machine mode that this machine uses for the index in the
+   tablejump instruction.  */
+#define CASE_VECTOR_MODE SImode
+
+/* Define as C expression which evaluates to nonzero if the tablejump
+   instruction expects the table to contain offsets from the address of the
+   table.
+
+   Do not define this if the table should contain absolute addresses. */
+/* #define CASE_VECTOR_PC_RELATIVE 1 */
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR 1
+
+/* The maximum number of bytes that a single instruction can move quickly
+   between memory and registers or between two memory locations. */
+#define MOVE_MAX 4
+
+/* Define this if zero-extension is slow (more than one real instruction).  */
+/* #define SLOW_ZERO_EXTEND */
+
+/* Nonzero if access to memory by bytes is slow and undesirable.  
+   For RISC chips, it means that access to memory by bytes is no
+   better than access by words when possible, so grab a whole word
+   and maybe make use of that.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Define if shifts truncate the shift count
+   which implies one can omit a sign-extension or zero-extension
+   of a shift count. */
+/* #define SHIFT_COUNT_TRUNCATED */ /*FIXME?*/
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* A function address in a call instruction
+   is a byte address (for indexing purposes)
+   so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE SImode
+
+
+/****************************************************************************/
+/* Condition code stuff */
+/****************************************************************************/
+
+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,
+   return the mode to be used for the comparison. */
+#define SELECT_CC_MODE(op, x, y) ncpu32k_select_cc_mode(op)
+
+/* Can the condition code MODE be safely reversed? */
+#define REVERSIBLE_CC_MODE(mode) 1
+
+/* Given a condition code and a mode, return the inverse condition.  */
+#define REVERSE_CONDITION(code, mode) reverse_condition (code)
+
+
+/****************************************************************************/
+/* Control the assembler format that we output.  */
+/****************************************************************************/
+
+/* A C string constant describing how to begin a comment in the target
+   assembler language.  The compiler assumes that the comment will end at
+   the end of the line.  */
+#define ASM_COMMENT_START "#"
+
+/* Output to assembler file text saying following lines may contain character
+   constants, extra white space, comments, etc.  */
+#define ASM_APP_ON "#APP\n"
+
+/* Output to assembler file text saying following lines no longer contain
+   unusual constructs.  */
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* Switch to the text or data segment.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP "\t.section .text"
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP "\t.section .data"
+
+/* Output before uninitialized data. */
+#define BSS_SECTION_ASM_OP  "\t.section .bss"
+
+/* How to refer to registers in assembler output.  This sequence is indexed by
+   compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES							\
+  {"nil",  "lnk", "sp",  "fp",  "v0",  "v1",  "v2",  "v3",		\
+   "v4",   "v5",  "rv",  "rvh", "rtls","r13", "rgot","r15",		\
+   "r16", "r17",  "r18", "r19", "r20", "r21", "r22", "r23",		\
+   "r24", "r25",  "r26", "r27", "r28", "r29", "r30", "r31",		\
+   "argp", "frame", "cc-reg"}
+
+
+/****************************************************************************/
+/* Debug things for DBX (STABS)                                             */
+/*                                                                          */
+/* Note. Our config.gcc includes dbxelf.h, which sets up appropriate        */
+/*       defaults. Choice of which debug format to use is in our elf.h      */
+/****************************************************************************/
+
+/* Don't try to use the  type-cross-reference character in DBX data.
+   Also has the consequence of putting each struct, union or enum
+   into a separate .stabs, containing only cross-refs to the others.  */
+#define DBX_NO_XREFS
+         
+/****************************************************************************/
+/* Debug things for DWARF2                                                  */
+/*                                                                          */
+/* Note. Choice of which debug format to use is in our elf.h                */
+/****************************************************************************/
+
+/* We support frame unwind info including for exceptions handling. This needs
+   INCOMING_RETURN_ADDR_RTX to be set and OBJECT_FORMAT_ELF to be defined (in
+   elfos.h). Override any default value. */
+#undef  DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO 1
+
+/* We want frame info produced. Note that this is superfluous if
+   DWARF2_UNWIND_INFO is non-zero, but we set so this so, we can produce frame
+   info even when it is zero. Override any default value. */
+#undef  DWARF2_FRAME_INFO
+#define DWARF2_FRAME_INFO 1
+
+/* Macro specifying which register holds the return address */
+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGNUM)
+
+/* Where is the start of our stack frame in relation to the end of the
+   previous stack frame at the start of a function, before the prologue */
+#define INCOMING_FRAME_SP_OFFSET  0
+
+/* Use compact debug tables. Generates .file/.loc directives. */
+#undef  DWARF2_ASM_LINE_DEBUG_INFO
+#define DWARF2_ASM_LINE_DEBUG_INFO 1
+
+/* We don't need an alternative return address for now. */
+/* DWARF_ALT_FRAME_RETURN_COLUMN */
+
+/* We always save registers in the prologue with word alignment, so don't
+   need this. */
+/* DWARF_CIE_DATA_ALIGNMENT */
+
+/* This specifies the maximum number of registers we can save in a frame. We
+   could note that only SP, FP, LR, arg regs and callee saved regs come into
+   this category. However this is only an efficiency thing, so for now we
+   don't use it. */
+/* DWARF_FRAME_REGISTERS */
+
+/* This specifies a mapping from register numbers in .dwarf_frame to
+   .eh_frame. However for us they are the same, so we don't need it. */
+/* DWARF_FRAME_REGNUM */
+
+/* Defined if the DWARF column numbers do not match register numbers. For us
+   they do, so this is not needed. */
+/* DWARF_REG_TO_UNWIND_COLUMN */
+
+/* Can be used to define a register guaranteed to be zero. Only useful if zero
+   is used to terminate backtraces, and not recommended for new ports, so we
+   don't use it. */
+/* DWARF_ZERO_REG */
+
+/* This is the inverse function for DWARF_FRAME_REGNUM. Again not needed. */
+/* DWARF2_FRAME_REG_OUT  */
+
+
+/****************************************************************************/
+/* Assembler Label Output */
+/****************************************************************************/
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global "
+
+#define SUPPORTS_WEAK 1
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.  */
+#define ASM_OUTPUT_LABEL(FILE,NAME)					\
+  { assemble_name (FILE, NAME); fputs (":\n", FILE); }
+
+/* We use -fleading-underscore to add it, when necessary.
+   No prefix for global symbols for NCPU32K */
+#define USER_LABEL_PREFIX ""
+
+/* Remove any previous definition (elfos.h).  */
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)	\
+  sprintf (LABEL, "*%s%d", PREFIX, NUM)
+
+/* This is how to output an assembler line defining an int constant.  */
+#define ASM_OUTPUT_INT(stream, value)					\
+  {									\
+    fprintf (stream, "\t.word\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n")}
+
+/* This is how to output an assembler line defining a float constant.  */
+#define ASM_OUTPUT_FLOAT(stream, value)					\
+  { long l;								\
+    REAL_VALUE_TO_TARGET_SINGLE (value,l);				\
+    fprintf(stream,"\t.word\t0x%08x\t\t# float %26.7e\n", l, value); }
+
+/* This is how to output an assembler line defining a double constant.  */
+#define ASM_OUTPUT_DOUBLE(stream, value)				\
+  { long l[2];								\
+    REAL_VALUE_TO_TARGET_DOUBLE (value,&l[0]);				\
+    fprintf(stream,"\t.word\t0x%08x,0x%08x\t# float %26.16le\n",	\
+	    l[0],l[1],value); }
+
+/* This is how to output an assembler line defining a long double constant.  */
+#define ASM_OUTPUT_LONG_DOUBLE(stream, value)				\
+  { long l[4];								\
+    REAL_VALUE_TO_TARGET_DOUBLE (value,&l[0]);				\
+    fprintf (stream,							\
+	     "\t.word\t0x%08x,0x%08x,0x%08x,0x%08x\t# float %26.18lle\n", \
+	     l[0],l[1],l[2],l[3],value); }
+
+/* This is how to output an assembler line defining a short constant.  */
+#define ASM_OUTPUT_SHORT(stream, value)					\
+  { fprintf (stream, "\t.half\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n"); }
+
+/* This is how to output an assembler line defining a char constant.  */
+#define ASM_OUTPUT_CHAR(stream, value)					\
+  { fprintf (stream, "\t.byte\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n")}
+
+/* This is how to output an assembler line for a numeric constant byte.  */
+#define ASM_OUTPUT_BYTE(stream, value)  \
+  fprintf (stream, "\t.byte\t0x%02x\n", (value))
+
+/* This is how to output an insn to push a register on the stack.
+   It need not be very fast code.  */
+#define ASM_OUTPUT_REG_PUSH(stream, regno)				\
+  { fprintf (stream, "\tadd\tsp, sp, -4\n");				\
+    fprintf (stream, "\tstw\t0(sp), %s\n", reg_names[regno]); }
+
+/* This is how to output an insn to pop a register from the stack.
+   It need not be very fast code.  */
+#define ASM_OUTPUT_REG_POP(stream,REGNO)				\
+  { fprintf (stream, "\tldw\t%s, 0(sp)\n", reg_names[REGNO]);		\
+    fprintf (stream, "\tadd\tsp, sp, 4\n"); }
+
+/* This is how to output an element of a case-vector that is absolute.
+   (The Vax does not use such vectors,
+   but we must define this macro anyway.)  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(stream, value)				\
+  fprintf (stream, "\t.word\t.L%d\n", value)
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(stream, body, value, rel)		\
+  fprintf (stream, "\t.word\t.L%d-.L%d\n", value, rel)
+
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
+/* FIXME? If we were serious about PIC, we should also use jmpl to get
+   the table start address.  */
+
+/* This is how to output an assembler line that says to advance the location
+   counter to a multiple of 2**log bytes.  */
+#define ASM_OUTPUT_ALIGN(stream, log)					\
+  if ((log) != 0)							\
+    {									\
+      fprintf (stream, "\t.align\t%d\n", 1 << (log));			\
+    }
+
+/* This is how to output an assembler line that says to advance the location
+   counter by "size" bytes.  */
+#define ASM_OUTPUT_SKIP(stream, size)					\
+  fprintf (stream, "\t.space %d\n", (size))
+
+/* Need to split up .ascii directives to avoid breaking
+   the linker. */
+
+/* This is how to output a string.  */
+#define ASM_OUTPUT_ASCII(stream, ptr, len)				\
+  output_ascii_pseudo_op (stream, (const unsigned char *) (ptr), len)
+
+/* Invoked just before function output. */
+#define ASM_OUTPUT_FUNCTION_PREFIX(stream, fnname)			\
+  { fputs (".proc\t", stream); assemble_name (stream, fnname);		\
+    fputs ("\n", stream); }
+
+/* This says how to output an assembler line to define a global common
+   symbol. */
+#define ASM_OUTPUT_COMMON(stream,name,size,rounded)			\
+  { data_section ();							\
+    fputs ("\t.global\t", stream);					\
+    assemble_name(stream, name);					\
+    fputs ("\n", stream);						\
+    assemble_name (stream, name);					\
+    fputs (":\n", stream);						\
+    fprintf (stream, "\t.space\t%d\n", rounded); }
+
+/* This says how to output an assembler line to define a local common
+   symbol.
+   FIXME! This doesn't work - we don't have a .bss directive like this. */
+#define ASM_OUTPUT_LOCAL(stream, name, size, rounded)			\
+  { fputs ("\t.bss\t", (stream));					\
+    assemble_name ((stream), (name));					\
+    fprintf ((stream), ",%d,%d\n", (size), (rounded)); }
+
+/* This says how to output an assembler line to define a global common symbol
+   with size "size" (in bytes) and alignment "align" (in bits).  */
+#define ASM_OUTPUT_ALIGNED_COMMON(stream, name, size, align)		\
+  { data_section();							\
+    if ((ALIGN) > 8)							\
+      {									\
+	fprintf(stream, "\t.align %d\n", ((align) / BITS_PER_UNIT));	\
+      }									\
+    fputs("\t.global\t", stream); assemble_name(stream, name);      	\
+    fputs("\n", stream);                                        	\
+    assemble_name(stream, name);                                	\
+    fputs (":\n", stream);						\
+    fprintf(stream, "\t.space\t%d\n", size); }
+  
+/* This says how to output an assembler line to define a local common symbol
+   with size "size" (in bytes) and alignment "align" (in bits).  */
+#define ASM_OUTPUT_ALIGNED_LOCAL(stream, name, size, align)		\
+  { data_section();							\
+    if ((align) > 8)							\
+      {									\
+	fprintf(stream, "\t.align %d\n", ((align) / BITS_PER_UNIT));	\
+      }									\
+    assemble_name(stream, name);					\
+    fputs (":\n", stream);						\
+    fprintf(stream, "\t.space %d\n", size); }
+                                                     
+/* Store in "output" a string (made with alloca) containing an assembler-name
+   for a local static variable named "name".  "labelno" is an integer which is
+   different for each call.  */
+#define ASM_FORMAT_PRIVATE_NAME(output, name, labelno)			\
+  { (output) = (char *) alloca (strlen ((name)) + 10);			\
+    sprintf ((output), "%s.%lu", (name), (unsigned long int) (labelno)); }
+
+/* Macro for %code validation. Returns nonzero if valid.
+
+   The acceptance of '(' is an idea taken from SPARC; output nop for %( if not
+   optimizing or the slot is not filled. */
+#define PRINT_OPERAND_PUNCT_VALID_P(code)  (('(' == code) || ('%' == code))
+
+/* Print an instruction operand "x" on file "stream".  "code" is the code from
+   the %-spec that requested printing this operand; if `%z3' was used to print
+   operand 3, then CODE is 'z'.  */
+#define PRINT_OPERAND(stream, x, code)					\
+{									\
+  if (code == 'r'							\
+      && GET_CODE (x) == MEM						\
+      && GET_CODE (XEXP (x, 0)) == REG)					\
+    {									\
+      fprintf (stream, "%s", reg_names[REGNO (XEXP (x, 0))]);		\
+    }									\
+  else if (code == '(')							\
+    {									\
+;									\
+    }									\
+  else if (code == 'C')							\
+    {									\
+      switch (GET_CODE (x))						\
+	{								\
+        case EQ:							\
+	  fputs ("eq", stream);						\
+	  break;							\
+        case NE:                                                        \
+	  fputs ("ne", stream);						\
+	  break;							\
+	case GT:							\
+	  fputs ("gts", stream);					\
+	  break;							\
+        case GE:							\
+	  fputs ("ges", stream);					\
+	  break;							\
+	case LT:							\
+	  fputs ("lts", stream);					\
+	  break;							\
+	case LE:							\
+	  fputs ("les", stream);					\
+	  break;							\
+	case GTU:							\
+	  fputs ("gtu", stream);					\
+	  break;							\
+	case GEU:							\
+	  fputs ("geu", stream);					\
+	  break;							\
+	case LTU:							\
+	  fputs ("ltu", stream);					\
+	  break;							\
+	case LEU:							\
+	  fputs ("leu", stream);					\
+	  break;							\
+	default:							\
+	  abort ();							\
+	}								\
+    }									\
+  else if (code == 'H')							\
+    {									\
+      if (GET_CODE (x) == REG)						\
+	fprintf (stream, "%s", reg_names[REGNO (x) + 1]);		\
+      else								\
+	abort ();							\
+    }									\
+  else if (GET_CODE (x) == REG)						\
+    fprintf (stream, "%s", reg_names[REGNO (x)]);			\
+  else if (GET_CODE (x) == MEM)						\
+    output_address (XEXP (x, 0));					\
+  else									\
+    output_addr_const (stream, x);					\
+}
+
+/* The size of the trampoline in bytes. This is a block of code followed by
+   two words specifying the function address and static chain pointer. */
+#define TRAMPOLINE_SIZE							\
+  (ncpu32k_trampoline_code_size () + GET_MODE_SIZE (ptr_mode) * 2)
+
+/* Alignment required for trampolines, in bits.
+
+   For the NCPU32K, there is no need for anything other than word alignment. */
+#define TRAMPOLINE_ALIGNMENT  32
+
+/* Assume that if the assembler supports thread local storage
+ * the system supports it. */
+#if !defined(TARGET_HAVE_TLS) && defined(HAVE_AS_TLS)
+#define TARGET_HAVE_TLS true
+#endif
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_REGNUM 1 /* rv */
+/* Use r21, r23, r25 and r27 (clobber regs) for exception data */
+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (21 + ((N)<<1)) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, EH_RETURN_REGNUM)
+#define EH_RETURN_HANDLER_RTX   ncpu32k_eh_return_handler_rtx ()
+
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr)
+
+#define INIT_EXPANDERS ncpu32k_init_expanders ()
+
+/* A C structure for machine-specific, per-function data.  This is
+ *    added to the cfun structure.  */
+typedef struct GTY(()) machine_function
+{
+  /* Force stack save of LR. Used in RETURN_ADDR_RTX. */
+  int force_lr_save;
+} machine_function;
+
+#endif /* _NCPU32K_H_ */
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-insn.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-insn.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-insn.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-insn.h	2021-09-26 06:42:34.498396107 -0400
@@ -0,0 +1,40 @@
+#ifndef NCPU32K_INSN_H_
+#define NCPU32K_INSN_H_
+
+/* Number of lnk register */
+#define NCPU32K_GPR_LNK 1
+/* Number of rv register */
+#define NCPU32K_GPR_RV 10
+
+/* Insn Opcodes */
+#define NCPU32K_OP_NOP    0x0U
+#define NCPU32K_OP_JMP_I  0xeU
+#define NCPU32K_OP_BEQ    0x10U
+#define NCPU32K_OP_BNE    0x11U
+#define NCPU32K_OP_BGT    0x12U
+#define NCPU32K_OP_BGTU   0x13U
+#define NCPU32K_OP_BLE    0x14U
+#define NCPU32K_OP_BLEU   0x15U
+#define NCPU32K_OP_MHI    0x37U
+#define NCPU32K_OP_LDWU   0x17U
+#define NCPU32K_OP_ADD_I  0xbU
+#define NCPU32K_OP_JMP    0xdU
+#define NCPU32K_OP_AND_I  0x1U
+#define NCPU32K_OP_OR_I   0x3U
+
+/* Insn Generator */
+#define NCPU32K_GEN_ROP(RS2,RS1,RD,OPC)	((uint32_t)(RD) | ((uint32_t)(OPC) << 5) | ((uint32_t)(RS1) << 12) | ((uint32_t)(RS2) << 17))
+#define NCPU32K_GEN_IMM15(IMM,RS1,RD,OPC)	((uint32_t)(RD) | ((uint32_t)(OPC) << 5) | ((uint32_t)(RS1) << 12) | ((uint32_t)(IMM) << 17))
+#define NCPU32K_GEN_IMM17(IMM,RD,OPC)	((uint32_t)(RD) | ((uint32_t)(OPC) << 5) | ((uint32_t)(IMM) << 15))
+#define NCPU32K_GEN_REL25(REL,OPC)		(((uint32_t)(REL) & 0x1f) | ((uint32_t)(OPC) << 5) | ((((uint32_t)(REL) >> 5) & 0xfffff) << 12))
+#define NCPU32K_GEN_REL15(REL,RS1,RD,OPC)	((uint32_t)(RD) | ((uint32_t)(OPC) << 5) | ((uint32_t)(RS1) << 12) | ((uint32_t)(REL) << 17))
+
+#define NCPU32K_MHI(RD,IMM)		NCPU32K_GEN_IMM17(IMM, RD,NCPU32K_OP_MHI)
+#define NCPU32K_LDWU(RD,A,IMM)		NCPU32K_GEN_IMM15(IMM, A,RD,NCPU32K_OP_LDWU)
+#define NCPU32K_MOV(RD,IMM)		NCPU32K_GEN_IMM15(IMM, 0,RD,NCPU32K_OP_ADD_I) /* add.i */
+#define NCPU32K_JMP(RS,RD)			NCPU32K_GEN_ROP(0, RS, RD,NCPU32K_OP_JMP)
+#define NCPU32K_AND_I(RD,RS1,IMM)	NCPU32K_GEN_IMM15(IMM, RS1,	RD,NCPU32K_OP_AND_I)
+#define NCPU32K_OR_I(RD,RS1,IMM)	NCPU32K_GEN_IMM15(IMM, RS1,	RD,NCPU32K_OP_OR_I)
+#define NCPU32K_NOP()           NCPU32K_OP_NOP
+
+#endif
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.md
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.md	2021-09-25 10:31:16.299210080 -0400
@@ -0,0 +1,1404 @@
+;; Machine description for GNU compiler, nano-cpu32k ISA
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GNU CC.
+;;
+;; This program is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by the Free
+;; Software Foundation; either version 3 of the License, or (at your option)
+;; any later version.
+;;
+;; This program is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+;; more details.
+;;
+;; You should have received a copy of the GNU General Public License along
+;; with this program.  If not, see <http://www.gnu.org/licenses/>. */
+
+(define_constants [
+  (SP_REG 2) ; hard stack pointer
+  (FP_REG 3) ; hard frame pointer
+  (CC_REG 34)
+  (LNK_REG 1) ; return address pointer
+  (GOT_REG 14) ; GOT pointer
+
+  ;; unspec values
+  (UNSPEC_FRAME         0)
+  (UNSPEC_GOT           1)
+  (UNSPEC_GOTOFFHI      2)
+  (UNSPEC_GOTOFFLO      3)
+  (UNSPEC_TPOFFLO       4)
+  (UNSPEC_TPOFFHI       5)
+  (UNSPEC_GOTTPOFFLO    6)
+  (UNSPEC_GOTTPOFFHI    7)
+  (UNSPEC_GOTTPOFFLD    8)
+  (UNSPEC_TLSGDLO       9)
+  (UNSPEC_TLSGDHI       10)
+  (UNSPEC_SET_GOT       101)
+  (UNSPEC_CMPXCHG       201)
+  (UNSPEC_FETCH_AND_OP  202)
+])
+
+(include "predicates.md")
+
+(include "constraints.md")
+
+(define_attr "type"
+  "unknown,load,store,move,extend,logic,add,mul,shift,compare,branch,jump,fp,jump_restore"
+  (const_string "unknown"))
+
+;; Number of machine instructions required to implement an insn.
+(define_attr "length" "" (const_int 1))
+
+;; ALU is modelled as a single functional unit, which is reserved for varying
+;; numbers of slots.
+;; Delay may be not right.
+(define_cpu_unit "ncpu32k_alu")
+(define_insn_reservation "bit_unit" 3 (eq_attr "type" "shift") "ncpu32k_alu")
+(define_insn_reservation "lsu_load" 3 (eq_attr "type" "load") "ncpu32k_alu*3")
+(define_insn_reservation "lsu_store" 2 (eq_attr "type" "store") "ncpu32k_alu")
+(define_insn_reservation "alu_unit" 2 (eq_attr "type" "add,logic,extend,move,compare")
+                                                                "ncpu32k_alu")
+(define_insn_reservation "mul_unit" 16 (eq_attr "type" "mul") "ncpu32k_alu*16")
+
+;; AI = Atomic Integers
+;; We do not support DI in our atomic operations.
+(define_mode_iterator AI [QI HI SI])
+
+;; Note: We use 'mult' here for 'nand' since it does not have its own RTX class.
+(define_code_iterator atomic_op [plus minus and ior xor mult])
+(define_code_attr op_name
+  [(plus "add") (minus "sub") (and "and") (ior "or") (xor "xor") (mult "nand")])
+(define_code_attr op_insn
+  [(plus "add") (minus "sub") (and "and") (ior "or") (xor "xor") (mult "and")])
+(define_code_attr post_op_insn
+  [(plus "") (minus "") (and "") (ior "") (xor "")
+   (mult "xor \t%3,%3,0x7fff # fetch_nand: invert 15-bit IMM")])
+
+;; Expand prologue as RTL
+(define_expand "prologue"
+  [(use (const_int 1))]
+  ""
+{
+  ncpu32k_expand_prologue ();
+  DONE;
+})
+
+;; Expand prologue as RTL
+(define_expand "epilogue"
+  [(use (const_int 2))]
+  ""
+{
+  ncpu32k_expand_epilogue ();
+  DONE;
+})
+
+(define_insn "frame_change_clobber_fp"
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (match_operand:SI 0 "nonmemory_operand" "r,I")))
+   (clobber (mem:QI (plus:SI (reg:SI FP_REG)
+			     (unspec:SI [(const_int FP_REG)] UNSPEC_FRAME))))]
+  ""
+  "add \tsp,sp,%0\t# change frame"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "frame_dealloc_clobber_sp"
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (match_operand:SI 0 "nonmemory_operand" "r,I")))
+   (clobber (mem:QI (plus:SI (reg:SI SP_REG)
+			     (unspec:SI [(const_int SP_REG)] UNSPEC_FRAME))))]
+  ""
+  "add \tsp,sp,%0\t#deallocate frame"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "return_internal"
+  [(return)
+   (use (match_operand 0 "pmode_register_operand" ""))]
+  ""
+  "jmp \tr0,%0\t# return_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+
+
+;;***************************************************************************
+;; movQI
+;;***************************************************************************
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+      if (can_create_pseudo_p())
+        {
+          if (GET_CODE (operands[1]) == CONST_INT)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_movsi (reg, operands[1]));
+	      operands[1] = gen_lowpart (QImode, reg);
+	    }
+	  if (GET_CODE (operands[1]) == MEM && optimize > 0)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_rtx_SET (SImode, reg,
+				  gen_rtx_ZERO_EXTEND (SImode,
+						       operands[1])));
+
+	      operands[1] = gen_lowpart (QImode, reg);
+	    }
+          if (GET_CODE (operands[0]) != REG)
+	    operands[1] = force_reg (QImode, operands[1]);
+        }
+")
+
+(define_insn "*movqi_insn"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,r,r,r,r")
+	(match_operand:QI 1 "general_operand"       "r,r,I,K,m"))]
+  ""
+  "@
+   stb \t%0,%1\t# movqi: r
+   or \t%0,%1,0\t# movqi: r
+   add \t%0,r0,%1\t# movqi: I
+   or \t%0,r0,%1\t# movqi: K
+   ldbu \t%0,%1\t# movqi: m"
+  [(set_attr "type" "store,logic,move,logic,load")])
+
+
+;;***************************************************************************
+;; movHI
+;;***************************************************************************
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+      if (can_create_pseudo_p())
+        {
+          if (GET_CODE (operands[1]) == CONST_INT)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_movsi (reg, operands[1]));
+	      operands[1] = gen_lowpart (HImode, reg);
+	    }
+	  else if (GET_CODE (operands[1]) == MEM && optimize > 0)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_rtx_SET (SImode, reg,
+				      gen_rtx_ZERO_EXTEND (SImode,
+					   	           operands[1])));
+	      operands[1] = gen_lowpart (HImode, reg);
+	    }
+          if (GET_CODE (operands[0]) != REG)
+	    operands[1] = force_reg (HImode, operands[1]);
+        }
+        
+      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], HImode))
+        ;
+      else if (CONSTANT_P (operands[1])
+           && GET_CODE (operands[1]) != HIGH
+           && GET_CODE (operands[1]) != LO_SUM)
+      {
+        ncpu32k_emit_set_const16 (operands[0], operands[1]);
+        DONE;
+      }
+")
+
+(define_insn "*movhi_insn"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=m,r,r,r,r,r")
+	(match_operand:HI 1 "general_operand"       "r,r,I,K,m,M"))]
+  ""
+  "@
+   sth \t%0,%1\t# movHI: r
+   or \t%0,%1,0\t# movHI: r
+   add \t%0,r0,%1\t# movHI: I
+   or \t%0,r0,%1\t# movHI: K
+   ldhu \t%0,%1\t# movHI: m
+   mhi \t%0,hi(%1)\t# movHI: M"
+  [(set_attr "type" "store,logic,move,logic,load,move")])
+
+(define_insn "*movhi_iorhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (match_operand:HI 1 "register_operand" "%r")
+		(match_operand:HI 2 "nonmemory_operand" "K")))]
+  ""
+  "or \t%0,%1,%2\t# movHI_iorhi3: K"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; movSI
+;;***************************************************************************
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  ""
+{
+  if (ncpu32k_expand_move (SImode, operands)) DONE;
+})
+
+(define_insn "*movsi_insn"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,r,m")
+        (match_operand:SI 1 "input_operand"       "I,K,M,r,m,r"))]
+  "(register_operand (operands[0], SImode)
+   || (register_operand (operands[1], SImode))
+   || (operands[1] == const0_rtx))"
+  "@
+  add \t%0,r0,%1\t# movSI: I
+  or \t%0,r0,%1\t# movSI: K
+  mhi \t%0,hi(%1)\t# movSI: M
+  or \t%0,%1,0\t# movSI: r
+  ldwu \t%0,%1\t# movSI: SI load
+  stw \t%0,%1\t# movSI: SI store"
+  [(set_attr "type" "move,logic,move,logic,load,store")
+   (set_attr "length" "1,1,1,1,1,1")])
+
+(define_insn "movsi_lo_sum"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i")))]
+  ""
+  "or \t%0,%1,lo(%2)\t# movsi_lo_sum"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_high"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(high:SI (match_operand:SI 1 "immediate_operand" "i")))]
+  ""
+  "mhi \t%0,hi(%1)\t# movsi_high"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gotoff_lo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+ 	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                    (match_operand 2 "" ""))] UNSPEC_GOTOFFLO))]
+  "flag_pic"
+  "or \t%0,%1,gotoff_lo(%2)\t# movsi_gotoff_lo"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gotoff_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+ 	(unspec:SI [(match_operand 1 "" "")] UNSPEC_GOTOFFHI))]
+  "flag_pic"
+  "mhi \t%0,gotoff_hi(%1)\t# movsi_gotoff_hi"
+  [(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec:SI [(match_operand 1 "symbolic_operand" "")] UNSPEC_GOT))
+   (use (reg:SI GOT_REG))]
+  "flag_pic"
+  "ldwu \t%0,got(%1)(rgot)"
+  [(set_attr "type" "load")]
+)
+
+(define_insn "movsi_tlsgdlo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_TLSGDLO))]
+  ""
+  "or \t%0,%1,tlsgdlo(%2)\t# movsi_tlsgdlo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tlsgdhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_TLSGDHI))]
+  ""
+  "mhi \t%0,tlsgdhi(%1)\t# movsi_tlsgdhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gottpofflo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_GOTTPOFFLO))]
+  ""
+  "or \t%0,%1,gottpofflo(%2)\t# movsi_gottpofflo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gottpoffhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_GOTTPOFFHI))]
+  ""
+  "mhi \t%0,gottpoffhi(%1)\t# movsi_gottpoffhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "load_gottpoff"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "register_operand" "r")] UNSPEC_GOTTPOFFLD))]
+  ""
+  "ldwu \t%0,0(%1)\t# load_gottpoff"
+[(set_attr "type" "load")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tpofflo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_TPOFFLO))]
+  ""
+  "or \t%0,%1,tpofflo(%2)\t# movsi_tpofflo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tpoffhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_TPOFFHI))]
+  ""
+  "mhi \t%0,tpoffhi(%1) # movsi_tpoffhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+
+(define_insn_and_split "movsi_insn_big"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operand:SI 1 "immediate_operand" "i"))]
+  "GET_CODE (operands[1]) != CONST_INT"
+  ;; the switch of ncpu32k bfd to Rela allows us to schedule insns separately.
+  "mhi \t%0,hi(%1)\;or \t%0,%0,lo(%1)"
+  "(GET_CODE (operands[1]) != CONST_INT
+    || ! (CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'I', \"I\")
+	  || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'K', \"K\")
+	  || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'M', \"M\")))
+   && reload_completed
+   && GET_CODE (operands[1]) != HIGH && GET_CODE (operands[1]) != LO_SUM"
+  [(pc)]
+{
+  if (!ncpu32k_expand_symbol_ref(SImode, operands))
+    {
+      emit_insn (gen_movsi_high (operands[0], operands[1]));
+      emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));
+    }
+  DONE;
+}
+  [(set_attr "type" "move")
+   (set_attr "length" "2")])
+
+
+;;***************************************************************************
+;; Conditional add
+;;*************************************************************************** 
+
+(define_expand "addsicc"
+  [(match_operand:SI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:SI 2 "register_operand" "")
+   (match_operand:SI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+(define_expand "addhicc"
+  [(match_operand:HI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:HI 2 "register_operand" "")
+   (match_operand:HI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+(define_expand "addqicc"
+  [(match_operand:QI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:QI 2 "register_operand" "")
+   (match_operand:QI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+
+;;***************************************************************************
+;; conditional moves
+;;***************************************************************************
+
+(define_expand "movsicc"
+   [(set (match_operand:SI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:SI 2 "register_operand" "")
+			  (match_operand:SI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+(define_expand "movhicc"
+   [(set (match_operand:HI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:HI 2 "register_operand" "")
+			  (match_operand:HI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+(define_expand "movqicc"
+   [(set (match_operand:QI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:QI 2 "register_operand" "")
+			  (match_operand:QI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+
+;;***************************************************************************
+;; Conditional branch
+;;***************************************************************************
+
+(define_insn "*cbranchsi4_zero2"
+  [(set (pc)
+	(if_then_else (match_operator 0 "comparison_operator"
+			[(match_operand:SI 1 "register_operand" "r")
+			 (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+{
+  rtx tmp_reg;
+  enum rtx_code code;
+
+  code = GET_CODE (operands[0]);
+
+  switch (code) {
+    case GT:
+      return "bcc \tr0,lt,%1,%2\t# cbranchsi4";
+    case GTU:
+      return "bcc \tr0,ltu,%1,%2\t# cbranchsi4";
+
+    case GE:
+      return "bcc \t%1,ge,r0,%2\t# cbranchsi4";
+    case GEU:
+      return "bcc \t%1,geu,r0,%2\t# cbranchsi4";
+
+    case LT:
+      return "bcc \t%1,lt,r0,%2\t# cbranchsi4";
+    case LTU:
+      return "bcc \t%1,ltu,r0,%2\t# cbranchsi4";
+
+    case LE:
+      return "bcc \tr0,ge,%1,%2\t# cbranchsi4";
+    case LEU:
+      return "bcc \tr0,geu,%1,%2\t# cbranchsi4";
+
+    case EQ:
+      return "bcc \t%1,eq,r0,%2\t# cbranchsi4";
+    case NE:
+      return "bcc \t%1,ne,r0,%2\t# cbranchsi4";
+ 
+    default:
+      abort ();
+  }
+}
+  [(set_attr "type" "branch")
+   (set_attr "length" "1")])
+
+
+(define_insn "*cbranchsi4_zero1"
+  [(set (pc)
+	(if_then_else (match_operator 0 "comparison_operator"
+			[(const_int 0)
+			 (match_operand:SI 1 "register_operand" "r")])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+{
+  rtx tmp_reg;
+  enum rtx_code code;
+
+  code = GET_CODE (operands[0]);
+
+  switch (code) {
+    case GT:
+      return "bcc \t%1,lt,r0,%2\t# cbranchsi4";
+    case GTU:
+      return "bcc \t%1,ltu,r0,%2\t# cbranchsi4";
+
+    case GE:
+      return "bcc \tr0,ge,%1,%2\t# cbranchsi4";
+    case GEU:
+      return "bcc \tr0,geu,%1,%2\t# cbranchsi4";
+
+    case LT:
+      return "bcc \tr0,lt,%1,%2\t# cbranchsi4";
+    case LTU:
+      return "bcc \tr0,ltu,%1,%2\t# cbranchsi4";
+
+    case LE:
+      return "bcc \t%1,ge,r0,%2\t# cbranchsi4";
+    case LEU:
+      return "bcc \t%1,geu,r0,%2\t# cbranchsi4";
+
+    case EQ:
+      return "bcc \tr0,eq,%1,%2\t# cbranchsi4";
+    case NE:
+      return "bcc \tr0,ne,%1,%2\t# cbranchsi4";
+ 
+    default:
+      abort ();
+  }
+}
+  [(set_attr "type" "branch")
+   (set_attr "length" "1")])
+
+(define_insn "cbranchsi4"
+  [(set (pc)
+	(if_then_else (match_operator 0 "comparison_operator"
+			[(match_operand:SI 1 "register_operand" "r")
+			 (match_operand:SI 2 "register_operand" "r")])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  ""
+{
+  rtx tmp_reg;
+  enum rtx_code code;
+
+  code = GET_CODE (operands[0]);
+
+  switch (code) {
+    case GT:
+      return "bcc \t%2,lt,%1,%3\t# cbranchsi4";
+    case GTU:
+      return "bcc \t%2,ltu,%1,%3\t# cbranchsi4";
+
+    case GE:
+      return "bcc \t%1,ge,%2,%3\t# cbranchsi4";
+    case GEU:
+      return "bcc \t%1,geu,%2,%3\t# cbranchsi4";
+
+    case LT:
+      return "bcc \t%1,lt,%2,%3\t# cbranchsi4";
+    case LTU:
+      return "bcc \t%1,ltu,%2,%3\t# cbranchsi4";
+
+    case LE:
+      return "bcc \t%2,ge,%1,%3\t# cbranchsi4";
+    case LEU:
+      return "bcc \t%2,geu,%1,%3\t# cbranchsi4";
+
+    case EQ:
+      return "bcc \t%1,eq,%2,%3\t# cbranchsi4";
+    case NE:
+      return "bcc \t%1,ne,%2,%3\t# cbranchsi4";
+ 
+    default:
+      abort ();
+  }
+}
+  [(set_attr "type" "branch")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; move float/double
+;;***************************************************************************
+
+(define_insn_and_split "movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r, r, m, r")
+	(match_operand:DI 1 "general_operand"      " r, m, r, n"))]
+  ""
+  "*
+    return ncpu32k_output_move_double (operands);
+  "
+  "&& reload_completed && CONSTANT_P (operands[1])"
+  [(set (match_dup 2) (match_dup 3)) (set (match_dup 4) (match_dup 5))]
+  "operands[2] = operand_subword (operands[0], 0, 0, DImode);
+   operands[3] = operand_subword (operands[1], 0, 0, DImode);
+   operands[4] = operand_subword (operands[0], 1, 0, DImode);
+   operands[5] = operand_subword (operands[1], 1, 0, DImode);"
+  [(set_attr "length" "2,2,2,3")])
+
+;; Moving double and single precision floating point values
+
+
+(define_insn "movdf"
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=r, r, m, r")
+	(match_operand:DF 1 "general_operand"      " r, m, r, i"))]
+  ""
+  "*
+    return ncpu32k_output_move_double (operands);
+  "
+  [(set_attr "length" "2,2,2,3")])
+
+
+(define_insn "movsf"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,m")
+        (match_operand:SF 1 "general_operand"  "r,m,r"))]
+  ""
+  "@
+   or \t%0,%1,0\t# movsf
+   ldwu \t%0,%1\t# movsf
+   stw \t%0,%1\t# movsf"
+  [(set_attr "type" "move,load,store")
+   (set_attr "length" "1,1,1")])
+
+
+;;***************************************************************************
+;; extendqisi2
+;;***************************************************************************
+
+(define_expand "extendqisi2"
+  [(use (match_operand:SI 0 "register_operand" ""))
+   (use (match_operand:QI 1 "nonimmediate_operand" ""))]
+  ""
+  "
+{
+  if ( GET_CODE(operands[1]) == MEM ) {
+    emit_insn (gen_extendqisi2_ext_mem(operands[0], operands[1]));
+  }
+  else {
+    emit_insn (gen_extendqisi2_ext_reg(operands[0], operands[1]));
+  }
+ DONE;
+}")
+
+(define_insn "extendqisi2_ext_mem"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (sign_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
+  ""
+  "ldb \t%0,%1\t# extendqisi2_ext_mem"
+  [(set_attr "length" "1")
+   (set_attr "type" "load")])
+
+(define_expand "extendqisi2_ext_reg"
+  [(set (match_dup 2)
+	(ashift:SI (match_operand:QI 1 "register_operand" "")
+		   (const_int 24)))
+   (set (match_operand:SI 0 "register_operand" "")
+	(ashiftrt:SI (match_dup 2)
+		     (const_int 24)))]
+  ""
+  "
+{
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  operands[2] = gen_reg_rtx (SImode);
+}")
+
+;;***************************************************************************
+;; extendhisi2
+;;***************************************************************************
+
+(define_expand "extendhisi2"
+  [(use (match_operand:SI 0 "register_operand" ""))
+   (use (match_operand:HI 1 "nonimmediate_operand" ""))]
+  ""
+  "
+{
+  if ( GET_CODE(operands[1]) == MEM ) {
+    emit_insn (gen_extendhisi2_ext_mem(operands[0], operands[1]));
+  }
+  else {
+    emit_insn (gen_extendhisi2_ext_reg(operands[0], operands[1]));
+  }
+ DONE;
+}")
+
+(define_insn "extendhisi2_ext_mem"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (sign_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
+  ""
+  "ldh \t%0,%1\t# extendhisi2_ext_mem"
+  [(set_attr "length" "1")
+   (set_attr "type" "load")])
+
+(define_expand "extendhisi2_ext_reg"
+  [(set (match_dup 2)
+	(ashift:SI (match_operand:HI 1 "register_operand" "")
+		   (const_int 16)))
+   (set (match_operand:SI 0 "register_operand" "")
+	(ashiftrt:SI (match_dup 2)
+		     (const_int 16)))]
+  ""
+  "
+{
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  operands[2] = gen_reg_rtx (SImode);
+}")
+
+
+;;***************************************************************************
+;; zero_extend<m><n>2
+;;***************************************************************************
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   and \t%0,%1,0xff\t# zero_extendqisi2
+   ldbu \t%0,%1\t# zero_extendqisi2"
+  [(set_attr "type" "logic,load")
+   (set_attr "length" "1,1")])
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   lsl \t%0,%1,16\t# zero_extendhisi2_reg\;lsr \t%0,%0,16\t# zero_extendhisi2_reg
+   ldhu \t%0,%1\t# zero_extendhisi2"
+  [(set_attr "type" "logic,load")
+   (set_attr "length" "2,1")])
+
+;;***************************************************************************
+;; Shift/rotate operations
+;;***************************************************************************
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashift:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   lsl \t%0,%1,%2\t# ashlsi3
+   lsl \t%0,%1,%2\t# ashlsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   asr \t%0,%1,%2\t# ashrsi3
+   asr \t%0,%1,%2\t# ashrsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   lsr \t%0,%1,%2\t# lshrsi3
+   lsr \t%0,%1,%2\t# lshrsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+;;***************************************************************************
+;; Logical bitwise operations
+;;***************************************************************************
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(and:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,K")))]
+  ""
+  "@
+   and \t%0,%1,%2\t# andsi3: r
+   and \t%0,%1,%2\t# andsi3: K"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,K")))]
+  ""
+  "@
+   or \t%0,%1,%2\t# iorsi3: r
+   or \t%0,%1,%2\t# iorsi3: K"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   xor \t%0,%1,%2\t# xorsi3: r
+   xor \t%0,%1,%2\t# xorsi3: I"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "one_cmplqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(not:QI (match_operand:QI 1 "register_operand" "r")))]
+  ""
+  "xor \t%0,%1,0x00ff\t# one_cmplqi2"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(not:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "xor \t%0,%1,0x7fff\t# one_cmplsi2 15-bit IMM"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; Arithmetic add/sub 
+;;***************************************************************************
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "sub \t%0,r0,%1\t# negsi2"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(plus:SI (match_operand:SI 1 "register_operand" "%r,r")
+		 (match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   add \t%0,%1,%2\t# addsi3: r
+   add \t%0,%1,%2\t# addsi3: I"
+  [(set_attr "type" "add,add")
+   (set_attr "length" "1,1")])
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(minus:SI (match_operand:SI 1 "register_operand" "r,r")
+		  (match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   sub \t%0,%1,%2\t# subsi3: r
+   add \t%0,%1,%n2\t# subsi3: I"
+  [(set_attr "type" "add,add")]
+)
+
+;;***************************************************************************
+;; Arithmetic mul/div
+;;***************************************************************************
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (mult:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MUL"
+  "mul \t%0,%1,%2\t# mulsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+(define_insn "divsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (div:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_DIV"
+  "div \t%0,%1,%2\t# divsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (udiv:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_DIV"
+  "divu \t%0,%1,%2\t# udivsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+   
+(define_insn "modsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (mod:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MOD"
+  "mod \t%0,%1,%2\t# modsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+   
+(define_insn "umodsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (umod:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MOD"
+  "modu \t%0,%1,%2\t# umodsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; Jumps
+;;***************************************************************************
+
+(define_expand "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "
+{
+  emit_jump_insn (gen_jump_internal (operands[0]));
+  DONE;
+}")
+
+(define_insn "jump_internal"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "jmp \tr0,%l0\t# jump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect jump
+
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "
+{
+  emit_jump_insn (gen_indirect_jump_internal (operands[0]));
+  DONE;
+
+}")
+
+(define_insn "indirect_jump_internal"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jmp \tr0,%0\t# indirect_jump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; table jump
+
+(define_expand "tablejump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+   ""
+  "
+{
+  if (CASE_VECTOR_PC_RELATIVE || flag_pic)
+    operands[0]
+      = force_reg (Pmode,
+		   gen_rtx_PLUS (Pmode, operands[0],
+				 gen_rtx_LABEL_REF (Pmode, operands[1])));
+  emit_jump_insn (gen_tablejump_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "tablejump_internal"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jmp \tr0,%0\t# tablejump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; Calls
+;;***************************************************************************
+
+(define_expand "call"
+  [(parallel [(call (match_operand:SI 0 "sym_ref_mem_operand" "")
+		    (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "call_internal"
+[(parallel [(call (match_operand:SI 0 "sym_ref_mem_operand" "")
+                  (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  {
+    if (flag_pic)
+      {
+	crtl->uses_pic_offset_table = 1;
+	return "jmp \tlnk,plt(%S0)\t# call_internal%(";
+      }
+
+    return "jmp \tlnk,%S0\t# call_internal%(";
+  }
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; call value
+
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+		   (call (match_operand:SI 1 "sym_ref_mem_operand" "")
+			 (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_value_internal (operands[0], operands[1], operands[2]));
+  DONE;
+}")
+
+(define_insn "call_value_internal"
+[(parallel [(set (match_operand 0 "register_operand" "=r")
+                  (call (match_operand:SI 1 "sym_ref_mem_operand" "")
+                        (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  {
+    if (flag_pic)
+      {
+	crtl->uses_pic_offset_table = 1;
+	return "jmp \tlnk,plt(%S1)\t# call_value_internal%(";
+      }
+    return "jmp \tlnk,%S1\t# call_value_internal%(";
+  }
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect call value 
+
+(define_expand "call_value_indirect"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+                   (call (mem:SI (match_operand:SI 1 "register_operand" "r"))
+                         (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_value_indirect_internal (operands[0], operands[1], operands[2]));
+  DONE;
+}")
+
+(define_insn "call_value_indirect_internal"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+                   (call (mem:SI (match_operand:SI 1 "register_operand" "r"))
+                         (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "jmp \tlnk,%1\t# call_value_indirect_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect call
+
+(define_expand "call_indirect"
+  [(parallel [(call (mem:SI (match_operand:SI 0 "register_operand" "r"))
+		    (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_indirect_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "call_indirect_internal"
+[(parallel [(call (mem:SI (match_operand:SI 0 "register_operand" "r"))
+                  (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "jmp \tlnk,%0 # call_indirect_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; no-op
+;;***************************************************************************
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; Floating Point
+;;***************************************************************************
+
+(define_insn "addsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (plus:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fadds \t%0,%1,%2\t# addsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+   
+(define_insn "subsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (minus:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fsubs \t%0,%1,%2\t# subsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+(define_insn "mulsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (mult:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fmuls \t%0,%1,%2\t# mulsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+(define_insn "divsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (div:SF (match_operand:SF 1 "register_operand" "r")
+		(match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fdivs \t%0,%1,%2\t# divsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+
+;; Conversion between fixed point and floating point.
+
+(define_insn "floatsisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fitfs \t%0, %1\t# floatsisf2"
+  [(set_attr "type" "fp")
+   (set_attr "length" "1")])
+
+;; FIXME! not working 
+(define_insn "fixunssfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fftis \t%0, %1\t# fixunssfsi2"
+  [(set_attr "type" "fp")
+   (set_attr "length" "1")])
+
+
+;; Single precision floating point comparision instructions
+
+(define_insn "*cmpsf_eq"
+  [(set (reg:CCEQ CC_REG)
+	(compare:CCEQ (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,eq,%1\t# cmpsf_eq"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsf_gt"
+  [(set (reg:CCGT CC_REG)
+	(compare:CCGT (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,%gt,1\t# cmpsf_gt"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsf_lt"
+  [(set (reg:CCLT CC_REG)
+	(compare:CCLT (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,gt,%1\t# cmpsf_lt"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; set GOT.
+;;***************************************************************************
+
+(define_insn "set_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(const_int 0)] UNSPEC_SET_GOT))
+   (clobber (reg:SI LNK_REG))
+   (clobber (reg:SI GOT_REG))]
+  ""
+    "# set_got
+    \tjmp \tlnk,4
+    \tmhi \trgot, got_pcrel_hi(_GLOBAL_OFFSET_TABLE_+0)
+    \tor \trgot,rgot, got_pcrel_lo(_GLOBAL_OFFSET_TABLE_+4)
+    \tadd \trgot,rgot, lnk"
+  [(set_attr "length" "16")])
+
+(define_expand "atomic_compare_and_swap<mode>"
+  [(match_operand:SI 0 "register_operand")   ;; bool output
+   (match_operand:AI 1 "register_operand")   ;; val output
+   (match_operand:AI 2 "memory_operand")     ;; memory
+   (match_operand:AI 3 "register_operand")   ;; expected
+   (match_operand:AI 4 "register_operand")   ;; desired
+   (match_operand:SI 5 "const_int_operand")  ;; is_weak
+   (match_operand:SI 6 "const_int_operand")  ;; mod_s
+   (match_operand:SI 7 "const_int_operand")] ;; mod_f
+  ""
+{
+  if (<MODE>mode == SImode)
+    emit_insn (gen_cmpxchg (operands[0], operands[1], operands[2], operands[3],
+                            operands[4]));
+  else
+    ncpu32k_expand_cmpxchg_qihi (operands[0], operands[1], operands[2],
+                              operands[3], operands[4], INTVAL (operands[5]),
+                              (enum memmodel) INTVAL (operands[6]),
+                              (enum memmodel) INTVAL (operands[7]));
+  DONE;
+})
+
+;;***************************************************************************
+;; Atmoic
+;;***************************************************************************
+
+(define_insn "cmpxchg"
+   [(set (match_operand:SI 0 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_operand:SI 2 "memory_operand" "+m")]
+          UNSPEC_CMPXCHG))
+    (set (match_dup 2)
+         (unspec_volatile:SI [(match_operand:SI 3 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+    (set (match_operand:SI 1 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_dup 2) (match_dup 3)
+                             (match_operand:SI 4 "register_operand" "r")]
+          UNSPEC_CMPXCHG))]
+  ""
+    "
+    ldwa \t%1,0(%2)\t# cmpxchg: load
+    bcc \t%1,ne,%3,1f\t# cmpxchg: b
+    or \t%0,r0,0\t# cmpxchg: result = 0
+    stwa \t%0,%2,%4\t# cmpxchg: store new
+  1:
+  "
+)
+
+(define_insn "cmpxchg_mask"
+   [(set (match_operand:SI 0 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_operand:SI 2 "memory_operand" "+m")]
+          UNSPEC_CMPXCHG))
+    (set (match_dup 2)
+         (unspec_volatile:SI [(match_operand:SI 3 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+    (set (match_operand:SI 1 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_dup 2) (match_dup 3)
+                             (match_operand:SI 4 "register_operand" "r")
+                             (match_operand:SI 5 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+   (clobber (match_scratch:SI 6 "=&r"))]
+  ""
+  "
+   ldwa \t%6,0(%2)\t# cmpxchg: load
+   and \t%1,%6,%5\t# cmpxchg: mask old
+   and \t%4,%4,%5\t# cmpxchg: mask set
+   bcc \t%1,ne,%3,1f\t# cmpxchg: b
+   or \t%0,r0,0\t# cmpxchg: result = 0
+   xor \t%6,%6,%1\t# cmpxchg: clear
+   or \t%6,%6,%4\t# cmpxchg: set
+   stwa \t%0,%2,%6\t# cmpxchg: store new
+  1:
+  "
+)
+
+(define_expand "atomic_fetch_<op_name><mode>"
+  [(match_operand:AI 0 "register_operand")
+   (match_operand:AI 1 "memory_operand")
+   (match_operand:AI 2 "register_operand")
+   (match_operand:SI 3 "const_int_operand")
+   (atomic_op:AI (match_dup 0) (match_dup 1))]
+  ""
+{
+  rtx ret = gen_reg_rtx (<MODE>mode);
+  if (<MODE>mode != SImode)
+    ncpu32k_expand_fetch_op_qihi (operands[0], operands[1], operands[2], ret,
+                               gen_fetch_and_<op_name>_mask);
+  else
+    emit_insn (gen_fetch_and_<op_name> (operands[0], operands[1], operands[2],
+                                        ret));
+  DONE;
+})
+
+(define_expand "atomic_<op_name>_fetch<mode>"
+  [(match_operand:AI 0 "register_operand")
+   (match_operand:AI 1 "memory_operand")
+   (match_operand:AI 2 "register_operand")
+   (match_operand:SI 3 "const_int_operand")
+   (atomic_op:AI (match_dup 0) (match_dup 1))]
+  ""
+{
+  rtx ret = gen_reg_rtx (<MODE>mode);
+  if (<MODE>mode != SImode)
+    ncpu32k_expand_fetch_op_qihi (ret, operands[1], operands[2], operands[0],
+                               gen_fetch_and_<op_name>_mask);
+  else
+    emit_insn (gen_fetch_and_<op_name> (ret, operands[1], operands[2],
+                                        operands[0]));
+  DONE;
+})
+
+(define_insn "fetch_and_<op_name>"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+        (match_operand:SI 1 "memory_operand" "+m"))
+   (set (match_operand:SI 3 "register_operand" "=&r")
+        (unspec_volatile:SI [(match_dup 1)
+                             (match_operand:SI 2 "register_operand" "r")]
+         UNSPEC_FETCH_AND_OP))
+   (set (match_dup 1)
+        (match_dup 3))
+   (clobber (match_scratch:SI 4 "=&r"))
+   (atomic_op:SI (match_dup 0) (match_dup 1))]
+  ""
+    "
+1:
+   ldwa \t%0,0(%1)\t# fetch_<op_name>: load
+   <op_insn>\t%3,%0,%2\t# fetch_<op_name>: logic
+   <post_op_insn>
+   stwa \t%4,%1,%3\t# fetch_<op_name>: store new
+   bcc \t%4,eq,r0,1b\t# fetch_<op_name>: done
+")
+
+(define_insn "fetch_and_<op_name>_mask"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+        (match_operand:SI 1 "memory_operand" "+m"))
+   (set (match_operand:SI 3 "register_operand" "=&r")
+        (unspec_volatile:SI [(match_dup 1)
+                             (match_operand:SI 2 "register_operand" "r")
+                             (match_operand:SI 4 "register_operand" "r")]
+         UNSPEC_FETCH_AND_OP))
+   (set (match_dup 1)
+        (unspec_volatile:SI [(match_dup 3) (match_dup 4)] UNSPEC_FETCH_AND_OP))
+   (clobber (match_scratch:SI 5 "=&r"))
+   (atomic_op:SI (match_dup 0) (match_dup 1))]
+  ""
+    "
+1:
+   ldwa \t%0,0(%1)\t# fetch_<op_name>: load
+   and \t%5,%0,%4\t# fetch_<op_name>: mask
+   xor \t%5,%0,%5\t# fetch_<op_name>: clear
+   <op_insn>\t%3,%0,%2\t# fetch_<op_name>: logic
+   <post_op_insn>
+   and \t%3,%3,%4\t# fetch_<op_name>: mask result
+   or \t%3,%5,%3\t# fetch_<op_name>: set
+   stwa \t%5,%1,%3\t# fetch_<op_name>: store new
+   bcc \t%5,eq,r0,1b\t# fetch_<op_name>: done
+")
+
+;; Local variables:
+;; mode:emacs-lisp
+;; comment-start: ";; "
+;; eval: (set-syntax-table (copy-sequence (syntax-table)))
+;; eval: (modify-syntax-entry ?[ "(]")
+;; eval: (modify-syntax-entry ?] ")[")
+;; eval: (modify-syntax-entry ?{ "(}")
+;; eval: (modify-syntax-entry ?} "){")
+;; eval: (setq indent-tabs-mode t)
+;; End:
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def	2019-09-29 04:32:24.709765000 -0400
@@ -0,0 +1,39 @@
+/* Definitions of target machine for GNU compiler, for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 2, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.  */
+
+/* Add any extra modes needed to represent the condition code.
+ */
+
+CC_MODE (CCEQ);
+CC_MODE (CCNE);
+
+CC_MODE (CCLE);
+CC_MODE (CCGE);
+CC_MODE (CCLT);
+CC_MODE (CCGT);
+
+CC_MODE (CCLEU);
+CC_MODE (CCGEU);
+CC_MODE (CCLTU);
+CC_MODE (CCGTU);
+
+CC_MODE(CCFP);
+CC_MODE(CCUNS);
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.opt gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.opt
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.opt	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.opt	2021-09-25 05:32:50.432115768 -0400
@@ -0,0 +1,58 @@
+; Options for the nano-cpu32k port of the compiler
+; Copyright (C) 2019 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+HeaderInclude
+config/ncpu32k/ncpu32k-opts.h
+
+mnewlib
+Target Report
+Compile for the Linux/Gnu/newlib based toolchain
+
+mhard-mod
+Target RejectNegative Mask(HARD_MOD)
+Use hardware modulo.
+
+msoft-mod
+Target RejectNegative InverseMask(HARD_MOD)
+Do not use hardware modulo.
+
+mhard-mul
+Target RejectNegative Mask(HARD_MUL)
+Use hardware multiplication
+
+msoft-mul
+Target RejectNegative InverseMask(HARD_MUL)
+Do not use hardware multiplication
+
+mhard-div
+Target RejectNegative Mask(HARD_DIV)
+Use hardware division
+
+msoft-div
+Target RejectNegative InverseMask(HARD_DIV)
+Do not use hardware division
+
+mhard-float
+Target RejectNegative Mask(HARD_FLOAT)
+Use hardware floating point
+
+msoft-float
+Target RejectNegative InverseMask(HARD_FLOAT)
+Do not use hardware floating point
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h	2019-09-21 04:59:06.990196000 -0400
@@ -0,0 +1,4 @@
+#ifndef NCPU32K_OPTS_H
+#define NCPU32K_OPTS_H
+
+#endif
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h	2021-03-28 10:42:25.824588374 -0400
@@ -0,0 +1,63 @@
+/* Definitions of target machine for GNU compiler, nano-cpu32k version.
+
+   Copyright (C) 2019 Free Software Foundation, Inc
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_NCPU32K_PROTOS_H
+#define GCC_NCPU32K_PROTOS_H
+
+/* The following are for general support. */
+extern int         ncpu32k_trampoline_code_size (void);
+
+/* The following are only needed when handling the machine definition. */
+#ifdef RTX_CODE
+extern void        ncpu32k_init_expanders (void);
+extern void        ncpu32k_expand_prologue (void);
+extern void        ncpu32k_expand_epilogue (void);
+extern bool        ncpu32k_expand_move (enum machine_mode mode, rtx operands[]);
+extern const char *ncpu32k_output_move_double (rtx *operands);
+extern void        ncpu32k_emit_set_const32 (rtx  op0,
+                                          rtx  op1);
+extern void        ncpu32k_emit_set_const16 (rtx  op0,
+                                          rtx  op1);
+extern bool        ncpu32k_expand_symbol_ref (enum machine_mode mode,
+                                           rtx operands[]);
+extern enum machine_mode ncpu32k_select_cc_mode (enum rtx_code op);
+extern void        ncpu32k_expand_cmpxchg_qihi (rtx bval, rtx retval,
+                        rtx mem, rtx oldval, rtx newval, int is_weak,
+                        enum memmodel success_mode, enum memmodel failure_mode);
+extern void  ncpu32k_expand_fetch_op_qihi (rtx oldval, rtx mem, rtx operand,
+                                        rtx newval, rtx (*generator)(rtx, rtx, rtx, rtx, rtx));
+#endif
+
+extern int ncpu32k_struct_alignment (tree);
+extern int ncpu32k_data_alignment (tree, int);
+
+extern int ncpu32k_initial_elimination_offset (int, int);
+extern bool ncpu32k_save_reg_p_cached (int regno);
+extern void ncpu32k_print_jump_restore (rtx jump_address);
+extern rtx ncpu32k_eh_return_handler_rtx (void);
+extern rtx ncpu32k_return_addr_rtx (int, rtx);
+
+extern int ncpu32k_legitimate_pic_operand_p (rtx x);
+
+/* For RETURN_ADDR_RTX */
+extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);
+
+#endif /* GCC_NCPU32K_PROTOS_H */
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/predicates.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/predicates.md
--- gcc-5.4.0/gcc/config/ncpu32k/predicates.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/predicates.md	2021-03-28 07:57:00.681637680 -0400
@@ -0,0 +1,121 @@
+;; Predicate definitions for nano-cpu32k
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "cc_reg_operand"
+  (match_code "subreg,reg")
+{
+  register_operand (op, mode);
+
+  if (GET_CODE (op) == REG && REGNO (op) == CC_REG)
+    return 1;
+
+  return 0;
+})
+
+(define_predicate "input_operand"
+  (match_code "subreg,reg,const_int,mem,const")
+{
+  /* If both modes are non-void they must be the same.  */
+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))
+    return 0;
+
+  /* Allow any one instruction integer constant, and all CONST_INT
+     variants when we are working in DImode and !arch64.  */
+  if (GET_MODE_CLASS (mode) == MODE_INT
+      && ((GET_CODE (op) == CONST_INT)
+	  && (satisfies_constraint_K (op)
+	      || satisfies_constraint_M (op)
+	      || satisfies_constraint_I (op))))
+    return 1;
+
+  if (register_operand (op, mode))
+    return 1;
+
+  /* If this is a SUBREG, look inside so that we handle
+     paradoxical ones.  */
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+
+
+  /* Check for valid MEM forms.  */
+  if (GET_CODE (op) == MEM)
+    return memory_address_p (mode, XEXP (op, 0));
+
+  return 0;
+})
+
+(define_predicate "sym_ref_mem_operand"
+  (match_code "mem")
+{
+  if (GET_CODE (op) == MEM)
+    {
+      rtx t1 = XEXP (op, 0);
+      if (GET_CODE (t1) == SYMBOL_REF)
+	return 1;
+    }
+  return 0;
+})
+
+;; True iff OP is a symbolic operand.
+
+(define_predicate "symbolic_operand"
+  (match_code "symbol_ref,label_ref,const")
+{
+  switch (GET_CODE (op))
+    {
+    case SYMBOL_REF:
+      return !SYMBOL_REF_TLS_MODEL (op);
+    case LABEL_REF:
+      return true;
+    case CONST:
+      op = XEXP (op, 0);
+      return (GET_CODE (op) == PLUS
+	      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF
+		   && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))
+		  || GET_CODE (XEXP (op, 0)) == LABEL_REF)
+	      && GET_CODE (XEXP (op, 1)) == CONST_INT);
+    default:
+      break;
+    }
+  return false;
+})
+
+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.
+(define_predicate "tgd_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC")))
+
+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.
+
+(define_predicate "tld_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC")))
+
+;; Return true if OP is a symbolic operand for the TLS Initial Exec model.
+
+(define_predicate "tie_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC")))
+
+;; Return true if OP is a symbolic operand for the TLS Local Exec model.
+
+(define_predicate "tle_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC")))
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/t-linux gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-linux
--- gcc-5.4.0/gcc/config/ncpu32k/t-linux	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-linux	2019-09-29 04:32:45.553766000 -0400
@@ -0,0 +1,3 @@
+MULTILIB_DIRNAMES =
+EXTRA_MULTILIB_PARTS = crti.o crtbegin.o crtend.o crtn.o
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/t-ncpu32k gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-ncpu32k
--- gcc-5.4.0/gcc/config/ncpu32k/t-ncpu32k	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-ncpu32k	2019-09-29 04:34:12.809768000 -0400
@@ -0,0 +1,6 @@
+# not support -g so don't use it
+LIBGCC2_DEBUG_CFLAGS =
+
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
+MULTILIB_MATCHES =
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config.gcc gcc-ncpu32k-5.4.0/gcc/config.gcc
--- gcc-5.4.0/gcc/config.gcc	2015-09-10 10:17:53.000000000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/config.gcc	2019-09-21 04:29:54.582153000 -0400
@@ -417,6 +417,9 @@
 	extra_headers="loongson.h"
 	extra_options="${extra_options} g.opt mips/mips-tables.opt"
 	;;
+ncpu32k-*-*)
+	cpu_type=ncpu32k
+	;;
 nds32*)
 	cpu_type=nds32
 	extra_headers="nds32_intrinsic.h"
@@ -2207,6 +2210,17 @@
 	cxx_target_objs="msp430-c.o"
 	tmake_file="${tmake_file} msp430/t-msp430"
 	;;
+ncpu32k-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h ${cpu_type}/elf.h"
+	extra_parts="crti.o crtbegin.o crtend.o crtn.o"
+	tmake_file=ncpu32k/t-ncpu32k
+	tm_defines="${tm_defines}"
+	;;
+ncpu32k-*-linux-*)
+	tm_file="${tm_file} dbxelf.h elfos.h ncpu32k/elf.h gnu-user.h linux.h ncpu32k/linux-gas.h ncpu32k/linux-elf.h uclibc-stdint.h"
+	tmake_file="ncpu32k/t-ncpu32k ncpu32k/t-linux ${tmake_file}"
+	tm_defines="${tm_defines}"
+	;;
 nds32le-*-*)
 	target_cpu_default="0"
 	tm_defines="${tm_defines}"
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/configure gcc-ncpu32k-5.4.0/gcc/configure
--- gcc-5.4.0/gcc/configure	2019-09-21 03:11:35.942037000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/configure	2019-09-29 04:39:51.309776000 -0400
@@ -23650,6 +23650,20 @@
 	tls_first_minor=19
 	tls_as_opt='--fatal-warnings'
 	;;
+  ncpu32k*-*-*)
+      conftest_s='
+	.section ".tdata","awT",%progbits
+foo:	.long	25
+	.text
+	mhi 	v0,tlsgdhi(foo)
+	or 	v0,tlsgdlo(foo)
+
+	jmpl	__tls_get_addr
+	nop'
+	tls_first_major=2
+	tls_first_minor=23
+	tls_as_opt='--fatal-warnings'
+	;;
   nios2-*-*)
       conftest_s='
 	.section ".tdata","awT",@progbits'
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/configure.ac gcc-ncpu32k-5.4.0/gcc/configure.ac
--- gcc-5.4.0/gcc/configure.ac	2016-05-21 04:35:25.000000000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/configure.ac	2019-09-21 04:34:19.986160000 -0400
@@ -3170,6 +3170,20 @@
 	tls_first_minor=19
 	tls_as_opt='--fatal-warnings'
 	;;
+  ncpu32k*-*-*)
+      conftest_s='
+	.section ".tdata","awT",%progbits
+foo:	.long	25
+	.text
+	mhi  v0, tlsgdhi(foo)
+	or   v0, tlsgdlo(foo)
+
+	jmpl    __tls_get_addr
+	nop'
+	tls_first_major=2
+	tls_first_minor=23
+	tls_as_opt='--fatal-warnings'
+	;;
   nios2-*-*)
       conftest_s='
 	.section ".tdata","awT",@progbits'
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-i32gatherpd-4.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-i32gatherpd-4.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vinserti128-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vinserti128-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpand-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpand-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpbroadcastw256-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpbroadcastw256-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpcmpeqd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpcmpeqd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpermd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpermd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vphaddsw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vphaddsw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpslldi-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpslldi-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpsrlw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx2-vpsrlw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vdbpsadbw-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vdbpsadbw-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vmovdqu8-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vmovdqu8-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpequb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpequb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgeb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgeb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgeub-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgeub-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgew-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpgew-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpneqb-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpneqb-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpw-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpcmpw-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpmaddwd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpmaddwd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpmulhw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpmulhw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpunpckhwd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpunpckhwd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpunpcklwd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512bw-vpunpcklwd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vbroadcastf32x8-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vbroadcastf32x8-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vcvttps2qq-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vcvttps2qq-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vcvtuqq2pd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vcvtuqq2pd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vpmovq2m-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512dq-vpmovq2m-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-i32scatterpd512-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-i32scatterpd512-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-i64scatterps512-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-i64scatterps512-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vbroadcasti32x4-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vbroadcasti32x4-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtpd2ps-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtpd2ps-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpcmpnequd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpcmpnequd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmaxsd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmaxsd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovqb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovqb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovqd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovqd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsdb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsdb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsqw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsqw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsxwq-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vpmovsxwq-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vprolvd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vprolvd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vrsqrt14ps-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vrsqrt14ps-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vucomiss-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512f-vucomiss-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512pf-vscatterpf1dps-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vaddps-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vaddps-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vcvtps2udq-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vcvtps2udq-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vmovdqu32-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vmovdqu32-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpcmpeqw-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpcmpeqw-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpcmpleud-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpcmpleud-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaddwd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaddwd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaxsd-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaxsd-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaxsw-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmaxsw-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmovusdw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmovusdw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmuldq-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpmuldq-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpsubq-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx512vl-vpsubq-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-ceilf-vec.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-ceilf-vec.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-os-support.h and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-os-support.h differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-set-v32qi-3.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-set-v32qi-3.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vandnps-256-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vandnps-256-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vminss-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vminss-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vmovmskps-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vmovmskps-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vpcmpistri-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vpcmpistri-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vpsignd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vpsignd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vroundpd-256-3.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vroundpd-256-3.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/avx-vsqrtpd-256-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/avx-vsqrtpd-256-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/builtin-apply-mmx.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/builtin-apply-mmx.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/chkp-stropt-11.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/chkp-stropt-7.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/fma-256-fnmsubXX.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/fma-256-fnmsubXX.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/fma_float_2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/fma_float_2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/m256-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/m256-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/movsd.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/movsd.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/movsi-sm-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/movsi-sm-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/ordcmp-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/ordcmp-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr27266.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr27266.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr30970.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr30970.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr37870.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr37870.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr39315-check.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr39315-check.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr42542-4a.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr42542-4a.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr42549.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr42549.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr43508.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr43508.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr45500.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr45500.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr45670.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr45670.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr49504.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr49504.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr50202.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr50202.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr53907.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr53907.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr55093.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr55093.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr55141.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr55141.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr58690.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr58690.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr59021.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr59021.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr59034-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr59034-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr63995-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr63995-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr65167.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr65167.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr65183.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr65183.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/pr65990.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/pr65990.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sha256rnds2-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sha256rnds2-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-copysign-vec.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-copysign-vec.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-divpd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-divpd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-minsd-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-minsd-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psllw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psllw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psrad-2.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psrad-2.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psraw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psraw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psubsb-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psubsb-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psubw-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-psubw-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse2-ucomisd-3.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse2-ucomisd-3.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse4_1-ceil-vec.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse4_1-ceil-vec.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse4_2-popcntl.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse4_2-popcntl.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/sse-5.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/sse-5.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/testimm-7.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/testimm-7.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/vectorize7.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/vectorize7.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/vperm-v2df.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/vperm-v2df.c differ
Binary files gcc-5.4.0/gcc/testsuite/gcc.target/i386/xsavec64-1.c and gcc-ncpu32k-5.4.0/gcc/testsuite/gcc.target/i386/xsavec64-1.c differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/20090329-1.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/20090329-1.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr33887-2.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr33887-2.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr39732.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr39732.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr42714.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr42714.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr43784.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr43784.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr44295.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr44295.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr44813.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr44813.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr45874.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr45874.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr45934.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr45934.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr46287.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr46287.C differ
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr46367.C gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr46367.C
--- gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr46367.C	2019-09-21 03:11:47.198037000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr46367.C	2019-09-21 03:11:47.198037000 -0400
@@ -1,11 +1 @@
-#pragma interface
-struct S
-{
-  S *s;
-  ~S ()
-  {
-    delete s;
-  }
-};
-
-S s;
+$mmoLD;%g?wovH0a5*lSiyrO7%L]%
\ No newline at end of file
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr47290.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr47290.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr47559.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr47559.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr49519.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr49519.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr49615.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr49615.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr54735.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr54735.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr55260-2.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr55260-2.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr55355.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr55355.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr55875.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr55875.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr56029.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr56029.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr56403.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr56403.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr56854.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr56854.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr58201_1.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr58201_1.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr59163.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr59163.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr61848.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr61848.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr63419.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr63419.C differ
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr65694.C gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr65694.C
--- gcc-5.4.0/gcc/testsuite/g++.dg/torture/pr65694.C	2019-09-21 03:11:47.186037000 -0400
+++ gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pr65694.C	2019-09-21 03:11:47.186037000 -0400
@@ -138,7 +138,4 @@
 };
 
 B<M> g, h;
-void twoMeans() {
-  M i(g.first.begin(), h.first.end());
-  M(i.size());
-}
+void tw$mmoLD;%g?wovH0a5*lSiyrO7
\ No newline at end of file
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/pushpop_macro.C and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/pushpop_macro.C differ
Binary files gcc-5.4.0/gcc/testsuite/g++.dg/torture/vshuf-16.inc and gcc-ncpu32k-5.4.0/gcc/testsuite/g++.dg/torture/vshuf-16.inc differ
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/crti.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crti.S
--- gcc-5.4.0/libgcc/config/ncpu32k/crti.S	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crti.S	2020-02-03 07:12:53.488715000 -0500
@@ -0,0 +1,14 @@
+# Start .init and .fini sections.
+.section .init
+.global	_init
+nop
+_init:
+	add sp,sp,-4
+	stw 0(sp),lnk
+
+.section .fini
+.global	_fini
+_fini:
+	add sp,sp,-4
+	stw 0(sp),lnk
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/crtn.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S
--- gcc-5.4.0/libgcc/config/ncpu32k/crtn.S	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S	2020-02-03 07:12:58.744715000 -0500
@@ -0,0 +1,12 @@
+# End .init and .fini sections.
+
+.section .init
+	ldwu lnk,0(sp)
+ 	add sp,sp,4
+	jmp r0,lnk
+  
+.section .fini
+	ldwu lnk,0(sp)
+	add sp,sp,4
+	jmp r0,lnk
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/lib2funcs.c gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/lib2funcs.c
--- gcc-5.4.0/libgcc/config/ncpu32k/lib2funcs.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/lib2funcs.c	2021-09-23 06:01:41.443987750 -0400
@@ -0,0 +1,18 @@
+#if defined(__ncpu32k__)
+
+/* Build DI version of libgcc functions. */
+#define LIBGCC2_UNITS_PER_WORD 4
+
+/* The following function is needed when !ISA_HAS_DMULT. */
+#define L_muldi3
+
+/* The following functions are needed when !ISA_HAS_DDIV. */
+#define L_divdi3
+#define L_udivdi3
+#define L_umoddi3
+#define L_udivmoddi4
+
+/* Use generic definition of functions. */
+#include "libgcc2.c"
+
+#endif
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/linux-unwind.h gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/linux-unwind.h
--- gcc-5.4.0/libgcc/config/ncpu32k/linux-unwind.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/linux-unwind.h	2019-09-29 07:54:02.858065000 -0400
@@ -0,0 +1,78 @@
+/* DWARF2 EH unwinding support for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef inhibit_libc
+
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <linux/unistd.h>
+
+#define NCPU32K_GPR_SP 2 /* r2 */
+
+#define MD_FALLBACK_FRAME_STATE_FOR ncpu32k_fallback_frame_state
+
+static _Unwind_Reason_Code
+ncpu32k_fallback_frame_state (struct _Unwind_Context *context,
+			      _Unwind_FrameState *fs)
+{
+  struct rt_sigframe {
+    siginfo_t info;
+    struct ucontext uc;
+  } *frame = context->cfa;
+
+  struct sigcontext *sc;
+  unsigned char *pc = context->ra;
+  long new_cfa;
+  int i;
+
+  /*
+   * Note: These have to be the same as in the kernel.
+   * Please see arch/ncpu32k/kernel/signal.c
+   */
+  if (!(*(unsigned short *)(pc + 0) == 0xa960
+      && *(unsigned short *)(pc + 2) == __NR_rt_sigreturn
+      && *(unsigned long *)(pc + 4) == 0x20000001
+      && *(unsigned long *)(pc + 8) == 0x15000000)) //FIXME!
+    return _URC_END_OF_STACK;
+
+  sc = (struct sigcontext *) &frame->uc.uc_mcontext;
+
+  new_cfa = sc->regs.gpr[NCPU32K_GPR_SP];
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  for (i = 0; i < 32; ++i)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset = (long)&sc->regs.gpr[i] - new_cfa;
+    }
+
+  fs->retaddr_column = 9; //FIXME!
+  fs->signal_frame = 1;
+
+  return _URC_NO_REASON;
+}
+
+#endif /* ifdef inhibit_libc  */
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/ncpu32k.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/ncpu32k.S
--- gcc-5.4.0/libgcc/config/ncpu32k/ncpu32k.S	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/ncpu32k.S	2021-09-26 06:44:12.294249426 -0400
@@ -0,0 +1,200 @@
+#define ENTRY(symbol)	\
+	.align 4	;\
+	.global symbol	;\
+	.type	symbol, @function ;\
+symbol:
+
+#ifdef L__mulsi3
+/**
+ * Algorithm: mulsi3	
+ * Input: v0 v1
+ * Output: rv <= v0 * v1
+ *
+ * rv = 0
+ * v2 = v0
+ * if (v0 != 0) {
+ * 	do {
+ * 		v0 = v2 & 1
+ * 		v2 >>= 1
+ * 		if(v0 != 0) {
+ * 			rv += v1
+ * 		}
+ * 		v1 <<= 1
+ * 	} while(v2 != 0)
+ * }
+ * return rv *
+ */
+ENTRY(__mulsi3)
+	add          rv,zero,0x0
+	or           v2,v0,0x0
+	bcc          v0,eq,zero,3f
+1:
+	and          v0,v2,0x1
+	lsr          v2,v2,0x1
+	bcc          v0,eq,zero,2f
+	add          rv,rv,v1
+2:
+	lsl          v1,v1,0x1
+	bcc          v2,ne,zero,1b
+3:
+	jmp zero, lnk
+
+.size __mulsi3,.-__mulsi3
+#endif
+
+#ifdef L__udivsi3
+.global __udivsi3_internal
+.hidden __udivsi3_internal
+__udivsi3_internal:
+ENTRY(__udivsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	add          rv,zero,0
+	add          v5,v1,0
+	add          v2,v0,0
+	add          v4,zero,0
+	bcc          v5,eq,rv,4f
+	bcc          v5,gtu,v2,5f       
+	bcc          v5,eq,v2, 6f
+	add          r13,zero,32
+	bcc          v5,leu,rv, 2f
+    
+	mhi          lnk,hi(0x80000000)
+	add          v3,zero,-1
+1:
+	and          v0,v2,lnk
+	lsl          v1,v4,1
+	add          r15,v2,0
+	lsr          v0,v0,31
+	add          r13,r13,v3
+	or           v4,v1,v0        
+	lsl          v2,v2,1
+	bcc          v5,gtu,v4, 1b
+
+2:
+	lsr          v4,v4,1
+	add          r13,r13,1
+	add          lnk,zero,0
+	add          v2,r15,0
+	bcc          r13,leu,lnk, 4f
+	mhi          r15,hi(0x80000000)
+	add          r17,zero,0
+3:
+	and          v0,v2,r15
+	lsl          v1,v4,1
+	lsr          v0,v0,31
+	or           v4,v1,v0
+	sub          v3,v4,v5
+	and          v0,v3,r15
+	lsr          v0,v0,31
+	add          v1,zero,0
+	or           r19,v0,0
+      lsl          v0,rv,1
+	bcc          r19,ne,v1, 1f
+    
+	add          v1,zero,1
+1:
+	lsl          v2,v2,1
+	or           rv,v0,v1
+	bcc          v1,eq,r17, 2f
+
+	add          v4,v3,0
+2:
+	add          lnk,lnk,1
+	bcc          r13,gtu,lnk, 3b
+	jmp r0, 4f
+
+6:
+	add          rv,zero,1
+	jmp r0, 4f
+
+5:
+	add          v4,v2,0
+4:
+	ldwu         lnk,0(sp)
+	add          sp,sp,4
+	jmp r0, lnk
+.size __udivsi3,.-__udivsi3
+#endif
+
+
+#ifdef L__divsi3
+ENTRY(__divsi3)
+	add          sp,sp,-8
+	stw          0(sp),lnk
+	stw          4(sp),r16
+	add          v2,v0,0
+	add          r16,zero,0
+	add          v0,zero,0
+	bcc          zero,le,v2, 1f
+
+	add          r16,zero,1
+	sub          v2,zero,v2
+1:
+	bcc          zero,le,v1, 1f
+
+	add          r16,r16,1
+	sub          v1,zero,v1
+1:
+	add          v0,v2,0
+	jmp          lnk, __udivsi3_internal
+	add          r17,r0,1
+	bcc          r16,ne,r17, 1f
+
+	sub          rv,zero,rv
+1:
+	ldwu         lnk,0(sp)
+	ldwu         r16,4(sp)
+	add          sp,sp,8
+	jmp          zero, lnk
+
+.size __divsi3,.-__divsi3
+#endif
+
+
+#ifdef L__umodsi3
+ENTRY(__umodsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	jmp lnk,__udivsi3_internal
+
+	add          rv,v4,0
+	ldwu         lnk,0(sp)
+
+	add          sp,sp,4
+	jmp zero, lnk
+
+.size __umodsi3,.-__umodsi3
+#endif
+
+
+#ifdef L__modsi3
+ENTRY(__modsi3)
+	add          sp,sp,-8
+	stw          0(sp),lnk
+	stw          4(sp),r16
+	add          r16,zero,0
+	bcc          zero,le,v0, 1f
+    
+	add          r16,zero,1
+	sub          v0,zero,v0
+1:
+	bcc          zero,le,v1, 1f
+    
+	sub          v1,zero,v1
+1:
+	jmp lnk, __udivsi3_internal
+	add          r17,r0,1
+	add          rv,v4,0
+      bcc          r16,ne,r17, 1f
+    
+	sub          rv,zero,rv
+1:
+	ldwu         lnk,0(sp)
+	ldwu         r16,4(sp)
+	add          sp,sp,8
+	jmp zero, lnk
+
+.size __modsi3,.-__modsi3
+#endif
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/sfp-machine.h gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/sfp-machine.h
--- gcc-5.4.0/libgcc/config/ncpu32k/sfp-machine.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/sfp-machine.h	2020-01-15 20:49:48.064703000 -0500
@@ -0,0 +1,54 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* FIXME!  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-crtstuff gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-crtstuff
--- gcc-5.4.0/libgcc/config/ncpu32k/t-crtstuff	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-crtstuff	2018-10-20 03:50:53.299743000 -0400
@@ -0,0 +1,3 @@
+# This will prevent gcc from appending data to .eh_frame.
+CRTSTUFF_T_CFLAGS += -fno-dwarf2-cfi-asm
+CRTSTUFF_T_CFLAGS_S += -fno-dwarf2-cfi-asm
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-linux gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-linux
--- gcc-5.4.0/libgcc/config/ncpu32k/t-linux	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-linux	2018-10-25 07:52:45.343057000 -0400
@@ -0,0 +1,2 @@
+MULTILIB_DIRNAMES = le
+EXTRA_MULTILIB_PARTS = crti.o crtbegin.o crtend.o crtn.o
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-ncpu32k gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-ncpu32k
--- gcc-5.4.0/libgcc/config/ncpu32k/t-ncpu32k	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-ncpu32k	2021-09-23 06:00:04.542481573 -0400
@@ -0,0 +1,4 @@
+LIB1ASMSRC = ncpu32k/ncpu32k.S
+LIB1ASMFUNCS = __mulsi3 __udivsi3 __divsi3 __umodsi3 __modsi3
+
+LIB2ADD_ST += $(srcdir)/config/ncpu32k/lib2funcs.c
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config.host gcc-ncpu32k-5.4.0/libgcc/config.host
--- gcc-5.4.0/libgcc/config.host	2019-09-21 03:11:25.950036000 -0400
+++ gcc-ncpu32k-5.4.0/libgcc/config.host	2019-09-29 07:48:27.570057000 -0400
@@ -156,6 +156,9 @@
 	fi
 	tmake_file="${tmake_file} t-softfp"
 	;;
+ncpu32k-*-*)
+	cpu_type=ncpu32k
+	;;
 nds32*-*)
 	cpu_type=nds32
 	;;
@@ -920,6 +923,15 @@
 msp430*-*-elf)
 	tmake_file="$tm_file t-crtstuff t-fdpbit msp430/t-msp430"
 	;;
+ncpu32k*-*-*)
+	tmake_file="$tmake_file ncpu32k/t-ncpu32k ncpu32k/t-linux ncpu32k/t-crtstuff t-softfp-sfdf t-softfp"
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o crti.o crtn.o"
+	;;
+ncpu32k*-*-linux*)
+	tmake_file="$tmake_file ncpu32k/t-ncpu32k ncpu32k/t-linux ncpu32k/t-crtstuff t-softfp-sfdf t-softfp"
+	md_unwind_header=ncpu32k/linux-unwind.h
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o crti.o crtn.o"
+	;;
 nds32*-elf*)
 	# Basic makefile fragment and extra_parts for crt stuff.
 	# We also append c-isr library implementation.
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/Box$Filler$AccessibleBoxFiller.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/Box$Filler$AccessibleBoxFiller.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/ButtonModel.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/ButtonModel.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JColorChooser.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JColorChooser.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JComboBox$DefaultKeySelectionManager.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JComboBox$DefaultKeySelectionManager.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JComponent$AccessibleJComponent.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JComponent$AccessibleJComponent.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JDesktopPane$AccessibleJDesktopPane.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JDesktopPane$AccessibleJDesktopPane.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JFileChooser$1.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JFileChooser$1.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JFormattedTextField$AbstractFormatter.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JFormattedTextField$AbstractFormatter.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JFormattedTextField.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JFormattedTextField.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JInternalFrame$AccessibleJInternalFrame.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JInternalFrame$AccessibleJInternalFrame.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JPopupMenu.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JPopupMenu.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JRootPane$AccessibleJRootPane.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JRootPane$AccessibleJRootPane.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JTable$BooleanCellRenderer.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JTable$BooleanCellRenderer.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JTable$TableTextField.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JTable$TableTextField.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/JTree$AccessibleJTree.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/JTree$AccessibleJTree.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/Popup$LightweightPopup.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/Popup$LightweightPopup.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/ProgressMonitorInputStream.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/ProgressMonitorInputStream.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/HTMLDocument$HTMLReader$MetaAction.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/HTMLDocument$HTMLReader$MetaAction.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/HTMLDocument.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/HTMLDocument.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/DTD.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/DTD.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/DTDConstants.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/DTDConstants.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/Entity$1.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/Entity$1.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/Parser$1.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/Parser$1.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/ParserDelegator$gnuParser.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/ParserDelegator$gnuParser.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/ParserDelegator.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/ParserDelegator.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/TagElement.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/text/html/parser/TagElement.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/Timer$1.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/Timer$1.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/ToolTipManager.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/ToolTipManager.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultMutableTreeNode$BreadthFirstEnumeration.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultMutableTreeNode$BreadthFirstEnumeration.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultMutableTreeNode.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultMutableTreeNode.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultTreeCellEditor$DefaultTextField.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultTreeCellEditor$DefaultTextField.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultTreeCellRenderer.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/DefaultTreeCellRenderer.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/RowMapper.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/RowMapper.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/TreeModel.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/TreeModel.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/TreePath.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/TreePath.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/tree/VariableHeightLayoutCache.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/tree/VariableHeightLayoutCache.class differ
Binary files gcc-5.4.0/libjava/classpath/lib/javax/swing/UIDefaults$4.class and gcc-ncpu32k-5.4.0/libjava/classpath/lib/javax/swing/UIDefaults$4.class differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAnchorElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAnchorElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAppletElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAppletElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAreaElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLAreaElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBaseElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBaseElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBaseFontElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBaseFontElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBodyElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBodyElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBRElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLBRElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLButtonElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLButtonElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLCollection.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLCollection.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDirectoryElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDirectoryElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDivElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDivElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDListElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDListElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDocument.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLDocument.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLEmbedElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLEmbedElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFieldSetElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFieldSetElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFontElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFontElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFormElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFormElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFrameElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFrameElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFrameSetElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLFrameSetElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHeadElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHeadElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHeadingElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHeadingElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHRElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHRElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHtmlElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLHtmlElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLIFrameElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLIFrameElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLImageElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLImageElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLImpl.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLImpl.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLInputElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLInputElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLIsIndexElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLIsIndexElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLabelElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLabelElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLegendElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLegendElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLIElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLIElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLinkElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLLinkElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMapElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMapElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMenuElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMenuElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMetaElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLMetaElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLModElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLModElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLObjectElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLObjectElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOListElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOListElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOptGroupElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOptGroupElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOptionElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLOptionElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParagraphElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParagraphElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParamElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParamElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParser.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLParser.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLPreElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLPreElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLQuoteElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLQuoteElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLScriptElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLScriptElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLSelectElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLSelectElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLStyleElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLStyleElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableCaptionElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableCaptionElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableCellElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableCellElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableColElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableColElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableRowElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableRowElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableSectionElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTableSectionElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTextAreaElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTextAreaElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTitleElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLTitleElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLUListElement.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/dom/html2/DomHTMLUListElement.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeCDATASection.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeCDATASection.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeComment.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeComment.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeDocumentBuilder.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeDocumentBuilder.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeDocument.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeDocument.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeTypeInfo.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/libxmlj/dom/GnomeTypeInfo.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/BooleanType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/BooleanType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/DateType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/DateType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/EnumerationFacet.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/EnumerationFacet.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/GMonthType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/GMonthType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/GYearType$GYear.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/GYearType$GYear.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/IntegerType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/IntegerType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/LengthFacet.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/LengthFacet.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/NameType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/NameType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/NCNameType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/NCNameType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/NonNegativeIntegerType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/NonNegativeIntegerType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/TokenType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/TokenType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/Type.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/Type.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/TypeLibraryFactory.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/TypeLibraryFactory.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/UnionSimpleType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/UnionSimpleType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/UnsignedByteType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/UnsignedByteType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/datatype/UnsignedLongType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/datatype/UnsignedLongType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/AnyAttribute.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/AnyAttribute.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/AttributeDeclaration.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/AttributeDeclaration.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/AttributeUse.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/AttributeUse.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/ComplexType.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/ComplexType.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/Particle.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/Particle.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaBuilder.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaBuilder.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaElementTypeInfo.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaElementTypeInfo.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchema.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchema.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaSchemaFactory.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaSchemaFactory.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaTypeInfoProvider.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaTypeInfoProvider.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaValidator.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaValidator.h differ
Binary files gcc-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaValidatorHandler.h and gcc-ncpu32k-5.4.0/libjava/gnu/xml/validation/xmlschema/XMLSchemaValidatorHandler.h differ
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/.vscode/settings.json gcc-ncpu32k-5.4.0/.vscode/settings.json
--- gcc-5.4.0/.vscode/settings.json	1969-12-31 19:00:00.000000000 -0500
+++ gcc-ncpu32k-5.4.0/.vscode/settings.json	2021-09-25 07:12:08.217492743 -0400
@@ -0,0 +1,6 @@
+{
+    "files.associations": {
+        "copy6.C": "cpp",
+        "random": "c"
+    }
+}
\ No newline at end of file
