diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/config.guess gcc-ncpu32k-5.4.0/config.guess
--- gcc-5.4.0/config.guess	2019-09-21 15:11:11.122036398 +0800
+++ gcc-ncpu32k-5.4.0/config.guess	2019-09-29 19:39:49.894044375 +0800
@@ -1370,6 +1370,9 @@
     x86_64:VMkernel:*:*)
 	echo ${UNAME_MACHINE}-unknown-esx
 	exit ;;
+    ncpu32k*:Linux:*:*)
+	echo ncpu32k-unknown-linux-${LIBC}
+	exit ;;
 esac
 
 cat >&2 <<EOF
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/config.sub gcc-ncpu32k-5.4.0/config.sub
--- gcc-5.4.0/config.sub	2019-09-21 15:11:25.338036750 +0800
+++ gcc-ncpu32k-5.4.0/config.sub	2019-09-29 19:41:41.878047151 +0800
@@ -295,6 +295,7 @@
 	| moxie \
 	| mt \
 	| msp430 \
+	| ncpu32k \
 	| nds32 | nds32le | nds32be \
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
@@ -419,6 +420,7 @@
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
+	| ncpu32k-* \
 	| nds32-* | nds32le-* | nds32be-* \
 	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/configure gcc-ncpu32k-5.4.0/configure
--- gcc-5.4.0/configure	2015-05-04 01:29:57.000000000 +0800
+++ gcc-ncpu32k-5.4.0/configure	2019-09-29 19:43:08.822049307 +0800
@@ -3892,6 +3892,9 @@
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  ncpu32k*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
   nds32*-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/configure.ac gcc-ncpu32k-5.4.0/configure.ac
--- gcc-5.4.0/configure.ac	2019-09-21 15:11:03.186036201 +0800
+++ gcc-ncpu32k-5.4.0/configure.ac	2019-09-29 19:42:32.558048408 +0800
@@ -1239,6 +1239,9 @@
   mips*-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  ncpu32k*-*-*)
+    noconfigdirs="$noconfigdirs gdb"
+    ;;
   nds32*-*-*)
     noconfigdirs="$noconfigdirs gdb"
     ;;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c gcc-ncpu32k-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c
--- gcc-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/common/config/ncpu32k/ncpu32k-common.c	2019-09-29 20:23:24.562109207 +0800
@@ -0,0 +1,58 @@
+/* Common hooks for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "common/common-target.h"
+#include "common/common-target-def.h"
+#include "opts.h"
+#include "flags.h"
+
+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
+static const struct default_options ncpu32k_option_optimization_table[] =
+  {
+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+    { OPT_LEVELS_NONE, 0, NULL, 0 }
+  };
+
+/* Implement TARGET_EXCEPT_UNWIND_INFO.  */
+static enum unwind_info_type
+ncpu32k_except_unwind_info (struct gcc_options *opts)
+{
+    /* Honor the --enable-sjlj-exceptions configure switch.  */
+#ifdef CONFIG_SJLJ_EXCEPTIONS
+    if (CONFIG_SJLJ_EXCEPTIONS)
+          return UI_SJLJ;
+#endif
+
+    if (DWARF2_UNWIND_INFO)
+      return UI_DWARF2;
+
+    return UI_SJLJ;
+}
+
+#undef  TARGET_EXCEPT_UNWIND_INFO
+#define TARGET_EXCEPT_UNWIND_INFO  ncpu32k_except_unwind_info
+
+#undef TARGET_OPTION_OPTIMIZATION_TABLE
+#define TARGET_OPTION_OPTIMIZATION_TABLE ncpu32k_option_optimization_table
+
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/constraints.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/constraints.md
--- gcc-5.4.0/gcc/config/ncpu32k/constraints.md	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/constraints.md	2020-02-03 18:39:58.653029097 +0800
@@ -0,0 +1,44 @@
+;; Constraint definitions for nano-cpu32k
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_constraint "I"
+  "Signed 14-bit Integer"
+  (and (match_code "const_int")
+       (match_test "ival >= -(1 << 13) && ival <= (1 << 13)-1")))
+
+(define_constraint "J"
+  "Zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "K"
+  "Unsigned 14bit Integer"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= (1 << 14)-1")))
+
+(define_constraint "L"
+  "Shift count (32-bit wordsize)"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 31")))
+
+(define_constraint "M"
+  "32-bit Integer that is aligned at LSB-14bit boundary."
+  (and (match_code "const_int")
+       (match_test "(ival & 0x3fff) == 0")))
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/elf.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/elf.h
--- gcc-5.4.0/gcc/config/ncpu32k/elf.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/elf.h	2019-09-21 16:50:36.618184315 +0800
@@ -0,0 +1,29 @@
+/* Definitions for nano-cpu32k using ELF
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Use ELF */
+#undef  OBJECT_FORMAT_ELF
+#define OBJECT_FORMAT_ELF
+
+/* debug info support is controlled by tm.h header files we include:
+   dbxelf.h enables optional stabs debug info.
+   elfos.h sets PREFERRED_DEBUGGING_TYPE to DWARF2_DEBUG .  */
+
+#define DRIVER_SELF_SPECS "%{!mno-newlib:-mnewlib}"
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/linux-elf.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-elf.h
--- gcc-5.4.0/gcc/config/ncpu32k/linux-elf.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-elf.h	2019-09-21 16:50:44.766184517 +0800
@@ -0,0 +1,96 @@
+/* Definitions for nano-cpu32k running Linux-based GNU systems using ELF
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* elfos.h should have already been included.  Now just override
+   any conflicting definitions and add any extras.  */
+
+/* Do not assume anything about header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* This is how we tell the assembler that two symbols have the same value.  */
+#define ASM_OUTPUT_DEF(FILE, NAME1, NAME2) \
+  do                                       \
+    {                                      \
+      assemble_name (FILE, NAME1);         \
+      fputs (" = ", FILE);                 \
+      assemble_name (FILE, NAME2);         \
+      fputc ('\n', FILE);                  \
+    }                                      \
+    while (0)
+
+
+#if 0
+/* Node: Label Output */
+
+#define SET_ASM_OP      "\t.set\t"
+
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)  \
+  (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0))
+
+#define ASM_WEAKEN_LABEL(FILE, NAME)    \
+  do                                    \
+    {                                   \
+      fputs ("\t.weak\t", (FILE));      \
+      assemble_name ((FILE), (NAME));   \
+      fputc ('\n', (FILE));             \
+    }                                   \
+  while (0)
+
+#endif
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+#undef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS ""
+
+#define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+
+/* Define a set of Linux builtins. This is copied from linux.h. We can't
+   include the whole file for now, because that causes configure to require ld
+   to support --eh-frame-header, which it currently doesn't */
+#define LINUX_TARGET_OS_CPP_BUILTINS()				\
+    do {							\
+	builtin_define ("__gnu_linux__");			\
+	builtin_define_std ("linux");				\
+	builtin_define_std ("unix");				\
+	builtin_assert ("system=linux");			\
+	builtin_assert ("system=unix");				\
+	builtin_assert ("system=posix");			\
+    } while (0)
+
+#define TARGET_OS_CPP_BUILTINS()				\
+  do {								\
+    LINUX_TARGET_OS_CPP_BUILTINS();				\
+    if (OPTION_UCLIBC)						\
+      builtin_define ("__UCLIBC__");				\
+    /* The GNU C++ standard library requires this.  */		\
+    if (c_dialect_cxx ())					\
+      builtin_define ("_GNU_SOURCE");				\
+  } while (0)
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{mnewlib:-entry 0x100} \
+  -dynamic-linker " GNU_USER_DYNAMIC_LINKER " \
+  %{rdynamic:-export-dynamic} \
+  %{static:-static} \
+  %{shared:-shared}"
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/linux-gas.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-gas.h
--- gcc-5.4.0/gcc/config/ncpu32k/linux-gas.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/linux-gas.h	2019-09-21 16:51:53.086186212 +0800
@@ -0,0 +1,35 @@
+/* Definitions of nano-cpu32k for GNU compiler.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Unsigned chars produces much better code than signed.  */
+#undef  DEFAULT_SIGNED_CHAR
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Make gcc agree with <machine/ansi.h> */
+
+#define SIZE_TYPE "unsigned int"
+#define PTRDIFF_TYPE "int"
+#define WCHAR_TYPE "unsigned int"
+#define WCHAR_TYPE_SIZE 32
+
+
+/* Clear the instruction cache from `beg' to `end'.  This makes an
+   inline system call to SYS_cacheflush.  */
+#define CLEAR_INSN_CACHE(BEG, END) /* Do something here !!! */
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.c gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.c
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.c	2020-02-03 16:22:59.777491487 +0800
@@ -0,0 +1,2326 @@
+/* Subroutines for insn-output.c for GNU compiler.  nano-cpu32k version.
+   Copyright (C) 2019 Free Software Foundation, Inc
+   largely based on ../or1k/or1k.c
+   
+   This file is part of GNU CC.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+  
+   This program is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+  
+   You should have received a copy of the GNU General Public License along
+   with this program.  If not, see <http://www.gnu.org/licenses/>. */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "hash-set.h"
+#include "inchash.h"
+#include "symtab.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "varasm.h"
+#include "obstack.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "function.h"
+#include "explow.h"
+#include "emit-rtl.h"
+#include "expr.h"
+#include "toplev.h"
+#include "recog.h"
+#include "ggc.h"
+#include "except.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "debug.h"
+#include "langhooks.h"
+#include "predict.h"
+#include "basic-block.h"
+#include "df.h"
+#include "optabs.h"
+#include "dwarf2.h"
+#include "ansidecl.h"
+#include "builtins.h"
+
+#define CONST_INT_I_MAX (1 << 13)-1
+#define CONST_INT_I_MIN -(1 << 13)
+
+/* Number of lnk register */
+#define NCPU32K_GPR_LNK 1
+/* Number of rv register */
+#define NCPU32K_GPR_RV 10
+
+/* Construct a mhi instruction for the given reg and value */
+#define NCPU32K_MHI(rd, imm)						\
+  (0x27 | ((rd) << 6) | ((imm) << 12))
+
+/* Construct a or.i instruction for the given two regs and value */
+#define NCPU32K_OR_I(rd, rs1, imm)					\
+  (0x03 | ((rd) << 6) | ((rs1) << 12) | ((imm) << 18))
+
+/* Construct a ldw instruction for the given two registers and offset */
+#define NCPU32K_LDWU(rd, rs1, imm)					\
+  (0x10 | ((rd) << 6) | ((rs1) << 12) | ((imm) << 18))
+
+/* Construct a jmp instruction for the given register */
+#define NCPU32K_JMP(rs1)						\
+  (0x0a | (NCPU32K_GPR_LNK << 6) | ((rs1) << 12))
+
+#define NCPU32K_NOP							\
+  (0x00)
+
+
+/*!Stack layout we use for pushing and poping saved registers */
+static struct
+{
+  bool save_lr_p;
+  int lr_save_offset;
+  bool save_fp_p;
+  int fp_save_offset;
+  int gpr_size;
+  int gpr_offset;
+  int total_size;
+  int vars_size;
+  int args_size;
+  int gpr_frame;
+  int late_frame;
+  HOST_WIDE_INT mask;
+}  frame_info;
+
+
+/*****************************************************************************/
+/* Utility functions */
+/*****************************************************************************/
+
+/**
+ * Must the current function save a register?
+ *
+ * @param[in] regno  The register to consider.
+ * @return  Non-zero (TRUE) if current function must save "regno", zero
+ *          (FALSE) otherwise.
+ */
+static bool
+ncpu32k_save_reg_p (int regno)
+{
+  /* No need to save the faked cc0 register.  */
+  if (regno == NCPU32K_CC_REG)
+    return false;
+
+  /* Check call-saved registers.  */
+  if (df_regs_ever_live_p(regno) && !call_used_regs[regno])
+    return true;
+
+  /* We need to save the old frame pointer before setting up a new
+     one.  */
+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)
+    return true;
+
+  /* Save the stack pointer for DWARF2 for now.
+   * AFAIK, DWARF should be able to unwind using only the current stack
+   * register and the CFA offset, but I never got that to work. */
+  if (regno == STACK_POINTER_REGNUM && !frame_pointer_needed)
+    return true;
+
+  /* We need to save the incoming return address if it is ever clobbered
+     within the function.  */
+  if (regno == LINK_REGNUM
+      && (df_regs_ever_live_p(regno) || crtl->uses_pic_offset_table
+          || cfun->machine->force_lr_save))
+    return true;
+
+  if(crtl->calls_eh_return)
+    {
+      unsigned int i;
+      for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; i++)
+        {
+          if ((unsigned int)regno == EH_RETURN_DATA_REGNO (i))
+            return true;
+        }
+    }
+
+  return false;
+
+}
+
+bool
+ncpu32k_save_reg_p_cached (int regno)
+{
+  return (frame_info.mask & ((HOST_WIDE_INT) 1 << regno)) != 0;
+}
+
+/**
+ * Compute full frame size and layout.
+ * Store information in "frame_info".
+ *
+ * @param[in] size  The size of the function's local variables.
+ * @return  Total size of stack frame.
+ */
+static HOST_WIDE_INT
+ncpu32k_compute_frame_size (HOST_WIDE_INT size)
+{
+  HOST_WIDE_INT args_size;
+  HOST_WIDE_INT vars_size;
+  HOST_WIDE_INT stack_offset;
+  HOST_WIDE_INT save_size;
+  bool interrupt_p = false;
+  int regno;
+
+  args_size = crtl->outgoing_args_size;
+  vars_size = NCPU32K_ALIGN (size, 4);
+
+  frame_info.args_size = args_size;
+  frame_info.vars_size = vars_size;
+  frame_info.gpr_frame = interrupt_p ? ncpu32k_redzone : 0;
+
+  /* If the function has local variables, we're committed to
+     allocating it anyway.  Otherwise reclaim it here.  */
+  /* FIXME: Verify this.  Got if from the MIPS port.  */
+  if (vars_size == 0 && crtl->is_leaf)
+    args_size = 0;
+
+  stack_offset = 0;
+
+  /* Save link register right at the bottom.  */
+  if (ncpu32k_save_reg_p (LINK_REGNUM))
+    {
+      stack_offset = stack_offset - UNITS_PER_WORD;
+      frame_info.lr_save_offset = stack_offset;
+      frame_info.save_lr_p = true;
+    }
+  else
+    frame_info.save_lr_p = false;
+
+  /* HACK: In PIC mode we need to save the PIC reg and the link reg in
+     in case the function is doing references through the got or plt,
+     but this information is not necessarily available when the initial
+     elimination offset is calculated, so we always reserve the space even
+     if it is not used... */
+  if (!frame_info.save_lr_p && flag_pic)
+    stack_offset = stack_offset - UNITS_PER_WORD;
+
+  /* Save frame pointer right after possible link register.  */
+  if (frame_pointer_needed)
+    {
+      stack_offset = stack_offset - UNITS_PER_WORD;
+      frame_info.fp_save_offset = stack_offset;
+      frame_info.save_fp_p = true;
+    }
+  else
+    frame_info.save_fp_p = false;
+
+  frame_info.gpr_size = 0;
+  frame_info.mask = 0;
+
+  for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+    {
+      if (regno == LINK_REGNUM
+	  || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM))
+	/* These have already been saved if so needed.  */
+	continue;
+
+      if (ncpu32k_save_reg_p (regno))
+	{
+	  frame_info.gpr_size += UNITS_PER_WORD;
+	  frame_info.mask |= ((HOST_WIDE_INT) 1 << regno);
+	}
+    }
+
+  if (!ncpu32k_save_reg_p (PIC_OFFSET_TABLE_REGNUM)
+      && (crtl->uses_pic_offset_table || (flag_pic && frame_info.save_lr_p)))
+    {
+      frame_info.gpr_size += UNITS_PER_WORD;
+      frame_info.mask |= ((HOST_WIDE_INT) 1 << PIC_OFFSET_TABLE_REGNUM);
+    }
+  else if (flag_pic && !ncpu32k_save_reg_p (PIC_OFFSET_TABLE_REGNUM))
+    frame_info.gpr_size += UNITS_PER_WORD;
+
+  save_size = (frame_info.gpr_size 
+	       + (frame_info.save_fp_p ? UNITS_PER_WORD : 0)
+	       + (frame_info.save_lr_p || flag_pic ? UNITS_PER_WORD : 0));
+  frame_info.total_size = save_size + vars_size + args_size;
+  gcc_assert (PROLOGUE_TMP != STATIC_CHAIN_REGNUM);
+  if (frame_info.total_size > CONST_INT_I_MAX && interrupt_p)
+    {
+      int n_extra
+	= (!!(~frame_info.mask && 1 << PROLOGUE_TMP)
+	   + !!(~frame_info.mask & 1 << EPILOGUE_TMP)) * UNITS_PER_WORD;
+
+      save_size += n_extra;
+      frame_info.gpr_size += n_extra;
+      frame_info.total_size += n_extra;
+      frame_info.mask |= (1 << PROLOGUE_TMP) | (1 << EPILOGUE_TMP);
+    }
+
+  stack_offset -= frame_info.gpr_size;
+  frame_info.gpr_offset = stack_offset;
+  frame_info.late_frame = frame_info.total_size;
+
+  if (save_size > ncpu32k_redzone
+      || (frame_info.gpr_frame
+	  && (frame_info.gpr_frame + frame_info.late_frame <= CONST_INT_I_MAX)))
+    {
+      if (frame_info.gpr_frame + frame_info.late_frame <= CONST_INT_I_MAX)
+	save_size = frame_info.total_size;
+      frame_info.gpr_frame += save_size;
+      frame_info.lr_save_offset += save_size;
+      frame_info.fp_save_offset += save_size;
+      frame_info.gpr_offset += save_size;
+      frame_info.late_frame -= save_size;
+      /* FIXME: check in TARGET_OVERRIDE_OPTIONS for invalid ncpu32k_redzone.  */
+      gcc_assert (frame_info.gpr_frame <= CONST_INT_I_MAX);
+      gcc_assert ((frame_info.gpr_frame & 3) == 0);
+    }
+
+  return frame_info.total_size;
+
+}
+
+
+/**
+ * Emit a frame related insn.
+ *
+ * Same as emit_insn, but sets RTX_FRAME_RELATED_P to one. Getting this right
+ * will matter for DWARF 2 output, if prologues are handled via the "prologue"
+ * pattern rather than target hooks.
+ *
+ * @param[in] insn  The insn to emit.
+ * @return  The RTX for the emitted insn.
+ */
+static rtx
+emit_frame_insn (rtx insn)
+{
+  insn = emit_insn (insn);
+  RTX_FRAME_RELATED_P (insn) = 1;
+  return (insn);
+
+}
+
+
+/**
+ * Generate a RTX for the indexed memory address based on stack_pointer_rtx
+ * and a displacement
+ *
+ * @param[in] disp  The displacement
+ * @return  The RTX for the generated address.
+ */
+static rtx
+stack_disp_mem (HOST_WIDE_INT disp)
+{
+  return gen_frame_mem (Pmode, plus_constant (Pmode, stack_pointer_rtx, disp));
+}
+
+enum machine_mode
+ncpu32k_select_cc_mode (enum rtx_code op)
+{
+  switch (op)
+    {
+    case EQ:  return CCEQmode;
+    case NE:  return CCNEmode;
+    case GEU: return CCGEUmode;
+    case GTU: return CCGTUmode;
+    case LTU: return CCLTUmode;
+    case LEU: return CCLEUmode;
+    case GE:  return CCGEmode;
+    case LT:  return CCLTmode;
+    case GT:  return CCGTmode;
+    case LE:  return CCLEmode;
+    default:  gcc_unreachable ();
+    }
+}
+
+static enum machine_mode
+ncpu32k_map_cc_mode (enum machine_mode mode)
+{
+  switch (mode)
+    {
+    case CCEQmode:  return CCEQmode;
+    case CCNEmode:  return CCEQmode;  /* reversal eq */
+  
+    case CCGTmode:
+    case CCLEmode:  return CCGTmode;  /* reversal gt */
+    
+    case CCLTmode:
+    case CCGEmode:  return CCLTmode;  /* reversal lt */
+  
+    case CCGTUmode:
+    case CCLEUmode: return CCGTUmode; /* reversal gtu */
+    
+    case CCLTUmode:
+    case CCGEUmode: return CCLTUmode; /* reversal ltu */
+  
+    default:  gcc_unreachable ();
+    }
+}
+
+/**
+ * Generate insn patterns to do an integer compare of operands.
+ *
+ * @param[in] code  RTX for the condition code.
+ * @param[in] op0   RTX for the first operand.
+ * @param[in] op1   RTX for the second operand.
+ * @return  RTX for the comparison.
+ */
+static rtx
+ncpu32k_expand_int_compare (enum rtx_code  code,
+			 rtx            op0,
+			 rtx            op1)
+{
+  enum machine_mode cmpmode;
+  rtx tmp, flags;
+
+  cmpmode = ncpu32k_select_cc_mode (code);
+  cmpmode = ncpu32k_map_cc_mode (cmpmode);
+  flags = gen_rtx_REG (cmpmode, NCPU32K_CC_REG);
+
+  /* This is very simple, but making the interface the same as in the
+     FP case makes the rest of the code easier.  */
+  tmp = gen_rtx_COMPARE (cmpmode, op0, op1);
+  emit_insn (gen_rtx_SET (VOIDmode, flags, tmp));
+
+  /* Return the test that should be put into the flags user, i.e.
+     the bcc, scc instruction.  */
+  return gen_rtx_fmt_ee (code, VOIDmode, flags, const0_rtx);
+
+}
+
+/**
+ * Generate insn patterns to do an INTEGER compare of operands.
+ *
+ * @param[in] code  RTX for the condition code.
+ * @param[in] op0   RTX for the first operand.
+ * @param[in] op1   RTX for the second operand.
+ * @return  RTX for the comparison.
+ */
+static rtx
+ncpu32k_expand_compare (enum rtx_code code, rtx op0, rtx op1)
+{
+  return ncpu32k_expand_int_compare (code, op0, op1);
+
+}
+
+void
+ncpu32k_expand_cmpxchg_qihi (rtx bval, rtx retval, rtx mem, rtx oldval, rtx newval,
+                          int  __attribute__ ((unused)) is_weak,
+                          enum memmodel __attribute__ ((unused)) success_mode,
+                          enum memmodel __attribute__ ((unused)) failure_mode)
+{
+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));
+  rtx addr = gen_reg_rtx (Pmode);
+  rtx off = gen_reg_rtx (SImode);
+  rtx shifter = gen_reg_rtx (SImode);
+  rtx retword = gen_reg_rtx (SImode);
+  rtx mask = gen_reg_rtx (SImode);
+  rtx shifted_oldval = gen_reg_rtx (SImode);
+  rtx shifted_newval = gen_reg_rtx (SImode);
+  rtx shifted_mask = gen_reg_rtx (SImode);
+  rtx mask_const;
+  rtx memsi;
+  enum machine_mode mode = GET_MODE (mem);
+
+  oldval = gen_lowpart_common (SImode, oldval);
+  newval = gen_lowpart_common (SImode, newval);
+
+  mask_const = gen_rtx_CONST_INT (VOIDmode,
+                                  mode == QImode ? 0xff : 0xffff);
+  emit_insn (gen_rtx_SET (VOIDmode, mask, mask_const));
+
+  /* align address and retrieve the offset. */
+  emit_insn (gen_rtx_SET (VOIDmode, addr,
+             gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+             gen_rtx_AND (SImode, addr1, GEN_INT (3))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+                          gen_rtx_XOR (SImode, off,
+                                       GEN_INT (GET_MODE (mem) == QImode
+                                                ? 3 : 2))));
+
+  memsi = gen_rtx_MEM (SImode, addr);
+
+  /* shift all arguments to be aligned to where the data we want
+   * to operate on is located. */
+  emit_insn (gen_rtx_SET (VOIDmode, shifter,
+             gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));
+
+  emit_insn (gen_ashlsi3 (shifted_oldval, oldval, shifter));
+  emit_insn (gen_ashlsi3 (shifted_newval, newval, shifter));
+  emit_insn (gen_ashlsi3 (shifted_mask, mask, shifter));
+
+  emit_insn (gen_cmpxchg_mask (bval, retword, memsi, shifted_oldval,
+                               shifted_newval, shifted_mask));
+
+  /* shift the data we care about to the lower end. */
+  emit_insn (gen_lshrsi3 (retword, retword, shifter));
+
+  emit_move_insn (retval, gen_lowpart (GET_MODE (retval), retword));
+}
+
+void
+ncpu32k_expand_fetch_op_qihi (rtx oldval, rtx mem, rtx operand, rtx newval,
+                           rtx (*generator)(rtx, rtx, rtx, rtx, rtx))
+{
+  rtx addr1 = force_reg (Pmode, XEXP (mem, 0));
+  rtx addr = gen_reg_rtx (Pmode);
+  rtx off = gen_reg_rtx (SImode);
+  rtx shifter = gen_reg_rtx (SImode);
+  rtx mask = gen_reg_rtx (SImode);
+  rtx shifted_oldval = gen_reg_rtx (SImode);
+  rtx shifted_newval = gen_reg_rtx (SImode);
+  rtx shifted_operand = gen_reg_rtx (SImode);
+  rtx shifted_mask = gen_reg_rtx (SImode);
+  rtx mask_const;
+  rtx memsi;
+  enum machine_mode mode = GET_MODE (mem);
+
+  /* TODO(bluecmd): A lot of code is shared between cmpxchg and this. We should
+   * move it to nice functions. */
+  operand = gen_lowpart_common (SImode, operand);
+
+  mask_const = gen_rtx_CONST_INT (VOIDmode,
+                                  mode == QImode ? 0xff : 0xffff);
+  emit_insn (gen_rtx_SET (VOIDmode, mask, mask_const));
+
+  /* align address and retrieve the offset. */
+  emit_insn (gen_rtx_SET (VOIDmode, addr,
+             gen_rtx_AND (Pmode, addr1, GEN_INT (-4))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+             gen_rtx_AND (SImode, addr1, GEN_INT (3))));
+  emit_insn (gen_rtx_SET (VOIDmode, off,
+                          gen_rtx_XOR (SImode, off,
+                                       GEN_INT (GET_MODE (mem) == QImode
+                                                ? 3 : 2))));
+
+  memsi = gen_rtx_MEM (SImode, addr);
+
+  /* shift all arguments to be aligned to where the data we want
+   * to operate on is located. */
+  emit_insn (gen_rtx_SET (VOIDmode, shifter,
+             gen_rtx_ASHIFT (SImode, off, GEN_INT (3))));
+
+  emit_insn (gen_ashlsi3 (shifted_operand, operand, shifter));
+  emit_insn (gen_ashlsi3 (shifted_mask, mask, shifter));
+
+  emit_insn (generator (shifted_oldval, memsi, shifted_operand,
+                        shifted_newval, shifted_mask));
+
+  /* shift the data we care about to the lower end. */
+  emit_insn (gen_lshrsi3 (shifted_oldval, shifted_oldval, shifter));
+  emit_insn (gen_lshrsi3 (shifted_newval, shifted_newval, shifter));
+  emit_move_insn (oldval, gen_lowpart (GET_MODE (oldval), shifted_oldval));
+  emit_move_insn (newval, gen_lowpart (GET_MODE (newval), shifted_newval));
+}
+
+
+static void
+ncpu32k_print_operand_address (FILE *stream, rtx addr)
+{
+  rtx offset;
+
+  switch (GET_CODE (addr))
+    {
+    case MEM:
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+        fprintf (stream, "%s", reg_names[REGNO (addr)]);
+      else
+        abort ();
+      break;
+
+    case REG:
+      fprintf (stream, "0(%s)", reg_names[REGNO (addr)]);
+      break;
+
+    case PLUS:
+      offset = 0;
+
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+        {
+          offset = XEXP (addr, 1);
+          addr   = XEXP (addr, 0);
+        }
+      else if (GET_CODE (XEXP (addr, 1)) == REG)
+        {
+          offset = XEXP (addr, 0);
+          addr   = XEXP (addr, 1);
+        }
+      output_address (offset);
+      fprintf (stream, "(%s)", reg_names[REGNO (addr)]);
+      break;
+
+    case SYMBOL_REF:
+      if (SYMBOL_REF_DECL (addr))
+        assemble_external (SYMBOL_REF_DECL (addr));
+
+      if (XSTR (addr, 0)[0] == '*')
+        fputs (&XSTR (addr, 0)[1], stream);
+      else
+        {
+          asm_fprintf (stream, "%U%s", XSTR (addr, 0));
+        }
+      break;
+
+    default:
+      output_addr_const (stream, addr);
+    }
+}
+
+/**
+ * Is this a value suitable for an NCPU32K address displacement?
+ *
+ * Must be an integer (signed) which fits into 14-bits. If the result is a
+ * double word, we had better also check that we can also get at the second
+ * word.
+ *
+ * @param[in] mode  Mode of the result for which this displacement will be
+ *                  used.
+ * @param[in] x     RTX for an expression.
+ * @return  Non-zero (TRUE) if this is a valid 14-bit offset, zero (FALSE)
+ *          otherwise.
+ */
+static int
+ncpu32k_legitimate_displacement_p (enum machine_mode  mode,
+				rtx                x)
+{
+  if (CONST_INT == GET_CODE(x))
+    {
+      HOST_WIDE_INT  disp = INTVAL (x);
+
+      /* Allow for a second access 4 bytes further on if double. */
+      if ((DFmode == mode) || (DImode == mode))
+	{
+	  return  (CONST_INT_I_MIN < disp) && (disp <= CONST_INT_I_MAX-4);
+	}
+      else
+	{
+	  return  (CONST_INT_I_MIN < disp) && (disp <= CONST_INT_I_MAX);
+	}
+    }
+  else
+    {
+      return  0;
+    }
+}
+
+
+/**
+ * Can this register be used as a base register?
+ *
+ * @todo The code from the old port does not allow r0 as a base when strict,
+ *       and does when non-strict. Surely it is always a valid register?
+ *
+ * @param[in] regno   The register to test
+ * @param[in] strict  Non-zero (TRUE) if this is a strict check, zero (FALSE)
+ *                    otherwise.
+ * @return  Non-zero (TRUE) if this register can be used as a base register,
+ *          zero (FALSE) otherwise.
+ */
+static bool
+ncpu32k_regnum_ok_for_base_p (HOST_WIDE_INT  num,
+			   bool           strict)
+{
+  if (strict)
+    {
+      return (num < FIRST_PSEUDO_REGISTER)
+	? (num > 0) && (num <= NCPU32K_LAST_INT_REG)
+	: (reg_renumber[num] > 0) && (reg_renumber[num] <= NCPU32K_LAST_INT_REG);
+    }
+  else
+    {
+      return (num <= NCPU32K_LAST_INT_REG) || (num >= FIRST_PSEUDO_REGISTER);
+    }
+}
+
+/* LEGITIMATE_PIC_OPERAND_P */
+int
+ncpu32k_legitimate_pic_operand_p (rtx x)
+{
+  if (GET_CODE (x) == CONST
+      && GET_CODE (XEXP (x, 0)) == PLUS
+      && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
+	   && (!SYMBOL_REF_LOCAL_P (XEXP (XEXP (x, 0), 0))
+	       || SYMBOL_REF_WEAK (XEXP (XEXP (x, 0), 0))))
+	  || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)
+      && CONST_INT_P (XEXP (XEXP (x, 0), 1)))
+    return ncpu32k_legitimate_displacement_p (SImode, XEXP (XEXP (x, 0), 1));
+
+  return 1;
+}
+
+static bool
+ncpu32k_expand_pic_symbol_ref (enum machine_mode mode ATTRIBUTE_UNUSED,
+			    rtx operands[])
+{
+  if (GET_CODE (operands[1]) == LABEL_REF
+      || (GET_CODE (operands[1]) == SYMBOL_REF
+	  && SYMBOL_REF_LOCAL_P (operands[1])
+	  && !SYMBOL_REF_WEAK (operands[1])))
+    {
+      crtl->uses_pic_offset_table = 1;
+      emit_insn (gen_movsi_gotoffhi (operands[0], operands[1]));
+      emit_insn (gen_movsi_gotofflo (operands[0], operands[0],
+				     operands[1]));
+      emit_insn (gen_add3_insn(operands[0], operands[0],
+			       pic_offset_table_rtx));
+      return true;
+    }
+  else if (GET_CODE (operands[1]) == SYMBOL_REF)
+    {
+      crtl->uses_pic_offset_table = 1;
+      emit_insn (gen_movsi_got (operands[0], operands[1]));
+      return true;
+    }
+  else if (GET_CODE (operands[1]) == CONST
+	   && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF
+	   && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT)
+    {
+      rtx symbolref = XEXP (XEXP (operands[1], 0), 0);
+      crtl->uses_pic_offset_table = 1;
+
+      if (SYMBOL_REF_LOCAL_P (symbolref)
+	  && !SYMBOL_REF_WEAK (symbolref))
+	{
+	  emit_insn (gen_movsi_gotoffhi (operands[0], operands[1]));
+	  emit_insn (gen_movsi_gotofflo (operands[0], operands[0],
+					 operands[1]));
+	  emit_insn (gen_add3_insn(operands[0], operands[0],
+				   pic_offset_table_rtx));
+	}
+      else
+	{
+	  rtx const_int = XEXP (XEXP (operands[1], 0), 1);
+
+	  /* Expand the constant into a register if it doesn't
+	     fit directly as an 14-bit immediate in the add below.
+	     Note that the reg allocation is allowed here since
+	     we are guarded by LEGITIMATE_PIC_OPERAND_P. */
+	  if (!ncpu32k_legitimate_displacement_p (mode, const_int))
+	    {
+	      rtx scratch = gen_reg_rtx (mode);
+
+	      ncpu32k_emit_set_const32 (scratch, const_int);
+	      const_int = scratch;
+	    }
+
+	  emit_insn (gen_movsi_got (operands[0], symbolref));
+	  emit_insn (gen_add3_insn(operands[0], operands[0], const_int));
+	}
+      return true;
+    }
+  return false;
+}
+
+/** Return the TLS type for TLS symbols, 0 otherwise.  */
+enum tls_model
+ncpu32k_tls_symbolic_operand (rtx op)
+{
+  if (GET_CODE (op) == CONST)
+    {
+      rtx sym, addend;
+      split_const (op, &sym, &addend);
+      if (GET_CODE (sym) == SYMBOL_REF)
+	return SYMBOL_REF_TLS_MODEL (sym);
+    }
+  else if (GET_CODE (op) == SYMBOL_REF)
+    return SYMBOL_REF_TLS_MODEL (op);
+
+  return TLS_MODEL_NONE;
+}
+
+static GTY(()) rtx gen_tls_tga;
+
+/** Get reference to the '__tls_get_addr' symbol */
+static rtx
+gen_tls_get_addr (void)
+{
+  if (!gen_tls_tga)
+    gen_tls_tga = init_one_libfunc ("__tls_get_addr");
+  return gen_tls_tga;
+}
+
+/** Emit call to '__tls_get_addr' */
+static void
+ncpu32k_tls_call (rtx dest, rtx arg)
+{
+  emit_library_call_value (gen_tls_get_addr(), dest,
+      LCT_CONST, Pmode, 1, arg, Pmode);
+}
+
+static rtx
+ncpu32k_legitimize_tls_address (rtx dest, rtx x)
+{
+  rtx sym;
+  rtx tp = gen_rtx_REG(Pmode, THREAD_PTR_REGNUM);
+  rtx addend = NULL_RTX;
+  rtx result = dest;
+
+  enum tls_model tls_kind = ncpu32k_tls_symbolic_operand (x);
+
+  if (GET_CODE (x) == SYMBOL_REF)
+    sym = gen_rtx_SYMBOL_REF(Pmode, XSTR(x, 0));
+  else if (GET_CODE (x) == CONST)
+    {
+      result = gen_reg_rtx (Pmode);
+      split_const (x, &sym, &addend);
+      sym = gen_rtx_SYMBOL_REF(Pmode, XSTR(sym, 0));
+    }
+  else
+    gcc_unreachable ();
+
+  switch (tls_kind) {
+    case TLS_MODEL_GLOBAL_DYNAMIC:
+    case TLS_MODEL_LOCAL_DYNAMIC:
+      {
+        /* TODO: For now, treat LD as GD */
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx offset = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        crtl->uses_pic_offset_table = 1;
+        /* Generate a new symbol ref that is not marked as TLS or we will recurse
+         * in ncpu32k_legitimate_constant_p. */
+        emit_insn (gen_movsi_tlsgdhi (hi, sym));
+        emit_insn (gen_movsi_tlsgdlo (offset, hi, sym));
+        emit_insn (gen_add3_insn (addr, offset, pic_offset_table_rtx));
+        ncpu32k_tls_call (result, addr);
+        break;
+      }
+    case TLS_MODEL_INITIAL_EXEC:
+      {
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx offset = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        rtx tpoffset = gen_reg_rtx (Pmode);
+        crtl->uses_pic_offset_table = 1;
+        emit_insn (gen_movsi_gottpoffhi (hi, sym));
+        emit_insn (gen_movsi_gottpofflo (offset, hi, sym));
+        emit_insn (gen_add3_insn (addr, offset, pic_offset_table_rtx));
+        emit_insn (gen_load_gottpoff (tpoffset, addr));
+        emit_insn (gen_add3_insn (result, tpoffset, tp));
+        break;
+      }
+    case TLS_MODEL_LOCAL_EXEC:
+      {
+        rtx hi = gen_reg_rtx (Pmode);
+        rtx addr = gen_reg_rtx (Pmode);
+        emit_insn (gen_movsi_tpoffhi (hi, sym));
+        emit_insn (gen_movsi_tpofflo (addr, hi, sym));
+        emit_insn (gen_add3_insn (result, addr, tp));
+        break;
+      }
+    default:
+      gcc_unreachable ();
+  }
+
+  if (addend != NULL_RTX)
+    emit_insn (gen_add3_insn (dest, result, addend));
+
+  return dest;
+}
+
+static rtx
+ncpu32k_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,
+                         enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  if (ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE)
+    return ncpu32k_legitimize_tls_address (gen_reg_rtx (Pmode), x);
+
+  return x;
+}
+
+static bool
+ncpu32k_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  return ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE;
+}
+
+bool
+ncpu32k_expand_symbol_ref(enum machine_mode mode, rtx operands[])
+{
+  if (flag_pic && ncpu32k_expand_pic_symbol_ref(mode, operands))
+    return true;
+
+  return false;
+}
+
+bool
+ncpu32k_expand_move (enum machine_mode mode, rtx operands[])
+{
+  if (can_create_pseudo_p ())
+    {
+      if (GET_CODE (operands[0]) == MEM
+	  || (GET_CODE (operands[0]) == SUBREG
+	      && GET_CODE (SUBREG_REG (operands[0])) == MEM))
+        {
+          /* Source operand for store must be in a register.  */
+          operands[1] = force_reg (SImode, operands[1]);
+        }
+    }
+
+  if (ncpu32k_tls_symbolic_operand (operands[1]) != TLS_MODEL_NONE)
+    {
+      ncpu32k_legitimize_tls_address (force_reg (Pmode, operands[0]),
+          operands[1]);
+      return true;
+    }
+
+  if (ncpu32k_expand_symbol_ref (mode, operands))
+    return true;
+
+  /* Working with CONST_INTs is easier, so convert
+     a double if needed.  */
+
+  if (GET_CODE (operands[1]) == CONST_DOUBLE) {
+    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));
+  }
+
+  /* Handle sets of MEM first.  */
+  if (GET_CODE (operands[0]) == MEM)
+    {
+      if (register_operand(operands[1], SImode)
+          || (operands[1] == const0_rtx))
+        goto movsi_is_ok;
+
+      if (! reload_in_progress)
+        {
+          operands[0] = validize_mem (operands[0]);
+          operands[1] = force_reg (SImode, operands[1]);
+        }
+    }
+
+  /* This makes sure we will not get rematched due to splittage.  */
+  if (! CONSTANT_P (operands[1]) || input_operand (operands[1], SImode))
+    ;
+  else if (CONSTANT_P (operands[1])
+           && GET_CODE (operands[1]) != HIGH
+           && GET_CODE (operands[1]) != LO_SUM)
+    {
+      ncpu32k_emit_set_const32 (operands[0], operands[1]);
+      return true;
+    }
+ movsi_is_ok:
+  ;
+
+  return false;
+}
+
+/**
+ * Emit a move from SRC to DEST.
+ *
+ *  Assume that the move expanders can handle all moves if !can_create_pseudo_p
+ *  ().  The distinction is important because, unlike emit_move_insn, the move
+ *  expanders know how to force Pmode objects into the constant pool even when
+ *  the constant pool address is not itself legitimate.
+ *
+ *  @param[in] dest  Destination of the move.
+ *  @param[in] src   Source for the move.
+ *  @return  RTX for the move.
+ */
+static rtx
+ncpu32k_emit_move (rtx dest, rtx src)
+{
+  return (can_create_pseudo_p ()
+	  ? emit_move_insn (dest, src)
+	  : emit_move_insn_1 (dest, src));
+
+}
+
+
+/**
+ * Emit an instruction of the form (set TARGET (CODE OP0 OP1)).
+ *
+ * @param[in] code    The code for the operation.
+ * @param[in] target  Destination for the set operation.
+ * @param[in] op0     First operand.
+ * @param[in] op1     Second operand.
+ */
+static void
+ncpu32k_emit_binary (enum rtx_code  code,
+		  rtx            target,
+		  rtx            op0,
+		  rtx            op1)
+{
+  emit_insn (gen_rtx_SET (VOIDmode, target,
+			  gen_rtx_fmt_ee (code, GET_MODE (target), op0, op1)));
+
+}
+
+
+/**
+ * Compute the result of an operation into a new register.
+ *
+ * Compute ("code" "op0" "op1") and store the result in a new register of mode
+ * "mode".
+ *
+ * @param[in] mode  Mode of the result
+ * @parma[in] code  RTX for the operation to perform
+ * @param[in] op0   RTX for the first operand
+ * @param[in] op1   RTX for the second operand  
+ * @return  The RTX for the new register.
+ */
+static rtx
+ncpu32k_force_binary (enum machine_mode  mode,
+		   enum rtx_code      code,
+		   rtx                op0,
+		   rtx                op1)
+{
+  rtx  reg;
+
+  reg = gen_reg_rtx (mode);
+  ncpu32k_emit_binary (code, reg, op0, op1);
+
+  return reg;
+
+}
+
+
+/*****************************************************************************/
+/* Global support functions                                                  */
+/*****************************************************************************/
+
+static int
+ncpu32k_trampoline_code_words (void)
+{
+  return 5;
+}
+
+/**
+ * Return the size in bytes of the trampoline code.
+ *
+ * Padded to TRAMPOLINE_ALIGNMENT bits. The code sequence is documented in
+ * ncpu32k_trampoline_init ()ï¼Ž
+ *
+ * This is just the code size. the static chain pointer and target function
+ * address immediately follow.
+ *
+ * @return  The size of the trampoline code in bytes.
+ */
+int
+ncpu32k_trampoline_code_size (void)
+{
+  const int  TRAMP_BYTE_ALIGN = TRAMPOLINE_ALIGNMENT / 8;
+
+  return (ncpu32k_trampoline_code_words() * 4 + TRAMP_BYTE_ALIGN - 1) / TRAMP_BYTE_ALIGN * TRAMP_BYTE_ALIGN;
+
+}
+
+
+/*****************************************************************************/
+/* Functions to support the Machine Description                              */
+/*****************************************************************************/
+
+/** Expand the prologue as a series of insns */
+void
+ncpu32k_expand_prologue (void)
+{
+  int total_size = ncpu32k_compute_frame_size (get_frame_size ());
+  rtx insn;
+
+  if (!total_size)
+    /* No frame needed.  */
+    return;
+
+  gcc_assert (!frame_info.save_lr_p || !frame_info.save_fp_p
+	      || frame_info.lr_save_offset != frame_info.fp_save_offset);
+
+  if (frame_info.gpr_frame)
+    emit_frame_insn (gen_add2_insn (stack_pointer_rtx,
+				    GEN_INT (-frame_info.gpr_frame)));
+  if (frame_info.save_fp_p)
+    {
+      emit_frame_insn (gen_rtx_SET (Pmode,
+				    stack_disp_mem (frame_info.fp_save_offset),
+				    hard_frame_pointer_rtx));
+
+      emit_frame_insn
+	(gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx, const0_rtx));
+    }
+  if (frame_info.save_lr_p)
+    {
+      emit_frame_insn
+	(gen_rtx_SET (Pmode, stack_disp_mem (frame_info.lr_save_offset),
+		      gen_rtx_REG (Pmode, LINK_REGNUM)));
+    }
+  if (frame_info.gpr_size)
+    {
+      int offset = 0;
+      int regno;
+
+      for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+	{
+	  if (!(frame_info.mask & ((HOST_WIDE_INT) 1 << regno)))
+	    continue;
+
+	  /* Check that the offsets aren't stepping on lr/fp slots */
+	  gcc_assert (!frame_info.save_lr_p
+		      || ((frame_info.gpr_offset + offset)
+			  != frame_info.lr_save_offset));
+	  gcc_assert (!frame_info.save_fp_p
+		      || ((frame_info.gpr_offset + offset)
+			  != frame_info.fp_save_offset));
+
+	  emit_frame_insn
+	    (gen_rtx_SET (Pmode,
+			  stack_disp_mem (frame_info.gpr_offset + offset),
+			  gen_rtx_REG (Pmode, regno)));
+	  offset = offset + UNITS_PER_WORD;
+	}
+    }
+
+  /* Update the stack pointer to reflect frame size.  */
+  total_size = frame_info.late_frame;
+  insn = gen_add2_insn (stack_pointer_rtx, GEN_INT (-total_size));
+  if (total_size > CONST_INT_I_MAX+1)
+    {
+      rtx note = insn;
+      rtx value_rtx = gen_rtx_REG (Pmode, PROLOGUE_TMP);
+
+      ncpu32k_emit_set_const32 (value_rtx, GEN_INT (-total_size));
+      if (frame_info.save_fp_p)
+	insn = gen_frame_alloc_fp (value_rtx);
+      else
+	insn = gen_add2_insn (stack_pointer_rtx, value_rtx);
+      insn = emit_frame_insn (insn);
+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);
+    }
+  else if (total_size)
+    {
+      if (frame_info.save_fp_p)
+	emit_frame_insn (gen_frame_alloc_fp (GEN_INT (-total_size)));
+      else
+	emit_frame_insn (insn);
+    }
+  /* Emit got pointer acquiring if there are any got references or
+     this function has calls */
+  if (crtl->uses_pic_offset_table || (flag_pic && frame_info.save_lr_p))
+    {
+      SET_REGNO (pic_offset_table_rtx, PIC_OFFSET_TABLE_REGNUM);
+      emit_insn (gen_set_got (pic_offset_table_rtx));
+    }
+
+}
+
+/** Expand the epilogue as a series of insns. */
+void
+ncpu32k_expand_epilogue (void)
+{
+  int total_size = ncpu32k_compute_frame_size (get_frame_size ());
+
+  if (frame_info.save_fp_p)
+    {
+      emit_insn (gen_frame_dealloc_fp ());
+      emit_insn
+	(gen_rtx_SET (Pmode, hard_frame_pointer_rtx,
+		      stack_disp_mem (frame_info.fp_save_offset)));
+    }
+  else
+    {
+      rtx value_rtx;
+
+      total_size = frame_info.late_frame;
+      if (total_size > CONST_INT_I_MAX)
+	{
+	  value_rtx = gen_rtx_REG (Pmode, EPILOGUE_TMP);
+	  ncpu32k_emit_set_const32 (value_rtx, GEN_INT (total_size));
+	}
+      else if (frame_info.late_frame)
+	value_rtx = GEN_INT (total_size);
+      if (total_size)
+	emit_insn (gen_frame_dealloc_sp (value_rtx));
+    }
+
+  /* eh_return sets the LR, do not overwrite it */
+  if (frame_info.save_lr_p && !crtl->calls_eh_return)
+    {
+      emit_insn
+        (gen_rtx_SET (Pmode, gen_rtx_REG (Pmode, LINK_REGNUM),
+                      stack_disp_mem (frame_info.lr_save_offset)));
+    }
+
+  if (frame_info.gpr_size)
+    {
+      int offset = 0;
+      int regno;
+
+      for (regno = 0; regno <= NCPU32K_LAST_ACTUAL_REG; regno++)
+	{
+	  if (!(frame_info.mask & ((HOST_WIDE_INT) 1 << regno)))
+	    continue;
+
+	  if (regno != FIRST_PSEUDO_REGISTER)
+	    emit_insn
+	      (gen_rtx_SET (Pmode, gen_rtx_REG (Pmode, regno),
+			    stack_disp_mem (frame_info.gpr_offset + offset)));
+	  offset = offset + UNITS_PER_WORD;
+	}
+    }
+
+  if (crtl->calls_eh_return)
+    emit_insn (gen_add2_insn (stack_pointer_rtx, EH_RETURN_STACKADJ_RTX));
+
+  if (frame_info.gpr_frame)
+    emit_insn (gen_add2_insn (stack_pointer_rtx,
+			      GEN_INT (frame_info.gpr_frame)));
+  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, LINK_REGNUM)));
+
+}
+
+
+/**
+ * Generate assembler code for a movdi/movdf pattern
+ *
+ * @param[in] operands  Operands to the movdx pattern.
+ * @return  The assembler string to output (always "", since we've done the
+ *          output here).
+ */
+const char *
+ncpu32k_output_move_double (rtx *operands)
+{
+  rtx xoperands[3];
+
+  switch (GET_CODE (operands[0]))
+    {
+    case REG:
+      if (GET_CODE (operands[1]) == REG)
+	{
+	  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)
+	    {
+	      output_asm_insn ("\tor \t%H0,%H1,r0", operands);
+	      output_asm_insn ("\tor \t%0,%1,r0", operands);
+	      return "";
+	    }
+	  else
+	    {
+	      output_asm_insn ("\tor \t%0,%1,r0", operands);
+	      output_asm_insn ("\tor \t%H0,%H1,r0", operands);
+	      return "";
+	    }
+	}
+      else if (GET_CODE (operands[1]) == MEM)
+	{
+	  xoperands[1] = XEXP (operands[1], 0);
+	  if (GET_CODE (xoperands[1]) == REG)
+	    {
+	      xoperands[0] = operands[0];
+	      if (REGNO (xoperands[0]) == REGNO (xoperands[1]))
+		{
+		  output_asm_insn ("\tldwu \t%H0,4(%1)", xoperands);
+		  output_asm_insn ("\tldwu \t%0,0(%1)", xoperands);
+		  return "";
+		}
+	      else
+		{
+		  output_asm_insn ("\tldwu \t%0,0(%1)", xoperands);
+		  output_asm_insn ("\tldwu \t%H0,4(%1)", xoperands);
+		  return "";
+		}
+	    }
+	  else if (GET_CODE (xoperands[1]) == PLUS)
+	    {
+	      if (GET_CODE (xoperands[2] = XEXP (xoperands[1], 1)) == REG)
+		{
+		  xoperands[0] = operands[0];
+		  xoperands[1] = XEXP (xoperands[1], 0);
+		  if (REGNO (xoperands[0]) == REGNO (xoperands[2]))
+		    {
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)",
+				       xoperands);
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      return "";
+		    }
+		  else
+		    {
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)", xoperands);
+		      return "";
+		    }
+		}
+	      else if (GET_CODE (xoperands[2] = XEXP (xoperands[1], 0)) ==
+		       REG)
+		{
+		  xoperands[0] = operands[0];
+		  xoperands[1] = XEXP (xoperands[1], 1);
+		  if (REGNO (xoperands[0]) == REGNO (xoperands[2]))
+		    {
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)",
+				       xoperands);
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      return "";
+		    }
+		  else
+		    {
+		      output_asm_insn ("\tldwu \t%0,%1(%2)", xoperands);
+		      output_asm_insn ("\tldwu \t%H0,%1+4(%2)", xoperands);
+		      return "";
+		    }
+		}
+	      else
+		abort ();
+	    }
+	  else
+	    abort ();
+	}
+      else
+	abort ();
+    case MEM:
+      xoperands[0] = XEXP (operands[0], 0);
+      if (GET_CODE (xoperands[0]) == REG)
+	{
+	  xoperands[1] = operands[1];
+	  output_asm_insn ("\tstw \t0(%0),%1", xoperands);
+	  output_asm_insn ("\tstw \t4(%0),%H1", xoperands);
+	  return "";
+	}
+      else if (GET_CODE (xoperands[0]) == PLUS)
+	{
+	  if (GET_CODE (xoperands[1] = XEXP (xoperands[0], 1)) == REG)
+	    {
+	      xoperands[0] = XEXP (xoperands[0], 0);
+	      xoperands[2] = operands[1];
+	      output_asm_insn ("\tstw \t%0(%1),%2", xoperands);
+	      output_asm_insn ("\tstw \t%0+4(%1),%H2", xoperands);
+	      return "";
+	    }
+	  else if (GET_CODE (xoperands[1] = XEXP (xoperands[0], 0)) == REG)
+	    {
+	      xoperands[0] = XEXP (xoperands[0], 1);
+	      xoperands[2] = operands[1];
+	      output_asm_insn ("\tstw \t%0(%1),%2", xoperands);
+	      output_asm_insn ("\tstw \t%0+4(%1),%H2", xoperands);
+	      return "";
+	    }
+	  else
+	    abort ();
+	}
+      else
+	{
+	  fprintf (stderr, "  O/p error %s\n", GET_RTX_NAME (GET_CODE (xoperands[0])));
+	  return "";
+	  /* abort (); */
+	}
+    default:
+      abort ();
+    }
+}
+
+/**
+ * Expand a conditional branch
+ *
+ * @param[in] operands  Operands to the branch.
+ * @param[in] mode      Mode of the comparison.
+ * @return assembly code for cbranch.
+ */
+void
+ncpu32k_expand_cbranch (rtx *operands, enum machine_mode mode)
+{
+  rtx tmp;
+  enum rtx_code test_code = GET_CODE(operands[0]);
+
+  switch (mode)
+    {
+    case SImode:
+      tmp = ncpu32k_expand_compare (test_code, operands[1], operands[2]);
+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode,
+				  tmp,
+				  gen_rtx_LABEL_REF (VOIDmode, operands[3]),
+				  pc_rtx);
+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));
+      return;
+      
+    case SFmode:
+      tmp = ncpu32k_expand_compare (test_code, operands[1], operands[2]);
+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode,
+				  tmp,
+				  gen_rtx_LABEL_REF (VOIDmode, operands[3]),
+				  pc_rtx);
+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));
+      return;
+      
+    default:
+      abort ();
+    }
+}
+
+
+/**
+ * Output the assembler for cc-branch instruction.
+ *
+ * @param[in] operands  Operands to the branch.
+ * @return  The assembler string to use.
+ */
+const char *
+ncpu32k_output_bcc (rtx * operands)
+{
+  enum rtx_code code;
+  enum machine_mode mode_calc, mode_op;
+
+  code      = GET_CODE (operands[1]);
+  mode_calc = ncpu32k_select_cc_mode (code);
+  mode_op   = GET_MODE (operands[2]);
+
+  if (mode_calc == mode_op)
+    return "bt\t%l0%(";
+  else
+    return "bf\t%l0%("; /* reversed */
+}
+
+
+/**
+ * Load a 32-bit constant.
+ *
+ * We know it can't be done in one insn when we get here, the movsi expander
+ * guarantees this.
+ *
+ * @param[in] op0  RTX for the destination.
+ * @param[in] op1  RTX for the (constant) source.
+ */
+void
+ncpu32k_emit_set_const32 (rtx  op0,
+		       rtx  op1)
+{
+  enum machine_mode mode = GET_MODE (op0);
+  rtx temp;
+
+  /* Sanity check that we really can't do it in one instruction. I.e that we
+     don't have a 14-bit constant. */
+  if (GET_CODE (op1) == CONST_INT)
+    {
+      HOST_WIDE_INT val = INTVAL (op1) & GET_MODE_MASK (mode);
+
+      if ((CONST_INT_I_MIN <= val) && (val <= CONST_INT_I_MAX))
+	{
+	  abort ();
+	}
+    }
+
+  /* Full 2-insn decomposition is needed.  */
+  if (reload_in_progress || reload_completed)
+    temp = op0;
+  else
+    temp = gen_reg_rtx (mode);
+
+  if (GET_CODE (op1) == CONST_INT)
+    {
+      /* Emit them as real moves instead of a HIGH/LO_SUM,
+         this way CSE can see everything and reuse intermediate
+         values if it wants.  */
+      emit_insn (gen_rtx_SET (VOIDmode, temp,
+			      GEN_INT (INTVAL (op1)
+				       & ~(HOST_WIDE_INT) 0x3fff)));
+
+      emit_insn (gen_rtx_SET (VOIDmode,
+			      op0,
+			      gen_rtx_IOR (mode, temp,
+					   GEN_INT (INTVAL (op1) & 0x3fff))));
+    }
+  else
+    {
+      /* since ncpu32k bfd can not deal with relocs that are not of type
+         NCPU32K_CONSTH_RELOC + NCPU32K_CONST_RELOC (ie move high must be
+         followed by exactly one lo_sum)
+       */
+      emit_insn (gen_movsi_insn_big (op0, op1));
+    }
+}
+
+void
+ncpu32k_emit_set_const16 (rtx  op0,
+		       rtx  op1)
+{
+  enum machine_mode mode = GET_MODE (op0);
+  rtx temp;
+  
+  /* Sanity check that we are setting a const */
+  if (GET_CODE (op1) != CONST_INT)
+    {
+      abort ();
+    }
+  /* Sanity check that we really can't do it in one instruction. I.e that we
+     don't have a 14-bit constant. */
+  HOST_WIDE_INT val = INTVAL (op1) & GET_MODE_MASK (mode);
+
+  if ((CONST_INT_I_MIN <= val) && (val <= CONST_INT_I_MAX))
+    {
+      abort ();
+    }
+
+  /* Full 2-insn decomposition is needed.  */
+  if (reload_in_progress || reload_completed)
+    temp = op0;
+  else
+    temp = gen_reg_rtx (mode);
+
+  /* Emit them as real moves instead of a HIGH/LO_SUM,
+   this way CSE can see everything and reuse intermediate
+   values if it wants.  */
+  emit_insn (gen_rtx_SET (VOIDmode, temp,
+  		      GEN_INT (INTVAL (op1)
+  			       & ~(HOST_WIDE_INT) 0x3fff)));
+
+  emit_insn (gen_rtx_SET (VOIDmode,
+  		      op0,
+  		      gen_rtx_IOR (mode, temp,
+  				   GEN_INT (INTVAL (op1) & 0x3fff))));
+}
+
+
+/*****************************************************************************/
+/* Target hook functions.                                                    */
+/*****************************************************************************/
+
+/*
+ These are initialized at the end of this file, to avoid having to
+ predeclare all the functions. They are only needed here, so are static.    */
+
+
+
+
+/* -------------------------------------------------------------------------- */
+/*!Define where a function returns values.
+
+   Define this to return an RTX representing the place where a function
+   returns or receives a value of data type ret type, a tree node representing
+   a data type.  "func" is a tree node representing FUNCTION_DECL or
+   FUNCTION_TYPE of a function being called. If "outgoing" is false, the hook
+   should compute the register in which the caller will see the return
+   value. Otherwise, the hook should return an RTX representing the place
+   where a function returns a value.
+
+   On many machines, only TYPE_MODE ("ret_type") is relevant. (Actually, on
+   most machines, scalar values are returned in the same place regardless of
+   mode.) The value of the expression is usually a reg RTX for the hard
+   register where the return value is stored. The value can also be a parallel
+   RTX, if the return value is in multiple places. See FUNCTION_ARG for an
+   explanation of the parallel form. Note that the callee will populate every
+   location specified in the parallel, but if the first element of the
+   parallel contains the whole return value, callers will use that element as
+   the canonical location and ignore the others. The m68k port uses this type
+   of parallel to return pointers in both â€˜%a0â€™ (the canonical location) and
+   â€˜%d0â€™.
+
+   If TARGET_PROMOTE_FUNCTION_RETURN returns true, you must apply the same
+   promotion rules specified in PROMOTE_MODE if valtype is a scalar type.
+
+   If the precise function being called is known, "func" is a tree node
+   (FUNCTION_DECL) for it; otherwise, "func" is a null pointer. This makes it
+   possible to use a different value-returning convention for specific
+   functions when all their calls are known.
+
+   Some target machines have "register windows" so that the register in which
+   a function returns its value is not the same as the one in which the caller
+   sees the value. For such machines, you should return different RTX
+   depending on outgoing.
+
+   TARGET_FUNCTION_VALUE is not used for return values with aggregate data
+   types, because these are returned in another way. See
+   TARGET_STRUCT_VALUE_RTX and related macros.
+
+   For the NCPU32K, we can just use the result of LIBCALL_VALUE, since all
+   functions return their result in the same place (register rv).
+
+   FIXME?: What about 64-bit scalar returns (long long int, double),
+                  which also use rvh (=r12)?
+
+   @param[in] ret_type  The return type of the function.
+   @param[in] func      Tree representing function being called.
+   @param[in] outgoing  Non-zero (TRUE) if the result represents where the
+                        function places the results, zero (FALSE) if the
+                        result represents where the caller sees the result.
+
+   @return  A RTX representing where the result can be found.                 */
+/* -------------------------------------------------------------------------- */
+static rtx
+ncpu32k_function_value (const_tree  ret_type,
+		     const_tree  func ATTRIBUTE_UNUSED,
+                     bool        outgoing ATTRIBUTE_UNUSED)
+{
+  return LIBCALL_VALUE (TYPE_MODE(ret_type));
+
+}	/* ncpu32k_function_value () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Check if a function is suitable for tail call optimization.
+
+   True if it is OK to do sibling call optimization for the specified call
+   expression "exp". "decl" will be the called function, or NULL if this is an
+   indirect call.
+
+   It is not uncommon for limitations of calling conventions to prevent tail
+   calls to functions outside the current unit of translation, or during PIC
+   compilation. The hook is used to enforce these restrictions, as the sibcall
+   md pattern can not fail, or fall over to a â€œnormalâ€ call. The criteria for
+   successful sibling call optimization may vary greatly between different
+   architectures.
+
+   For the NCPU32K, we currently don't allow sibcalls.
+
+   @param[in] decl  The function for which we may optimize
+   @param[in] exp   The call expression which is candidate for optimization.
+
+   @return  Non-zero (TRUE) if sibcall optimization is permitted, zero (FALSE)
+            otherwise.                                                        */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_function_ok_for_sibcall (tree  decl ATTRIBUTE_UNUSED,
+			      tree  exp ATTRIBUTE_UNUSED)
+{
+  return 0;
+}	/* ncpu32k_function_ok_for_sibcall () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Should an argument be passed by reference.
+
+   This target hook should return true if an argument at the position
+   indicated by "cum" should be passed by reference. This predicate is queried
+   after target independent reasons for being passed by reference, such as
+   TREE_ADDRESSABLE ("type").
+
+   If the hook returns TRUE, a copy of that argument is made in memory and a
+   pointer to the argument is passed instead of the argument itself. The
+   pointer is passed in whatever way is appropriate for passing a pointer to
+   that type.
+
+   For the NCPU32K, all aggregates and arguments greater than 8 bytes are passed
+   this way.
+
+   @param[in] cum    Position of argument under consideration.
+   @param[in[ mode   Not sure what this relates to.
+   @param[in] type   Type of the argument.
+   @param[in] named  Not sure what this relates to.
+
+   @return  Non-zero (TRUE) if the argument should be passed by reference,
+            zero (FALSE) otherwise.                                           */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_pass_by_reference (cumulative_args_t  cum ATTRIBUTE_UNUSED,
+                        enum machine_mode  mode ATTRIBUTE_UNUSED,
+                        const_tree         type,
+                        bool               named ATTRIBUTE_UNUSED)
+{
+  return (type && (AGGREGATE_TYPE_P (type) || int_size_in_bytes (type) > 8));
+
+}	/* ncpu32k_pass_by_reference () */
+
+
+/* INITIAL_ELIMINATION_OFFSET */
+int
+ncpu32k_initial_elimination_offset(int from, int to)
+{
+  ncpu32k_compute_frame_size (get_frame_size ());
+  return ((from == FRAME_POINTER_REGNUM
+	   ? frame_info.gpr_offset : frame_info.gpr_frame)
+	  + (to == STACK_POINTER_REGNUM ? frame_info.late_frame : 0));
+}
+
+
+/* -------------------------------------------------------------------------- */
+/*!How many bytes at the beginning of an argument must be put into registers.
+
+   This target hook returns the number of bytes at the beginning of an
+   argument that must be put in registers. The value must be zero for
+   arguments that are passed entirely in registers or that are entirely pushed
+   on the stack.
+
+   On some machines, certain arguments must be passed partially in registers
+   and partially in memory. On these machines, typically the first few words
+   of arguments a re passed in registers, and the rest on the stack. If a
+   multi-word argument (a double or a structure) crosses that boundary, its
+   first few words must be passed in registers and the rest must be
+   pushed. This macro tells the compiler when this occurs, and how many bytes
+   should go in registers.
+
+   FUNCTION_ARG for these arguments should return the first register to be
+   used by the caller for this argument; likewise FUNCTION_INCOMING_ARG, for
+   the called function.
+
+   On the NCPU32K we never split argumetns between registers and memory.
+
+   FIXME?: Is this correct? Surely we should allow this. The ABI spec
+                  is incomplete on this point.
+
+   @param[in] cum    Position of argument under consideration.
+   @param[in[ mode   Not sure what this relates to.
+   @param[in] type   Type of the argument.
+   @param[in] named  Not sure what this relates to.
+
+   @return  The number of bytes of the argument to go into registers          */
+/* -------------------------------------------------------------------------- */
+static int
+ncpu32k_arg_partial_bytes (cumulative_args_t cum ATTRIBUTE_UNUSED,
+                        enum machine_mode  mode ATTRIBUTE_UNUSED,
+                        tree               type ATTRIBUTE_UNUSED,
+                        bool               named ATTRIBUTE_UNUSED)
+{
+  return 0;
+
+}	/* ncpu32k_arg_partial_bytes () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Promote the mode of a function's arguments/return value.
+
+   Like PROMOTE_MODE, but it is applied to outgoing function arguments or
+   function return values. The target hook should return the new mode and
+   possibly change "*punsignedp" if the promotion should change
+   signedness. This function is called only for scalar or pointer types.
+
+   "for_return" allows to distinguish the promotion of arguments and return
+   values. If it is 1, a return value is being promoted and
+   TARGET_FUNCTION_VALUE must perform the same promotions done here. If it is
+   2, the returned mode should be that of the register in which an incoming
+   parameter is copied, or the outgoing result is computed; then the hook
+   should return the same mode as PROMOTE_MODE, though the signedness may be
+   different.
+
+   The default is to not promote arguments and return values. You can also
+   define the hook to "default_promote_function_mode_always_promote" if you
+   would like to apply the same rules given by PROMOTE_MODE.
+
+   For the NCPU32K, if the size of the mode is integral and less than 4, we
+   promote to SImode, otherwise we return the mode we are supplied.
+
+   @param[in]  type        Not sure. Type of the argument?
+   @param[in]  mode        The mode of argument/return value to consider.
+   @param[out] punsignedp  Signedness of the value.
+   @param[in]  fntype      Not sure. Type of the function?
+   @param[in]  for_return  1 if a return value, 2 if an incoming value.
+
+   @return  The new mode.                                                     */
+/* -------------------------------------------------------------------------- */
+static enum machine_mode
+ncpu32k_promote_function_mode (const_tree         type ATTRIBUTE_UNUSED,
+			    enum machine_mode  mode,
+			    int               *punsignedp ATTRIBUTE_UNUSED,
+			    const_tree         fntype ATTRIBUTE_UNUSED,
+			    int                for_return ATTRIBUTE_UNUSED)
+{
+  return (   (GET_MODE_CLASS (mode) == MODE_INT)
+	  && (GET_MODE_SIZE (mode) < 4)) ? SImode : mode;
+
+}	/* ncpu32k_promote_function_mode () */
+
+
+/* -------------------------------------------------------------------------- */
+/*!Is this a legitimate address?
+
+  A function that returns whether x (an RTX) is a legitimate memory address on
+  the target machine for a memory operand of mode mode.
+
+  Legitimate addresses are defined in two variants: a strict variant and a
+  non-strict one.  The strict parameter chooses which variant is desired by
+  the caller.
+
+  The strict variant is used in the reload pass. It must be defined so that
+  any pseudo- register that has not been allocated a hard register is
+  considered a memory reference.  This is because in contexts where some kind
+  of register is required, a pseudo-register with no hard register must be
+  rejected. For non-hard registers, the strict variant should look up the
+  reg_renumber array; it should then proceed using the hard register number in
+  the array, or treat the pseudo as a memory reference if the array holds -1.
+
+  The non-strict variant is used in other passes. It must be defined to accept
+  all pseudo-registers in every context where some kind of register is
+  required.
+
+  Normally, constant addresses which are the sum of a symbol_ref and an
+  integer are stored inside a const RTX to mark them as constant. Therefore,
+  there is no need to recognize such sums specifically as legitimate
+  addresses. Normally you would simply recognize any const as legitimate.
+
+  Usually PRINT_OPERAND_ADDRESS is not prepared to handle constant sums that
+  are not marked with const. It assumes that a naked plus indicates
+  indexing. If so, then you must reject such naked constant sums as
+  illegitimate addresses, so that none of them will be given to
+  PRINT_OPERAND_ADDRESS.
+
+  On some machines, whether a symbolic address is legitimate depends on the
+  section that the address refers to. On these machines, define the target
+  hook TARGET_ENCODE_ SECTION_INFO to store the information into the
+  symbol_ref, and then check for it here. When you see a const, you will have
+  to look inside it to find the symbol_ref in order to determine the
+  section. See the internals manual section on "Assembler Format" for more
+  info.
+
+  Some ports are still using a deprecated legacy substitute for this hook, the
+  GO_IF_LEGITIMATE_ADDRESS macro. This macro has this syntax:
+
+    #define GO_IF_LEGITIMATE_ADDRESS (mode, x, label )
+
+  and should goto label if the address x is a valid address on the target
+  machine for a memory operand of mode mode. Whether the strict or non-strict
+  variants are desired is defined by the REG_OK_STRICT macro introduced
+  earlier in this section. Using the hook is usually simpler because it limits
+  the number of files that are recompiled when changes are made.
+
+   The NCPU32K only has a single addressing mode, which is a base register with
+   14-bit displacement. We can accept just 14-bit constants as addresses (they
+   can use r0 as base address, and we can accept plain registers as addresses
+   (they can use a displacement of zero).
+
+   @param[in] mode    The mode of the address
+   @param[in] x       The address (RTX)
+   @param[in] strict  Non-zero (TRUE) if we are in "strict" mode, zero (FALSE)
+                      otherwise.
+
+   @return  Non-zero (TRUE) if this is a legitimate address, zero (FALSE)
+            otherwise.                                                        */
+/* -------------------------------------------------------------------------- */
+static bool
+ncpu32k_legitimate_address_p (enum machine_mode  mode ATTRIBUTE_UNUSED,
+			   rtx                x,
+			   bool               strict)
+{
+  /* Addresses consisting of a register and 14-bit displacement are also
+     suitable. We need the mode, since for double words, we had better be
+     able to address the full 8 bytes. */
+  if (GET_CODE(x) == PLUS)
+    {
+      rtx reg = XEXP(x,0);
+
+      /* If valid register... */
+      if ((GET_CODE(reg) == REG)
+          && ncpu32k_regnum_ok_for_base_p (REGNO (reg), strict))
+        {
+          rtx offset = XEXP(x,1);
+
+          /* ...and valid offset */
+          if (ncpu32k_legitimate_displacement_p (mode, offset))
+            {
+              return 1;
+            }
+        }
+    }
+
+  /* Addresses consisting of just a register are OK. They can be built into
+     addresses using an offset of zero (and an offset of four if double
+     word). */
+  if (GET_CODE(x) == REG
+    && ncpu32k_regnum_ok_for_base_p(REGNO(x),strict)) {
+      return 1;
+  }
+
+  return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/*!Initialize a trampoline for nested functions.
+
+   A nested function is defined by *two* pieces of information, the address of
+   the function (like any other function) and a pointer to the frame of the
+   enclosing function. The latter is required to allow the nested function to
+   access local variables in the enclosing function's frame.
+
+   This represents a problem, since a function in C is represented as an
+   address that can be held in a single variable as a pointer. Requiring two
+   pointers will not fit.
+
+   The solution is documented in "Lexical Closures for C++" by Thomas
+   M. Breuel (USENIX C++ Conference Proceedings, October 17-21, 1988). The
+   nested function is represented by a small block of code and data on the
+   enclosing function's stack frame, which sets up a pointer to the enclosing
+   function's stack frame (the static chain pointer) in a register defined by
+   the ABI, and then jumps to the code of the function proper.
+
+   The function can be represented as a single pointer to this block of code,
+   known as a trampoline, which when called generates both pointers
+   needed. The nested function (which knows it is a nested function at compile
+   time) can then generate code to access the enclosing frame via the static
+   chain register.
+
+   There is a catch that the trampoline is set up as data, but executed as
+   instructions. The former will be via the data cache, the latter via the
+   instruction cache. There is a risk that a later trampoline will not be seen
+   by the instruction cache, so the wrong code will be executed. So the
+   instruction cache should be flushed for the trampoline address range.
+
+   This hook is called to initialize a trampoline. "m_tramp" is an RTX for the
+   memory block for the trampoline; "fndecl" is the FUNCTION_DECL for the
+   nested function; "static_chain" is an RTX for the static chain value that
+   should be passed to the function when it is called.
+
+   If the target defines TARGET_ASM_TRAMPOLINE_TEMPLATE, then the first thing
+   this hook should do is emit a block move into "m_tramp" from the memory
+   block returned by assemble_trampoline_template. Note that the block move
+   need only cover the constant parts of the trampoline. If the target
+   isolates the variable parts of the trampoline to the end, not all
+   TRAMPOLINE_SIZE bytes need be copied.
+
+   If the target requires any other actions, such as flushing caches or
+   enabling stack execution, these actions should be performed after
+   initializing the trampoline proper.
+
+   For the NCPU32K, no static chain register is used. We choose to use the return
+   value (rv) register. The code is based on that for MIPS.
+
+   @note For the NCPU32K we need to flush the instruction cache, which is a
+         privileged operation. Needs fixing.
+
+   @param[in] m_tramp      The lowest address of the trampoline on the stack.
+   @param[in] fndecl       Declaration of the enclosing function.
+   @param[in] chain_value  Static chain pointer to pass to the nested
+                           function.                                          */
+/* -------------------------------------------------------------------------- */
+static void
+ncpu32k_trampoline_init (rtx   m_tramp,
+		      tree  fndecl,
+		      rtx   chain_value)
+{
+  rtx  addr;				/* Start address of the trampoline */
+  rtx  end_addr;			/* End address of the code block */
+
+  rtx  high;				/* RTX for the high part of end_addr */
+  rtx  low;				/* RTX for the low part of end_addr */
+  rtx  opcode;				/* RTX for generated opcodes */
+  rtx  mem;				/* RTX for trampoline memory */
+
+  rtx *trampoline;	/* The trampoline code */
+
+  unsigned int  i;			/* Index into trampoline */
+  unsigned int  j;			/* General counter */
+
+  HOST_WIDE_INT  end_addr_offset;	  /* Offset to end of code */
+  HOST_WIDE_INT  static_chain_offset;	  /* Offset to stack chain word */
+  HOST_WIDE_INT  target_function_offset;  /* Offset to func address word */
+
+  /* Work out the offsets of the pointers from the start of the trampoline
+     code.  */
+  trampoline             = (rtx*) alloca (ncpu32k_trampoline_code_words() * sizeof(rtx));
+  end_addr_offset        = ncpu32k_trampoline_code_size ();
+  static_chain_offset    = end_addr_offset;
+  target_function_offset = static_chain_offset + GET_MODE_SIZE (ptr_mode);
+
+  /* Get pointers in registers to the beginning and end of the code block.  */
+  addr     = force_reg (Pmode, XEXP (m_tramp, 0));
+  end_addr = ncpu32k_force_binary (Pmode, PLUS, addr, GEN_INT (end_addr_offset));
+
+  /* Build up the code in TRAMPOLINE.
+
+              mhi   rv, hi(end_addr)
+              or    rv, lo(end_addr)
+              ldwu  r13, 4(rv)
+              jmp   r13
+              ldwu  rv, 0(rv)
+       end_addr:
+              .word   <static chain>
+              .word   <nested_function>
+  */
+
+  i = 0;
+
+  /* Break out the high and low parts of the end_addr */
+  high = expand_simple_binop (SImode, LSHIFTRT, end_addr, GEN_INT (16),
+			      NULL, false, OPTAB_WIDEN);
+  low  = convert_to_mode (SImode, gen_lowpart (HImode, end_addr), true);
+
+  /* Emit the mhi, adding an operation to OR in the high bits from the
+     RTX. */
+  opcode = gen_int_mode (NCPU32K_MHI (NCPU32K_GPR_RV, 0), SImode);
+  trampoline[i++] = expand_simple_binop (SImode, IOR, opcode, high, NULL,
+					 false, OPTAB_WIDEN); 
+  
+  /* Emit the or.i, adding an operations to OR in the low bits from the
+     RTX. */
+  opcode = gen_int_mode (NCPU32K_OR_I (NCPU32K_GPR_RV, NCPU32K_GPR_RV, 0), SImode);
+  trampoline[i++] = expand_simple_binop (SImode, IOR, opcode, low, NULL,
+					 false, OPTAB_WIDEN); 
+
+  /* Emit the ldw of the function address. No bits to OR in here, so we can
+     do the opcode directly. */
+  trampoline[i++] =
+    gen_int_mode (NCPU32K_LDWU (13, NCPU32K_GPR_RV, target_function_offset - end_addr_offset),
+		  SImode);
+
+  /* Emit the jmp of the function. No bits to OR in here, so we can do the
+     opcode directly. */
+  trampoline[i++] = gen_int_mode (NCPU32K_JMP (13), SImode);
+
+  /* Emit the ldw of the static chain. No bits to OR in here, so we can
+     do the opcode directly. */
+  trampoline[i++] =
+    gen_int_mode (NCPU32K_LDWU (STATIC_CHAIN_REGNUM, NCPU32K_GPR_RV,
+                          static_chain_offset - end_addr_offset), SImode);
+
+  /* Copy the trampoline code.  Leave any padding uninitialized.  */
+  for (j = 0; j < i; j++)
+    {
+      mem = adjust_address (m_tramp, SImode, j * GET_MODE_SIZE (SImode));
+      ncpu32k_emit_move (mem, trampoline[j]);
+    }
+
+  /* Set up the static chain pointer field.  */
+  mem = adjust_address (m_tramp, ptr_mode, static_chain_offset);
+  ncpu32k_emit_move (mem, chain_value);
+
+  /* Set up the target function field.  */
+  mem = adjust_address (m_tramp, ptr_mode, target_function_offset);
+  ncpu32k_emit_move (mem, XEXP (DECL_RTL (fndecl), 0));
+
+  /* Flushing the trampoline from the instruction cache needs to be done
+     here. */
+
+}
+
+
+/* -------------------------------------------------------------------------- */
+/*!Provide support for DW_AT_calling_convention
+
+   Define this to enable the dwarf attribute DW_AT_calling_convention to be
+   emitted for each function. Instead of an integer return the enum value for
+   the DW_CC_ tag.
+
+   To support optional call frame debugging information, you must also define
+   INCOMING_RETURN_ADDR_RTX and either set RTX_FRAME_RELATED_P on the prologue
+   insns if you use RTL for the prologue, or call "dwarf2out_def_cfa" and
+   "dwarf2out_reg_save" as appropriate from TARGET_ASM_FUNCTION_PROLOGUE if
+   you donâ€™t.
+
+   For the NCPU32K, it should be sufficient to return DW_CC_normal in all cases.
+
+   @param[in] function  The function requiring debug information
+
+   @return  The enum of the DW_CC tag.                                        */
+/* -------------------------------------------------------------------------- */
+static int
+ncpu32k_dwarf_calling_convention (const_tree  function ATTRIBUTE_UNUSED)
+{
+  return  DW_CC_normal;
+
+}	/* ncpu32k_dwarf_calling_convention () */
+
+/*****************************************************************************/
+/* Target hook initialization.                                               */
+/*****************************************************************************/
+
+/* In most cases these use the static functions declared above. They have
+   defaults, so must be undefined first, before being redefined.
+
+   The description of what they do is found with the function above, unless it
+   is a standard function or a constant, in which case it is defined here (as
+   with TARGET_ASM_NAMED_SECTION).
+
+   The final declaration is of the global "targetm" structure. */
+
+/* Output assembly directives to switch to section name. The section should
+   have attributes as specified by flags, which is a bit mask of the SECTION_*
+   flags defined in â€˜output.hâ€™. If decl is non-NULL, it is the VAR_DECL or
+   FUNCTION_DECL with which this section is associated.
+
+   For NCPU32K, we use the default ELF sectioning. */
+#undef  TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section
+
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE ncpu32k_function_value
+
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL ncpu32k_function_ok_for_sibcall
+
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE ncpu32k_pass_by_reference
+
+#undef  TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES ncpu32k_arg_partial_bytes
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE ncpu32k_option_override
+
+#undef TARGET_ASM_FILE_START
+#define TARGET_ASM_FILE_START ncpu32k_asm_file_start
+
+/* This target hook returns TRUE if an argument declared in a prototype as an
+   integral type smaller than int should actually be passed as an int. In
+   addition to avoiding errors in certain cases of mismatch, it also makes for
+   better code on certain machines.
+
+   The default is to not promote prototypes.
+
+   For the NCPU32K we do require this, so use a utility hook, which always
+   returns TRUE. */
+#undef  TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+
+#undef  TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE ncpu32k_promote_function_mode
+
+#undef  TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P  ncpu32k_legitimate_address_p
+
+#undef  TARGET_LEGITIMIZE_ADDRESS
+#define TARGET_LEGITIMIZE_ADDRESS ncpu32k_legitimize_address
+
+#undef  TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT  ncpu32k_trampoline_init
+
+#undef  TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM ncpu32k_cannot_force_const_mem
+
+#undef TARGET_DWARF_CALLING_CONVENTION
+#define TARGET_DWARF_CALLING_CONVENTION  ncpu32k_dwarf_calling_convention
+
+/* uClibc has some instances where (non-coforming to ISO C) a non-varargs
+   prototype is in scope when calling that function which is implemented
+   as varargs.  We want this to work at least where none of the anonymous
+   arguments are used.  I.e. we want the last named argument to be known
+   as named so it can be passed in a register, varars funtion or not.  */
+#undef TARGET_STRICT_ARGUMENT_NAMING
+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true
+
+/* Is this suitable for an immediate operand.
+
+   FIXME?: Is this correct. We can only do 14-bit immediates directly. */
+static bool
+ncpu32k_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)
+{
+  if (ncpu32k_tls_symbolic_operand (x) != TLS_MODEL_NONE)
+    return 0;
+
+  return GET_CODE(x) != CONST_DOUBLE || (GET_MODE (x) == VOIDmode && !flag_pic);
+}
+#undef TARGET_LEGITIMATE_CONSTANT_P
+#define TARGET_LEGITIMATE_CONSTANT_P ncpu32k_legitimate_constant_p
+
+/* On the NCPU32K, no functions pop their arguments.
+   FIXME?: Is this really correct? */
+static int
+ncpu32k_return_pops_args (tree ARG_UNUSED(fundecl), tree ARG_UNUSED(funtype), int ARG_UNUSED(size))
+{
+  return 0;
+}
+#undef TARGET_RETURN_POPS_ARGS
+#define TARGET_RETURN_POPS_ARGS ncpu32k_return_pops_args
+
+/* Determine where to put an argument to a function.  Value is zero to push
+   the argument on the stack, or a hard register in which to store the
+   argument.
+
+   "mode" is the argument's machine mode.
+
+   "type" is the data type of the argument (as a tree).  This is null for
+    libcalls where that information may not be available.
+
+   "cum" is a variable of type CUMULATIVE_ARGS which gives info about the
+    preceding args and about the function being called.
+
+   "named" is nonzero if this argument is a named parameter (otherwise it is
+    an extra parameter matching an ellipsis).
+
+    On the ARC the first MAX_ARC_PARM_REGS args are normally in registers and
+    the rest are pushed.  */
+static rtx
+ncpu32k_function_arg (cumulative_args_t cum, enum machine_mode mode,
+                     const_tree type, bool named)
+{
+  CUMULATIVE_ARGS *cum_pnt = get_cumulative_args (cum);
+
+  if (NCPU32K_PASS_IN_REG_P (*cum_pnt, mode, type, named))
+    return gen_rtx_REG (mode, NCPU32K_ROUND_ADVANCE_CUM (*cum_pnt, mode, type)
+                          + GP_ARG_MIN_REG);
+  else
+    return 0;
+}
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG ncpu32k_function_arg
+/* Update the data in "cum" to advance over an argument of mode "mode" and
+   data type "type".  ("type" is null for libcalls where that information may
+   not be available.)  */
+static void
+ncpu32k_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,
+                           const_tree type, bool ARG_UNUSED(named))
+{
+  CUMULATIVE_ARGS *cum_pnt = get_cumulative_args (cum);
+
+  *cum_pnt = NCPU32K_ROUND_ADVANCE_CUM (*cum_pnt, mode, type)
+    + NCPU32K_ROUND_ADVANCE_ARG (mode, type);
+}
+
+#undef TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE ncpu32k_function_arg_advance
+
+#undef TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS ncpu32k_print_operand_address
+
+/* Trampoline stubs are yet to be written. */
+/* #define TARGET_ASM_TRAMPOLINE_TEMPLATE */
+/* #define TARGET_TRAMPOLINE_INIT */
+
+/* Lay out structs with increased alignment so that they can be accessed
+   more efficiently.  But don't increase the size of one or two byte
+   structs.  */
+int
+ncpu32k_struct_alignment (tree t)
+{
+  unsigned HOST_WIDE_INT total = 0;
+  int default_align_fields = 0;
+  int special_align_fields = 0;
+  tree field;
+  unsigned max_align
+    = maximum_field_alignment ? maximum_field_alignment : BIGGEST_ALIGNMENT;
+  bool struct_p;
+
+  switch (TREE_CODE (t))
+    {
+    case RECORD_TYPE:
+      struct_p = true; break;
+    case UNION_TYPE: case QUAL_UNION_TYPE:
+      struct_p = false; break;
+    default: gcc_unreachable ();
+    }
+  /* Skip all non field decls */
+  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))
+    {
+      unsigned HOST_WIDE_INT field_size;
+
+      if (TREE_CODE (field) != FIELD_DECL ||
+	  TREE_TYPE (field) == error_mark_node)
+	continue;
+      /* If this is a field in a non-qualified union, or the sole field in
+	 a struct, and the alignment was set by the user, don't change the
+	 alignment.
+	 If the field is a struct/union in a non-qualified union, we already
+	 had sufficient opportunity to pad it - if we didn't, that'd be
+	 because the alignment was set as above.
+	 Likewise if the field is a struct/union and the sole field in a
+	 struct.  */
+      if (DECL_USER_ALIGN (field)
+	  || TYPE_USER_ALIGN (TREE_TYPE (field))
+	  || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE
+	  || TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE
+	  || TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)
+	{
+	  if (TREE_CODE (t) == UNION_TYPE)
+	    return 0;
+	  special_align_fields++;
+	}
+      else if (DECL_PACKED (field))
+	special_align_fields++;
+      else
+	default_align_fields++;
+      if (!tree_fits_uhwi_p (DECL_SIZE (field)))
+	field_size = max_align;
+      else
+	field_size = tree_to_uhwi (DECL_SIZE (field));
+      if (field_size >= BIGGEST_ALIGNMENT)
+	total = max_align;
+      if (struct_p)
+	total += field_size;
+      else
+	total = MAX (total, field_size);
+    }
+
+  if (!default_align_fields
+      && (TREE_CODE (t) != RECORD_TYPE || special_align_fields <= 1))
+    return 0;
+  return total < max_align ? (1U << ceil_log2 (total)) : max_align;
+}
+
+/* Increase the alignment of objects so that they are easier to copy.
+   Note that this can cause more struct copies to be inlined, so code
+   size might increase, but so should perfromance.  */
+int
+ncpu32k_data_alignment (tree t, int align)
+{
+  if (align < FASTEST_ALIGNMENT && TREE_CODE (t) == ARRAY_TYPE)
+    {
+      int size = int_size_in_bytes (t);
+
+      return (size > 0 && size < FASTEST_ALIGNMENT / BITS_PER_UNIT
+	      ? (1 << floor_log2 (size)) * BITS_PER_UNIT
+	      : FASTEST_ALIGNMENT);
+    }
+  return align;
+}
+
+static void
+ncpu32k_option_override (void)
+{
+}
+
+static void
+ncpu32k_asm_file_start(void)
+{
+  default_file_start();
+}
+
+/* Implement EH_RETURN_HANDLER_RTX. 
+ * Make eh_return use the link register. Epilogue LR restore
+ * is suppressed for eh_return. */
+rtx
+ncpu32k_eh_return_handler_rtx (void)
+{
+  return INCOMING_RETURN_ADDR_RTX;
+}
+
+/* Implement RETURN_ADDR_RTX.
+ * We do not support moving back to a previous frame. */
+rtx
+ncpu32k_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)
+{
+  if (count != 0)
+    return const0_rtx;
+
+  /* We don't know if LR is going to be saved or if we're going to
+   * be clobbering it with the GOT instruction.
+   * Therefore the safest bet is to force a save of LR and use that.
+   * Assume it's going to be first in the stack. */
+
+  cfun->machine->force_lr_save = true;
+  return gen_rtx_MEM (Pmode, plus_constant (Pmode, arg_pointer_rtx,
+                                            -UNITS_PER_WORD));
+}
+
+/* Implement TARGET_FRAME_POINTER_REQUIRED.
+ * We want frame pointer in eh_return and when alloca is used */
+static bool
+ncpu32k_frame_pointer_required (void)
+{
+  return crtl->calls_eh_return || cfun->calls_alloca;
+}
+
+/* Functions to save and restore machine-specific function data.  */
+static struct machine_function *
+ncpu32k_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+/* INIT_EXPANDERS */
+void
+ncpu32k_init_expanders (void)
+{
+  /* Arrange to initialize and mark the machine per-function
+   * status.  */
+  init_machine_status = ncpu32k_init_machine_status;
+
+  if (cfun && cfun->machine)
+    {
+      cfun->machine->force_lr_save = false;
+    }
+}
+
+#undef  TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED ncpu32k_frame_pointer_required
+
+/* Initialize the GCC target structure.  */
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-ncpu32k.h"
+
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.h	2020-01-28 22:08:12.714915531 +0800
@@ -0,0 +1,1139 @@
+/* Definitions of target machine for GNU compiler. nano-cpu32k version.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 1, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#ifndef _NCPU32K_H_
+#define _NCPU32K_H_
+
+#include "config/ncpu32k/ncpu32k-opts.h"
+
+/* Target CPU builtins */
+#define TARGET_CPU_CPP_BUILTINS()                       \
+  do                                                    \
+    {                                                   \
+      builtin_define ("__NCPU32K__");                   \
+      builtin_define ("__ncpu32k__");                   \
+      builtin_assert ("cpu=ncpu32k");                   \
+      builtin_assert ("machine=ncpu32k");               \
+    }                                                   \
+  while (0)
+
+#undef CPP_SPEC
+#define CPP_SPEC "%{!mnewlib:%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}}"
+
+/* Make sure we pick up the crti.o, crtbegin.o, crtend.o and crtn.o files. */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{!shared:%{pie:Scrt0.o%s;:crt0.o%s}} crti.o%s \
+   %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{mnewlib:-entry 0x100} %{static:-static} %{shared:-shared}"
+
+/* Override previous definitions (linux.h). Newlib doesn't have a profiling
+   version of the library, but it does have a debugging version (libg.a) */
+#undef LIB_SPEC
+#define LIB_SPEC "%{!mnewlib:%{pthread:-lpthread}	\
+		             %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}"			\
+                 "%{mnewlib:%{!g:-lc} %{g:-lg} -lncpu32k					\
+                            %{mboard=*:-lboard-%*} %{!mboard=*:-lboard-ncpu32ksim}		\
+                            %{!g:-lc} %{g:-lg}						\
+                            }"
+
+/* Target machine storage layout */
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields. */
+#define BITS_BIG_ENDIAN 0
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 0
+
+/* Define this if most significant word of a multiword number is numbered.  */
+#define WORDS_BIG_ENDIAN 0
+
+#define BITS_PER_WORD 32
+#define SHORT_TYPE_SIZE 16
+#define INT_TYPE_SIZE 32
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE 64
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD 4
+
+/* Width in bits of a pointer.
+   See also the macro `Pmode' defined below.  */
+#define POINTER_SIZE 32
+
+/* Allocation boundary (in *bits*) for storing pointers in memory.  */
+#define POINTER_BOUNDARY 32
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY 32
+
+/* Boundary (in *bits*) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY 32
+
+/* Allocation boundary (in *bits*) for the code of a function.  */
+#define FUNCTION_BOUNDARY 32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY 8
+
+/* A bitfield declared as `int' forces `int' alignment for the struct.  */
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 32
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 32
+
+/* Make strings word-aligned so strcpy from constants will be faster.  */
+/*
+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  				\
+  ((TREE_CODE (EXP) == STRING_CST || TREE_CODE (EXP) == CONSTRUCTOR)    \
+    && (ALIGN) < FASTEST_ALIGNMENT      				\
+   ? FASTEST_ALIGNMENT : (ALIGN))
+*/
+
+/* One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  Another is to
+   cause character arrays to be word-aligned so that `strcpy' calls
+   that copy constants to character arrays can be done inline.  */         
+/*
+#define DATA_ALIGNMENT(TYPE, ALIGN)                                     \
+  ((((ALIGN) < FASTEST_ALIGNMENT)                                       \
+    && (TREE_CODE (TYPE) == ARRAY_TYPE                                  \
+        || TREE_CODE (TYPE) == UNION_TYPE                               \
+        || TREE_CODE (TYPE) == RECORD_TYPE)) ? FASTEST_ALIGNMENT : (ALIGN))
+*/ /* CHECK - btw code gets bigger with this one */
+#define DATA_ALIGNMENT(TYPE, ALIGN) \
+  ((ALIGN) < FASTEST_ALIGNMENT \
+   ? ncpu32k_data_alignment ((TYPE), (ALIGN)) : (ALIGN))
+
+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \
+  ((ALIGN) < FASTEST_ALIGNMENT \
+   ? ncpu32k_data_alignment ((TYPE), (ALIGN)) : (ALIGN))
+
+/* Define this if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 1
+
+/* Align an address */
+#define NCPU32K_ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))
+
+/* Define if operations between registers always perform the operation
+   on the full register even if a narrower mode is specified.  */
+#define WORD_REGISTER_OPERATIONS
+
+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD
+   will either zero-extend or sign-extend.  The value of this macro should
+   be the code that says which one of the two operations is implicitly
+   done, NIL if none.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases,
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type. */
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \
+  if (GET_MODE_CLASS (MODE) == MODE_INT         \
+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \
+    (MODE) = SImode;
+  /* CHECK */
+
+
+/*
+ * brings 0.4% improvment in static size for linux
+ *
+#define PROMOTE_FOR_CALL_ONLY
+*/
+
+/* Define this macro if it is as good or better to call a constant
+   function address than to call an address kept in a register.  */
+#define NO_FUNCTION_CSE 1 /* CHECK */
+   
+/* Standard register usage.  */
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.  */
+
+#define NCPU32K_LAST_ACTUAL_REG		31
+#define ARG_POINTER_REGNUM		(NCPU32K_LAST_ACTUAL_REG + 1) /* arg = 32 */
+#define FRAME_POINTER_REGNUM		(ARG_POINTER_REGNUM + 1) /* soft FP = 33 */
+#define NCPU32K_LAST_INT_REG		FRAME_POINTER_REGNUM
+#define NCPU32K_CC_REG			(NCPU32K_LAST_INT_REG + 1) /* cc = 34 */
+#define FIRST_PSEUDO_REGISTER		(NCPU32K_CC_REG + 1)
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.
+   These are:
+     r0  -- NIL
+     r1 -- LNK
+     r2 -- SP
+     r3 -- FP
+     r12 -- TLS for linux
+     r14 -- GOT pointer
+*/
+/*      0  1  2  3  4  5  6  7  8  9 */
+#define FIXED_REGISTERS { \
+/*0*/   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, \
+/*10*/  0, 0, 1, 0, 1, 0, 0, 0, 0, 0, \
+/*20*/  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/*30*/  0, 0, 1, 1, 1 }
+  
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you like.
+   These are:
+      r3	fp
+      r4-r9	v0-v5
+      r10	rv
+      r11	rvh
+      All Caller-saved registers
+   And all the Fixed Registers...
+*/
+/*      0  1  2  3  4  5  6  7  8  9 */
+#define CALL_USED_REGISTERS { \
+/*0*/   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+/*10*/  1, 1, 1, 1, 1, 1, 0, 1, 0, 1, \
+/*20*/  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, \
+/*30*/  0, 1, 1, 1, 1}
+/*
+  SP		FIXED & CALL_USED
+  hard FP	CALL_USED
+  soft FP	FIXED and CALL_USED
+ */
+
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.
+   On the nano-cpu32k, all registers are one word long.  */
+#define HARD_REGNO_NREGS(REGNO, MODE)   \
+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */
+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+#define MODES_TIEABLE_P(MODE1, MODE2)  1
+
+/* A C expression for the cost of moving data of mode mode from a register in
+   class "from" to one in class "to". The classes are expressed using the
+   enumeration values such as GENERAL_REGS. A value of 2 is the default; other
+   values are interpreted relative to that.
+
+   It is not required that the cost always equal 2 when "from" is the same as
+   "to"; on some machines it is expensive to move between registers if they are
+   not general registers.
+
+   If reload sees an insn consisting of a single set between two hard
+   registers, and if REGISTER_MOVE_COST applied to their classes returns a
+   value of 2, reload does not check to ensure that the constraints of the
+   insn are met. Setting a cost of other than 2 will allow reload to verify
+   that the constraints are met. You should do this if the "movm" pattern's
+   constraints do not allow such copying.  */
+#define REGISTER_MOVE_COST(mode, from, to)  2
+
+/* A C expression for the cost of moving data of mode mode between a register
+   of class "class" and memory; "in" is zero if the value is to be written to
+   memory, nonzero if it is to be read in. This cost is relative to those in
+   REGISTER_MOVE_COST. If moving between registers and memory is more
+   expensive than between two registers, you should define this macro to
+   express the relative cost.
+
+   If you do not define this macro, GCC uses a default cost of 4 plus the cost
+   of copying via a secondary reload register, if one is needed. If your
+   machine requires a secondary reload register to copy between memory and a
+   register of class but the reload mechanism is more complex than copying via
+   an intermediate, define this macro to reflect the actual cost of the move.
+
+   GCC defines the function "memory_move_secondary_cost" if secondary reloads
+   are needed. It computes the costs due to copying via a secondary
+   register. If your machine copies from memory using a secondary register in
+   the conventional way but the default base value of 4 is not correct for
+   your machine, define this macro to add some other value to the result of
+   that function. The arguments to that function are the same as to this
+   macro.  */
+#define MEMORY_MOVE_COST(mode, class, in)  10
+
+/* A C expression for the cost of a branch instruction. A value of 1 is the
+   default; other values are interpreted relative to that. Parameter "speed_p"
+   is TRUE when the branch in question should be optimized for speed. When it
+   is FALSE, BRANCH_COST should be returning value optimal for code size
+   rather then performance considerations. "predictable_p" is true for well
+   predictable branches. On many architectures the BRANCH_COST can be reduced
+   then.  */
+#define BRANCH_COST(speed_p, predictable_p)  4
+
+/* Specify the registers used for certain standard purposes.
+   The values of these macros are register numbers.  */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM 2 /* r2 */
+
+/* Base register for access to local variables of the function.  */
+#define HARD_FRAME_POINTER_REGNUM 3 /* r3 */
+
+/* Link register. */
+#define LINK_REGNUM 1 /* r1 */
+
+/* Register in which static-chain is passed to a function.  */
+
+#define STATIC_CHAIN_REGNUM 10 /* rv */
+
+#define PROLOGUE_TMP 13 /* FIXME? */
+#define EPILOGUE_TMP 4 /* v0 */
+
+/* Register in which address to store a structure value
+   is passed to a function.  */
+/*#define STRUCT_VALUE_REGNUM 0*/
+
+/* Pass address of result struct to callee as "invisible" first argument */
+#define STRUCT_VALUE 0
+
+/****************************************************************************/
+/* Register operands  */
+/****************************************************************************/
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   GENERAL_REGS and BASE_REGS classess are the same on NCPU32K.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+enum reg_class 
+{ 
+  NO_REGS,
+  GENERAL_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES 
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.   */
+#define REG_CLASS_NAMES							\
+{									\
+  "NO_REGS",								\
+  "GENERAL_REGS",   							\
+  "ALL_REGS"								\
+}
+
+/* Define which registers fit in which classes.  This is an initializer for a
+   vector of HARD_REG_SET of length N_REG_CLASSES.
+
+   An initializer containing the contents of the register classes, as integers
+   which are bit masks.  The Nth integer specifies the contents of class N.
+   The way the integer MASK is interpreted is that register R is in the class
+   if `MASK & (1 << R)' is 1.
+
+   When the machine has more than 32 registers, an integer does not suffice.
+   Then the integers are replaced by sub-initializers, braced groupings
+   containing several integers.  Each sub-initializer must be suitable as an
+   initializer for the type `HARD_REG_SET' which is defined in
+   `hard-reg-set.h'.
+
+   For the NCPU32K we have the minimal set. GENERAL_REGS is all except r0, which
+   it permanently zero. */
+#define REG_CLASS_CONTENTS						\
+  {									\
+    { 0x00000000, 0x00000000 },		/* NO_REGS */			\
+    { 0xffffffff, 0x00000003 },		/* GENERAL_REGS */		\
+    { 0xffffffff, 0x00000007 }		/* ALL_REGS */			\
+  }
+
+/* The same information, inverted:
+
+   Return the class number of the smallest class containing reg number regno.
+   This could be a conditional expression or could index an array.
+
+   FIXME? 0 is not really a register, but a constant.  */
+#define REGNO_REG_CLASS(regno)						\
+  ((0 == regno) ? ALL_REGS : ((1 <= regno) && (regno <= NCPU32K_LAST_INT_REG))		\
+   ? GENERAL_REGS : NO_REGS)
+
+/* The class value for index registers, and the one for base regs.  */
+#define INDEX_REG_CLASS GENERAL_REGS
+#define BASE_REG_CLASS  GENERAL_REGS
+
+/* Given an rtx X being reloaded into a reg required to be in class CLASS,
+   return the class of reg to actually use.  In general this is just CLASS;
+   but on some machines in some cases it is preferable to use a more
+   restrictive class.  */
+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)
+
+/* Return the maximum number of consecutive registers needed to represent mode
+   MODE in a register of class CLASS.
+
+   On the nano-cpu32k, this is always the size of MODE in words, since all registers
+   are the same size.  */
+#define CLASS_MAX_NREGS(CLASS, MODE)					\
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+
+
+/****************************************************************************/
+/* Stack layout; argument passing; function entry, exit and calling.  */
+/****************************************************************************/
+
+/* Define this if pushing a word on the stack makes the stack pointer a
+   smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this if the nominal address of the stack frame is at the
+   high-address end of the local variables; that is, each additional local
+   variable allocated goes at a more negative offset in the frame.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Offset within stack frame to start allocating local variables at.  If
+   FRAME_GROWS_DOWNWARD, this is the offset to the END of the first local
+   allocated.  Otherwise, it is the offset to the BEGINNING of the first local
+   allocated.  */
+#define STARTING_FRAME_OFFSET 0
+
+/* Offset of first parameter from the argument pointer register value.  */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* Define this if stack space is still allocated for a parameter passed
+   in a register.  The value is the number of bytes allocated to this
+   area.
+   N/a for NCPU32K. */
+/* #define REG_PARM_STACK_SPACE(FNDECL) (UNITS_PER_WORD * GP_ARG_NUM_REG) */
+
+/* Define this if the above stack space is to be considered part of the
+   space allocated by the caller.
+   N/a for NCPU32K. */
+/* #define OUTGOING_REG_PARM_STACK_SPACE */   
+
+/* Define this macro if `REG_PARM_STACK_SPACE' is defined, but the
+   stack parameters don't skip the area specified by it.
+   N/a for NCPU32K. */
+/* #define STACK_PARMS_IN_REG_PARM_AREA */
+
+/* If nonzero, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   current_function_outgoing_args_size. No space will be pushed onto the stack
+   for each call; instead, the function prologue should increase the stack
+   frame size by this amount.
+
+   Setting both PUSH_ARGS and ACCUMULATE_OUTGOING_ARGS is not proper. */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+#define ELIMINABLE_REGS							\
+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},				\
+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},			\
+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},				\
+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  (OFFSET) = ncpu32k_initial_elimination_offset ((FROM), (TO))
+
+/* Minimum and maximum general purpose registers used to hold arguments.  */
+#define GP_ARG_MIN_REG 4 /* v0 */
+#define GP_ARG_MAX_REG 9 /* v5 */
+#define GP_ARG_NUM_REG (GP_ARG_MAX_REG - GP_ARG_MIN_REG + 1) 
+
+/* Return register */
+#define GP_ARG_RETURN  10 /* rv */
+#define GP_ARG_RETURNH 11 /* rvh */
+
+/* TLS thread pointer register */
+#define THREAD_PTR_REGNUM 12 /* r12 */
+
+/* Position Independent Code.  */
+#define PIC_OFFSET_TABLE_REGNUM 14 /* r14 */
+
+/* A C expression that is nonzero if X is a legitimate immediate
+   operand on the target machine when generating position independent code.
+   You can assume that X satisfies CONSTANT_P, so you need not
+   check this.  You can also assume `flag_pic' is true, so you need not
+   check it either.  You need not define this macro if all constants
+   (including SYMBOL_REF) can be immediate operands when generating
+   position independent code.  */
+#define LEGITIMATE_PIC_OPERAND_P(X) ncpu32k_legitimate_pic_operand_p (X)
+
+/* A C expression to create an RTX representing the place where a library
+   function returns a value of mode mode.
+
+   Note that â€œlibrary functionâ€ in this context means a compiler support
+   routine, used to perform arithmetic, whose name is known specially by the
+   compiler and was not mentioned in the C code being compiled.
+
+   For the NCPU32K, return value is in "rv" (GP_ARG_RETURN).  */   
+#define LIBCALL_VALUE(mode)                                             \
+  gen_rtx_REG(								\
+	   ((GET_MODE_CLASS (mode) != MODE_INT				\
+	     || GET_MODE_SIZE (mode) >= 4)				\
+	    ? (mode)							\
+	    : SImode),							\
+	    GP_ARG_RETURN)
+
+/* Define this if PCC uses the nonreentrant convention for returning
+   structure and union values. 
+   N/a for NCPU32K. */
+/* #define PCC_STATIC_STRUCT_RETURN */
+
+/* A C expression that is nonzero if regno is the number of a hard register in
+   which the values of called function may come back.
+
+   A register whose use for returning values is limited to serving as the
+   second of a pair (for a value of type double, say) need not be recognized
+   by this macro. So for most machines, this definition suffices:
+
+       #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)
+
+   If the machine has register windows, so that the caller and the called
+   function use different registers for the return value, this macro should
+   recognize only the caller's register numbers.
+
+   For NCPU32K, we must check if we have the return register.
+
+   From GCC 4.6, this will be replaced by TARGET_FUNCION_VALUE_REGNO_P target
+   hook function. */
+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == GP_ARG_RETURN)
+ 
+/* 1 if N is a possible register number for function argument passing. */
+#define FUNCTION_ARG_REGNO_P(N) \
+   ((N) >= GP_ARG_MIN_REG && (N) <= GP_ARG_MAX_REG)
+
+/* A code distinguishing the floating point format of the target
+   machine.  There are three defined values: IEEE_FLOAT_FORMAT,
+   VAX_FLOAT_FORMAT, and UNKNOWN_FLOAT_FORMAT.  */
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+#define FLOAT_WORDS_BIG_ENDIAN 0 /* le */
+
+/* A C type for declaring a variable that is used as the first argument of
+   FUNCTION_ARG and other related values. For some target machines, the type
+   int suffices and can hold the number of bytes of argument so far.
+
+   There is no need to record in CUMULATIVE_ARGS anything about the arguments
+   that have been passed on the stack. The compiler has other variables to
+   keep track of that.  For target machines on which all arguments are passed
+   on the stack, there is no need to store anything in CUMULATIVE_ARGS;
+   however, the data structure must exist and should not be empty, so use
+   int. */
+#define CUMULATIVE_ARGS int
+
+/* A C statement (sans semicolon) for initializing the variable "cum" for the
+   state at the beginning of the argument list. The variable has type
+   CUMULATIVE_ARGS. The value of "fntype" is the tree node for the data type
+   of the function which will receive the args, or 0 if the args are to a
+   compiler support library function. For direct calls that are not libcalls,
+   "fndecl" contain the declaration node of the function. "fndecl" is also set
+   when INIT_CUMULATIVE_ARGS is used to find arguments for the function being
+   compiled.  "n_named_args" is set to the number of named arguments,
+   including a structure return address if it is passed as a parameter, when
+   making a call. When processing incoming arguments, "n_named_args" is set to
+   âˆ’1.
+
+   When processing a call to a compiler support library function, "libname"
+   identifies which one. It is a symbol_ref rtx which contains the name of the
+   function, as a string. "libname" is 0 when an ordinary C function call is
+   being processed. Thus, each time this macro is called, either "libname" or
+   "fntype" is nonzero, but never both of them at once.
+
+   For the NCPU32K, we set "cum" to zero each time.
+   JPB 29-Aug-10: Is this correct? */
+#define INIT_CUMULATIVE_ARGS(cum, fntype, libname, fndecl, n_named_args) \
+  (cum = 0)
+
+
+/* Define intermediate macro to compute the size (in registers) of an argument
+   for the ncpu32k.
+   The NCPU32K_ROUND_ADVANCE* macros are local to this file. */
+
+/* local, Round "size" up to a word boundary.  */
+#define NCPU32K_ROUND_ADVANCE(size)					\
+  (((size) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* local, Round arg "mode"/"type" up to the next word boundary.  */
+#define NCPU32K_ROUND_ADVANCE_ARG(mode, type)				\
+  ((mode) == BLKmode							\
+   ? NCPU32K_ROUND_ADVANCE (int_size_in_bytes (type))			\
+   : NCPU32K_ROUND_ADVANCE (GET_MODE_SIZE (mode)))
+
+/* local, The ABI says that no rounding to even or odd words takes place.  */
+#define NCPU32K_ROUND_ADVANCE_CUM(cum, mode, type) (cum)
+  
+/* Return boolean indicating if arg of type "type" and mode "mode" will be
+   passed in a reg.  This includes arguments that have to be passed by
+   reference as the pointer to them is passed in a reg if one is available
+   (and that is what we're given).
+
+   When passing arguments "named" is always 1.  When receiving arguments
+   "named" is 1 for each argument except the last in a stdarg/varargs
+   function.  In a stdarg function we want to treat the last named arg as
+   named.  In a varargs function we want to treat the last named arg (which is
+   `__builtin_va_alist') as unnamed. */
+#define NCPU32K_PASS_IN_REG_P(cum, mode, type, named)			\
+  ((named)                         					\
+   && ((NCPU32K_ROUND_ADVANCE_CUM ((cum), (mode), (type))			\
+	+ NCPU32K_ROUND_ADVANCE_ARG ((mode), (type))			\
+	<= GP_ARG_NUM_REG)))
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry. */
+#define FUNCTION_PROFILER(FILE, LABELNO)
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function, the
+   stack pointer does not matter.  The value is tested only in functions that
+   have frame pointers.  No definition is equivalent to always zero.
+
+   The default suffices for NCPU32K. */
+#define EXIT_IGNORE_STACK 0
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before the
+   prologue.  This RTL is either a REG, indicating that the return
+   value is saved in REG, or a MEM representing a location in
+   the stack.  */
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, LINK_REGNUM)
+
+#define RETURN_ADDR_RTX ncpu32k_return_addr_rtx
+
+/* Addressing modes, and classification of registers for them.  */
+
+/* #define HAVE_POST_INCREMENT */
+/* #define HAVE_POST_DECREMENT */
+
+/* #define HAVE_PRE_DECREMENT */
+/* #define HAVE_PRE_INCREMENT */
+
+/* Macros to check register numbers against specific register classes.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* True if X is an rtx for a constant that is a valid address.  */
+#define CONSTANT_ADDRESS_P(X) 						\
+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF              \
+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST                \
+   || GET_CODE (X) == HIGH)        
+
+/* A C expression which is nonzero if register number num is suitable for use
+   as a base register in operand addresses. Like TARGET_LEGITIMATE_ADDRESS_P,
+   this macro should also define a strict and a non-strict variant. Both
+   variants behave the same for hard register; for pseudos, the strict variant
+   will pass only those that have been allocated to a valid hard registers,
+   while the non-strict variant will pass all pseudos.
+
+   Compiler source files that want to use the strict variant of this and other
+   macros define the macro REG_OK_STRICT. You should use an #ifdef
+   REG_OK_STRICT conditional to define the strict variant in that case and the
+   non-strict variant otherwise.  */
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(num)					     \
+  (   ((0 < (num))             && ((num)             <= NCPU32K_LAST_INT_REG))  \
+   || ((0 < reg_renumber[num]) && (reg_renumber[num] <= NCPU32K_LAST_INT_REG)))
+
+#else
+/* Accept an int register or a pseudo reg.  */
+#define REGNO_OK_FOR_BASE_P(num) ((num) <= NCPU32K_LAST_INT_REG ||		\
+				  (num) >= FIRST_PSEUDO_REGISTER)
+#endif
+
+/* NCPU32K doesn't have any indexed addressing. */
+#define REG_OK_FOR_INDEX_P(X) 0
+#define REGNO_OK_FOR_INDEX_P(X) 0
+
+/* Specify the machine mode that this machine uses for the index in the
+   tablejump instruction.  */
+#define CASE_VECTOR_MODE SImode
+
+/* Define as C expression which evaluates to nonzero if the tablejump
+   instruction expects the table to contain offsets from the address of the
+   table.
+
+   Do not define this if the table should contain absolute addresses. */
+/* #define CASE_VECTOR_PC_RELATIVE 1 */
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR 1
+
+/* The maximum number of bytes that a single instruction can move quickly
+   between memory and registers or between two memory locations. */
+#define MOVE_MAX 4
+
+/* Define this if zero-extension is slow (more than one real instruction).  */
+/* #define SLOW_ZERO_EXTEND */
+
+/* Nonzero if access to memory by bytes is slow and undesirable.  
+   For RISC chips, it means that access to memory by bytes is no
+   better than access by words when possible, so grab a whole word
+   and maybe make use of that.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Define if shifts truncate the shift count
+   which implies one can omit a sign-extension or zero-extension
+   of a shift count. */
+/* #define SHIFT_COUNT_TRUNCATED */ /*FIXME?*/
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* A function address in a call instruction
+   is a byte address (for indexing purposes)
+   so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE SImode
+
+
+/****************************************************************************/
+/* Condition code stuff */
+/****************************************************************************/
+
+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,
+   return the mode to be used for the comparison. */
+#define SELECT_CC_MODE(op, x, y) ncpu32k_select_cc_mode(op)
+
+/* Can the condition code MODE be safely reversed? */
+#define REVERSIBLE_CC_MODE(mode) 1
+
+/* Given a condition code and a mode, return the inverse condition.  */
+#define REVERSE_CONDITION(code, mode) reverse_condition (code)
+
+
+/****************************************************************************/
+/* Control the assembler format that we output.  */
+/****************************************************************************/
+
+/* A C string constant describing how to begin a comment in the target
+   assembler language.  The compiler assumes that the comment will end at
+   the end of the line.  */
+#define ASM_COMMENT_START "#"
+
+/* Output to assembler file text saying following lines may contain character
+   constants, extra white space, comments, etc.  */
+#define ASM_APP_ON "#APP\n"
+
+/* Output to assembler file text saying following lines no longer contain
+   unusual constructs.  */
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* Switch to the text or data segment.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP "\t.section .text"
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP "\t.section .data"
+
+/* Output before uninitialized data. */
+#define BSS_SECTION_ASM_OP  "\t.section .bss"
+
+/* How to refer to registers in assembler output.  This sequence is indexed by
+   compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES							\
+  {"nil",  "lnk", "sp",  "fp",  "v0",  "v1",  "v2",  "v3",		\
+   "v4",   "v5",  "rv",  "rvh", "rtls","r13", "rgot","r15",		\
+   "r16", "r17",  "r18", "r19", "r20", "r21", "r22", "r23",		\
+   "r24", "r25",  "r26", "r27", "r28", "r29", "r30", "r31",		\
+   "argp", "frame", "cc-reg"}
+
+
+/****************************************************************************/
+/* Debug things for DBX (STABS)                                             */
+/*                                                                          */
+/* Note. Our config.gcc includes dbxelf.h, which sets up appropriate        */
+/*       defaults. Choice of which debug format to use is in our elf.h      */
+/****************************************************************************/
+
+/* Don't try to use the  type-cross-reference character in DBX data.
+   Also has the consequence of putting each struct, union or enum
+   into a separate .stabs, containing only cross-refs to the others.  */
+#define DBX_NO_XREFS
+         
+/****************************************************************************/
+/* Debug things for DWARF2                                                  */
+/*                                                                          */
+/* Note. Choice of which debug format to use is in our elf.h                */
+/****************************************************************************/
+
+/* We support frame unwind info including for exceptions handling. This needs
+   INCOMING_RETURN_ADDR_RTX to be set and OBJECT_FORMAT_ELF to be defined (in
+   elfos.h). Override any default value. */
+#undef  DWARF2_UNWIND_INFO
+#define DWARF2_UNWIND_INFO 1
+
+/* We want frame info produced. Note that this is superfluous if
+   DWARF2_UNWIND_INFO is non-zero, but we set so this so, we can produce frame
+   info even when it is zero. Override any default value. */
+#undef  DWARF2_FRAME_INFO
+#define DWARF2_FRAME_INFO 1
+
+/* Macro specifying which register holds the return address */
+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (LINK_REGNUM)
+
+/* Where is the start of our stack frame in relation to the end of the
+   previous stack frame at the start of a function, before the prologue */
+#define INCOMING_FRAME_SP_OFFSET  0
+
+/* Use compact debug tables. Generates .file/.loc directives. */
+#undef  DWARF2_ASM_LINE_DEBUG_INFO
+#define DWARF2_ASM_LINE_DEBUG_INFO 1
+
+/* We don't need an alternative return address for now. */
+/* DWARF_ALT_FRAME_RETURN_COLUMN */
+
+/* We always save registers in the prologue with word alignment, so don't
+   need this. */
+/* DWARF_CIE_DATA_ALIGNMENT */
+
+/* This specifies the maximum number of registers we can save in a frame. We
+   could note that only SP, FP, LR, arg regs and callee saved regs come into
+   this category. However this is only an efficiency thing, so for now we
+   don't use it. */
+/* DWARF_FRAME_REGISTERS */
+
+/* This specifies a mapping from register numbers in .dwarf_frame to
+   .eh_frame. However for us they are the same, so we don't need it. */
+/* DWARF_FRAME_REGNUM */
+
+/* Defined if the DWARF column numbers do not match register numbers. For us
+   they do, so this is not needed. */
+/* DWARF_REG_TO_UNWIND_COLUMN */
+
+/* Can be used to define a register guaranteed to be zero. Only useful if zero
+   is used to terminate backtraces, and not recommended for new ports, so we
+   don't use it. */
+/* DWARF_ZERO_REG */
+
+/* This is the inverse function for DWARF_FRAME_REGNUM. Again not needed. */
+/* DWARF2_FRAME_REG_OUT  */
+
+
+/****************************************************************************/
+/* Assembler Label Output */
+/****************************************************************************/
+
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global "
+
+#define SUPPORTS_WEAK 1
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.  */
+#define ASM_OUTPUT_LABEL(FILE,NAME)					\
+  { assemble_name (FILE, NAME); fputs (":\n", FILE); }
+
+/* We use -fleading-underscore to add it, when necessary.
+   No prefix for global symbols for NCPU32K */
+#define USER_LABEL_PREFIX ""
+
+/* Remove any previous definition (elfos.h).  */
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)	\
+  sprintf (LABEL, "*%s%d", PREFIX, NUM)
+
+/* This is how to output an assembler line defining an int constant.  */
+#define ASM_OUTPUT_INT(stream, value)					\
+  {									\
+    fprintf (stream, "\t.word\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n")}
+
+/* This is how to output an assembler line defining a float constant.  */
+#define ASM_OUTPUT_FLOAT(stream, value)					\
+  { long l;								\
+    REAL_VALUE_TO_TARGET_SINGLE (value,l);				\
+    fprintf(stream,"\t.word\t0x%08x\t\t# float %26.7e\n", l, value); }
+
+/* This is how to output an assembler line defining a double constant.  */
+#define ASM_OUTPUT_DOUBLE(stream, value)				\
+  { long l[2];								\
+    REAL_VALUE_TO_TARGET_DOUBLE (value,&l[0]);				\
+    fprintf(stream,"\t.word\t0x%08x,0x%08x\t# float %26.16le\n",	\
+	    l[0],l[1],value); }
+
+/* This is how to output an assembler line defining a long double constant.  */
+#define ASM_OUTPUT_LONG_DOUBLE(stream, value)				\
+  { long l[4];								\
+    REAL_VALUE_TO_TARGET_DOUBLE (value,&l[0]);				\
+    fprintf (stream,							\
+	     "\t.word\t0x%08x,0x%08x,0x%08x,0x%08x\t# float %26.18lle\n", \
+	     l[0],l[1],l[2],l[3],value); }
+
+/* This is how to output an assembler line defining a short constant.  */
+#define ASM_OUTPUT_SHORT(stream, value)					\
+  { fprintf (stream, "\t.half\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n"); }
+
+/* This is how to output an assembler line defining a char constant.  */
+#define ASM_OUTPUT_CHAR(stream, value)					\
+  { fprintf (stream, "\t.byte\t");					\
+    output_addr_const (stream, (value));				\
+    fprintf (stream, "\n")}
+
+/* This is how to output an assembler line for a numeric constant byte.  */
+#define ASM_OUTPUT_BYTE(stream, value)  \
+  fprintf (stream, "\t.byte\t0x%02x\n", (value))
+
+/* This is how to output an insn to push a register on the stack.
+   It need not be very fast code.  */
+#define ASM_OUTPUT_REG_PUSH(stream, regno)				\
+  { fprintf (stream, "\tadd\tsp, sp, -4\n");				\
+    fprintf (stream, "\tstw\t0(sp), %s\n", reg_names[regno]); }
+
+/* This is how to output an insn to pop a register from the stack.
+   It need not be very fast code.  */
+#define ASM_OUTPUT_REG_POP(stream,REGNO)				\
+  { fprintf (stream, "\tldw\t%s, 0(sp)\n", reg_names[REGNO]);		\
+    fprintf (stream, "\tadd\tsp, sp, 4\n"); }
+
+/* This is how to output an element of a case-vector that is absolute.
+   (The Vax does not use such vectors,
+   but we must define this macro anyway.)  */
+#define ASM_OUTPUT_ADDR_VEC_ELT(stream, value)				\
+  fprintf (stream, "\t.word\t.L%d\n", value)
+
+/* This is how to output an element of a case-vector that is relative.  */
+#define ASM_OUTPUT_ADDR_DIFF_ELT(stream, body, value, rel)		\
+  fprintf (stream, "\t.word\t.L%d-.L%d\n", value, rel)
+
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
+/* FIXME? If we were serious about PIC, we should also use jmpl to get
+   the table start address.  */
+
+/* This is how to output an assembler line that says to advance the location
+   counter to a multiple of 2**log bytes.  */
+#define ASM_OUTPUT_ALIGN(stream, log)					\
+  if ((log) != 0)							\
+    {									\
+      fprintf (stream, "\t.align\t%d\n", 1 << (log));			\
+    }
+
+/* This is how to output an assembler line that says to advance the location
+   counter by "size" bytes.  */
+#define ASM_OUTPUT_SKIP(stream, size)					\
+  fprintf (stream, "\t.space %d\n", (size))
+
+/* Need to split up .ascii directives to avoid breaking
+   the linker. */
+
+/* This is how to output a string.  */
+#define ASM_OUTPUT_ASCII(stream, ptr, len)				\
+  output_ascii_pseudo_op (stream, (const unsigned char *) (ptr), len)
+
+/* Invoked just before function output. */
+#define ASM_OUTPUT_FUNCTION_PREFIX(stream, fnname)			\
+  { fputs (".proc\t", stream); assemble_name (stream, fnname);		\
+    fputs ("\n", stream); }
+
+/* This says how to output an assembler line to define a global common
+   symbol. */
+#define ASM_OUTPUT_COMMON(stream,name,size,rounded)			\
+  { data_section ();							\
+    fputs ("\t.global\t", stream);					\
+    assemble_name(stream, name);					\
+    fputs ("\n", stream);						\
+    assemble_name (stream, name);					\
+    fputs (":\n", stream);						\
+    fprintf (stream, "\t.space\t%d\n", rounded); }
+
+/* This says how to output an assembler line to define a local common
+   symbol.
+   FIXME! This doesn't work - we don't have a .bss directive like this. */
+#define ASM_OUTPUT_LOCAL(stream, name, size, rounded)			\
+  { fputs ("\t.bss\t", (stream));					\
+    assemble_name ((stream), (name));					\
+    fprintf ((stream), ",%d,%d\n", (size), (rounded)); }
+
+/* This says how to output an assembler line to define a global common symbol
+   with size "size" (in bytes) and alignment "align" (in bits).  */
+#define ASM_OUTPUT_ALIGNED_COMMON(stream, name, size, align)		\
+  { data_section();							\
+    if ((ALIGN) > 8)							\
+      {									\
+	fprintf(stream, "\t.align %d\n", ((align) / BITS_PER_UNIT));	\
+      }									\
+    fputs("\t.global\t", stream); assemble_name(stream, name);      	\
+    fputs("\n", stream);                                        	\
+    assemble_name(stream, name);                                	\
+    fputs (":\n", stream);						\
+    fprintf(stream, "\t.space\t%d\n", size); }
+  
+/* This says how to output an assembler line to define a local common symbol
+   with size "size" (in bytes) and alignment "align" (in bits).  */
+#define ASM_OUTPUT_ALIGNED_LOCAL(stream, name, size, align)		\
+  { data_section();							\
+    if ((align) > 8)							\
+      {									\
+	fprintf(stream, "\t.align %d\n", ((align) / BITS_PER_UNIT));	\
+      }									\
+    assemble_name(stream, name);					\
+    fputs (":\n", stream);						\
+    fprintf(stream, "\t.space %d\n", size); }
+                                                     
+/* Store in "output" a string (made with alloca) containing an assembler-name
+   for a local static variable named "name".  "labelno" is an integer which is
+   different for each call.  */
+#define ASM_FORMAT_PRIVATE_NAME(output, name, labelno)			\
+  { (output) = (char *) alloca (strlen ((name)) + 10);			\
+    sprintf ((output), "%s.%lu", (name), (unsigned long int) (labelno)); }
+
+/* Macro for %code validation. Returns nonzero if valid.
+
+   The acceptance of '(' is an idea taken from SPARC; output nop for %( if not
+   optimizing or the slot is not filled. */
+#define PRINT_OPERAND_PUNCT_VALID_P(code)  (('(' == code) || ('%' == code))
+
+/* Print an instruction operand "x" on file "stream".  "code" is the code from
+   the %-spec that requested printing this operand; if `%z3' was used to print
+   operand 3, then CODE is 'z'.  */
+#define PRINT_OPERAND(stream, x, code)					\
+{									\
+  if (code == 'r'							\
+      && GET_CODE (x) == MEM						\
+      && GET_CODE (XEXP (x, 0)) == REG)					\
+    {									\
+      fprintf (stream, "%s", reg_names[REGNO (XEXP (x, 0))]);		\
+    }									\
+  else if (code == '(')							\
+    {									\
+;									\
+    }									\
+  else if (code == 'C')							\
+    {									\
+      switch (GET_CODE (x))						\
+	{								\
+        case EQ:							\
+	  fputs ("eq", stream);						\
+	  break;							\
+        case NE:                                                        \
+	  fputs ("ne", stream);						\
+	  break;							\
+	case GT:							\
+	  fputs ("gts", stream);					\
+	  break;							\
+        case GE:							\
+	  fputs ("ges", stream);					\
+	  break;							\
+	case LT:							\
+	  fputs ("lts", stream);					\
+	  break;							\
+	case LE:							\
+	  fputs ("les", stream);					\
+	  break;							\
+	case GTU:							\
+	  fputs ("gtu", stream);					\
+	  break;							\
+	case GEU:							\
+	  fputs ("geu", stream);					\
+	  break;							\
+	case LTU:							\
+	  fputs ("ltu", stream);					\
+	  break;							\
+	case LEU:							\
+	  fputs ("leu", stream);					\
+	  break;							\
+	default:							\
+	  abort ();							\
+	}								\
+    }									\
+  else if (code == 'H')							\
+    {									\
+      if (GET_CODE (x) == REG)						\
+	fprintf (stream, "%s", reg_names[REGNO (x) + 1]);		\
+      else								\
+	abort ();							\
+    }									\
+  else if (GET_CODE (x) == REG)						\
+    fprintf (stream, "%s", reg_names[REGNO (x)]);			\
+  else if (GET_CODE (x) == MEM)						\
+    output_address (XEXP (x, 0));					\
+  else									\
+    output_addr_const (stream, x);					\
+}
+
+/* The size of the trampoline in bytes. This is a block of code followed by
+   two words specifying the function address and static chain pointer. */
+#define TRAMPOLINE_SIZE							\
+  (ncpu32k_trampoline_code_size () + GET_MODE_SIZE (ptr_mode) * 2)
+
+/* Alignment required for trampolines, in bits.
+
+   For the NCPU32K, there is no need for anything other than word alignment. */
+#define TRAMPOLINE_ALIGNMENT  32
+
+/* Assume that if the assembler supports thread local storage
+ * the system supports it. */
+#if !defined(TARGET_HAVE_TLS) && defined(HAVE_AS_TLS)
+#define TARGET_HAVE_TLS true
+#endif
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_REGNUM 1 /* rv */
+/* Use r21, r23, r25 and r27 (clobber regs) for exception data */
+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (21 + ((N)<<1)) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, EH_RETURN_REGNUM)
+#define EH_RETURN_HANDLER_RTX   ncpu32k_eh_return_handler_rtx ()
+
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \
+  (flag_pic ? DW_EH_PE_pcrel : DW_EH_PE_absptr)
+
+#define INIT_EXPANDERS ncpu32k_init_expanders ()
+
+/* A C structure for machine-specific, per-function data.  This is
+ *    added to the cfun structure.  */
+typedef struct GTY(()) machine_function
+{
+  /* Force stack save of LR. Used in RETURN_ADDR_RTX. */
+  int force_lr_save;
+} machine_function;
+
+#endif /* _NCPU32K_H_ */
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.md
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.md	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.md	2020-02-03 19:05:04.344944388 +0800
@@ -0,0 +1,1383 @@
+;; Machine description for GNU compiler, nano-cpu32k ISA
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GNU CC.
+;;
+;; This program is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by the Free
+;; Software Foundation; either version 3 of the License, or (at your option)
+;; any later version.
+;;
+;; This program is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+;; more details.
+;;
+;; You should have received a copy of the GNU General Public License along
+;; with this program.  If not, see <http://www.gnu.org/licenses/>. */
+
+(define_constants [
+  (SP_REG 2) ; hard stack pointer
+  (FP_REG 3) ; hard frame pointer
+  (CC_REG 34)
+  (LNK_REG 1)
+  (GOT_REG 14)
+
+  ;; unspec values
+  (UNSPEC_FRAME         0)
+  (UNSPEC_GOT           1)
+  (UNSPEC_GOTOFFHI      2)
+  (UNSPEC_GOTOFFLO      3)
+  (UNSPEC_TPOFFLO       4)
+  (UNSPEC_TPOFFHI       5)
+  (UNSPEC_GOTTPOFFLO    6)
+  (UNSPEC_GOTTPOFFHI    7)
+  (UNSPEC_GOTTPOFFLD    8)
+  (UNSPEC_TLSGDLO       9)
+  (UNSPEC_TLSGDHI       10)
+  (UNSPEC_SET_GOT       101)
+  (UNSPEC_CMPXCHG       201)
+  (UNSPEC_FETCH_AND_OP  202)
+])
+
+(include "predicates.md")
+
+(include "constraints.md")
+
+(define_attr "type"
+  "unknown,load,store,move,extend,logic,add,mul,shift,compare,branch,jump,fp,jump_restore"
+  (const_string "unknown"))
+
+;; Number of machine instructions required to implement an insn.
+(define_attr "length" "" (const_int 1))
+
+;; ALU is modelled as a single functional unit, which is reserved for varying
+;; numbers of slots.
+;; Delay may be not right.
+(define_cpu_unit "ncpu32k_alu")
+(define_insn_reservation "bit_unit" 3 (eq_attr "type" "shift") "ncpu32k_alu")
+(define_insn_reservation "lsu_load" 3 (eq_attr "type" "load") "ncpu32k_alu*3")
+(define_insn_reservation "lsu_store" 2 (eq_attr "type" "store") "ncpu32k_alu")
+(define_insn_reservation "alu_unit" 2 (eq_attr "type" "add,logic,extend,move,compare")
+                                                                "ncpu32k_alu")
+(define_insn_reservation "mul_unit" 16 (eq_attr "type" "mul") "ncpu32k_alu*16")
+
+;; AI = Atomic Integers
+;; We do not support DI in our atomic operations.
+(define_mode_iterator AI [QI HI SI])
+
+;; Note: We use 'mult' here for 'nand' since it does not have its own RTX class.
+(define_code_iterator atomic_op [plus minus and ior xor mult])
+(define_code_attr op_name
+  [(plus "add") (minus "sub") (and "and") (ior "or") (xor "xor") (mult "nand")])
+(define_code_attr op_insn
+  [(plus "add") (minus "sub") (and "and") (ior "or") (xor "xor") (mult "and")])
+(define_code_attr post_op_insn
+  [(plus "") (minus "") (and "") (ior "") (xor "")
+   (mult "xor \t%3,%3,0x3fff # fetch_nand: invert")])
+
+;; Expand prologue as RTL
+(define_expand "prologue"
+  [(use (const_int 1))]
+  ""
+{
+  ncpu32k_expand_prologue ();
+  DONE;
+})
+
+;; Expand prologue as RTL
+(define_expand "epilogue"
+  [(use (const_int 2))]
+  ""
+{
+  ncpu32k_expand_epilogue ();
+  DONE;
+})
+
+(define_insn "frame_alloc_fp"
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (match_operand:SI 0 "nonmemory_operand" "r,I")))
+   (clobber (mem:QI (plus:SI (reg:SI FP_REG)
+			     (unspec:SI [(const_int FP_REG)] UNSPEC_FRAME))))]
+  ""
+  "add \tsp,sp,%0\t# allocate frame"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "frame_dealloc_fp"
+  [(set (reg:SI SP_REG) (reg:SI FP_REG))
+   (clobber (mem:QI (plus:SI (reg:SI FP_REG)
+			     (unspec:SI [(const_int FP_REG)] UNSPEC_FRAME))))]
+  ""
+  "or \tsp,fp,0\t# deallocate frame"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "frame_dealloc_sp"
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (match_operand:SI 0 "nonmemory_operand" "r,I")))
+   (clobber (mem:QI (plus:SI (reg:SI SP_REG)
+			     (unspec:SI [(const_int SP_REG)] UNSPEC_FRAME))))]
+  ""
+  "add \tsp,sp,%0"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "return_internal"
+  [(return)
+   (use (match_operand 0 "pmode_register_operand" ""))]
+  ""
+  "jmp \tr0,%0\t# return_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+
+
+;;***************************************************************************
+;; movQI
+;;***************************************************************************
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+      if (can_create_pseudo_p())
+        {
+          if (GET_CODE (operands[1]) == CONST_INT)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_movsi (reg, operands[1]));
+	      operands[1] = gen_lowpart (QImode, reg);
+	    }
+	  if (GET_CODE (operands[1]) == MEM && optimize > 0)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_rtx_SET (SImode, reg,
+				  gen_rtx_ZERO_EXTEND (SImode,
+						       operands[1])));
+
+	      operands[1] = gen_lowpart (QImode, reg);
+	    }
+          if (GET_CODE (operands[0]) != REG)
+	    operands[1] = force_reg (QImode, operands[1]);
+        }
+")
+
+(define_insn "*movqi_insn"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=m,r,r,r,r")
+	(match_operand:QI 1 "general_operand"       "r,r,I,K,m"))]
+  ""
+  "@
+   stb \t%0,%1\t# movqi: r
+   or \t%0,%1,0\t# movqi: r
+   add \t%0,r0,%1\t# movqi: I
+   or \t%0,r0,%1\t# movqi: K
+   ldbu \t%0,%1\t# movqi: m"
+  [(set_attr "type" "store,logic,move,logic,load")])
+
+
+;;***************************************************************************
+;; movHI
+;;***************************************************************************
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+      if (can_create_pseudo_p())
+        {
+          if (GET_CODE (operands[1]) == CONST_INT)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_movsi (reg, operands[1]));
+	      operands[1] = gen_lowpart (HImode, reg);
+	    }
+	  else if (GET_CODE (operands[1]) == MEM && optimize > 0)
+	    {
+	      rtx reg = gen_reg_rtx (SImode);
+
+	      emit_insn (gen_rtx_SET (SImode, reg,
+				      gen_rtx_ZERO_EXTEND (SImode,
+					   	           operands[1])));
+	      operands[1] = gen_lowpart (HImode, reg);
+	    }
+          if (GET_CODE (operands[0]) != REG)
+	    operands[1] = force_reg (HImode, operands[1]);
+        }
+        
+      if (! CONSTANT_P (operands[1]) || input_operand (operands[1], HImode))
+        ;
+      else if (CONSTANT_P (operands[1])
+           && GET_CODE (operands[1]) != HIGH
+           && GET_CODE (operands[1]) != LO_SUM)
+      {
+        ncpu32k_emit_set_const16 (operands[0], operands[1]);
+        DONE;
+      }
+")
+
+(define_insn "*movhi_insn"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=m,r,r,r,r,r")
+	(match_operand:HI 1 "general_operand"       "r,r,I,K,m,M"))]
+  ""
+  "@
+   sth \t%0,%1\t# movHI: r
+   or \t%0,%1,0\t# movHI: r
+   add \t%0,r0,%1\t# movHI: I
+   or \t%0,r0,%1\t# movHI: K
+   ldhu \t%0,%1\t# movHI: m
+   mhi \t%0,hi(%1)\t# movHI: M"
+  [(set_attr "type" "store,logic,move,logic,load,move")])
+
+(define_insn "*movhi_iorhi3"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (match_operand:HI 1 "register_operand" "%r")
+		(match_operand:HI 2 "nonmemory_operand" "K")))]
+  ""
+  "or \t%0,%1,%2\t# movHI_iorhi3: K"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; movSI
+;;***************************************************************************
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  ""
+{
+  if (ncpu32k_expand_move (SImode, operands)) DONE;
+})
+
+(define_insn "*movsi_insn"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,r,r,m")
+        (match_operand:SI 1 "input_operand"       "I,K,M,r,m,r"))]
+  "(register_operand (operands[0], SImode)
+   || (register_operand (operands[1], SImode))
+   || (operands[1] == const0_rtx))"
+  "@
+  add \t%0,r0,%1\t# movSI: I
+  or \t%0,r0,%1\t# movSI: K
+  mhi \t%0,hi(%1)\t# movSI: M
+  or \t%0,%1,0\t# movSI: r
+  ldwu \t%0,%1\t# movSI: SI load
+  stw \t%0,%1\t# movSI: SI store"
+  [(set_attr "type" "move,logic,move,logic,load,store")
+   (set_attr "length" "1,1,1,1,1,1")])
+
+(define_insn "movsi_lo_sum"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i")))]
+  ""
+  "or \t%0,%1,lo(%2)\t# movsi_lo_sum"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_high"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(high:SI (match_operand:SI 1 "immediate_operand" "i")))]
+  ""
+  "mhi \t%0,hi(%1)\t# movsi_high"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gotofflo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+ 	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                    (match_operand 2 "" ""))] UNSPEC_GOTOFFLO))]
+  "flag_pic"
+  "or \t%0,%1,gotofflo(%2)\t# movsi_gotofflo"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gotoffhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+ 	(unspec:SI [(match_operand 1 "" "")] UNSPEC_GOTOFFHI))]
+  "flag_pic"
+  "mhi \t%0,gotoffhi(%1)\t# movsi_gotoffhi"
+  [(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec:SI [(match_operand 1 "symbolic_operand" "")] UNSPEC_GOT))
+   (use (reg:SI GOT_REG))]
+  "flag_pic"
+  "ldwu \t%0,got(%1)(rgot)"
+  [(set_attr "type" "load")]
+)
+
+(define_insn "movsi_tlsgdlo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_TLSGDLO))]
+  ""
+  "or \t%0,%1,tlsgdlo(%2)\t# movsi_tlsgdlo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tlsgdhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_TLSGDHI))]
+  ""
+  "mhi \t%0,tlsgdhi(%1)\t# movsi_tlsgdhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gottpofflo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_GOTTPOFFLO))]
+  ""
+  "or \t%0,%1,gottpofflo(%2)\t# movsi_gottpofflo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_gottpoffhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_GOTTPOFFHI))]
+  ""
+  "mhi \t%0,gottpoffhi(%1)\t# movsi_gottpoffhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+(define_insn "load_gottpoff"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "register_operand" "r")] UNSPEC_GOTTPOFFLD))]
+  ""
+  "ldwu \t%0,0(%1)\t# load_gottpoff"
+[(set_attr "type" "load")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tpofflo"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(lo_sum:SI (match_operand:SI 1 "register_operand" "r")
+                   (match_operand:SI 2 "immediate_operand" "i"))] UNSPEC_TPOFFLO))]
+  ""
+  "or \t%0,%1,tpofflo(%2)\t# movsi_tpofflo"
+ [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "movsi_tpoffhi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] UNSPEC_TPOFFHI))]
+  ""
+  "mhi \t%0,tpoffhi(%1) # movsi_tpoffhi"
+[(set_attr "type" "move")
+   (set_attr "length" "1")])
+
+
+(define_insn_and_split "movsi_insn_big"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operand:SI 1 "immediate_operand" "i"))]
+  "GET_CODE (operands[1]) != CONST_INT"
+  ;; the switch of ncpu32k bfd to Rela allows us to schedule insns separately.
+  "mhi \t%0,hi(%1)\;or \t%0,%0,lo(%1)"
+  "(GET_CODE (operands[1]) != CONST_INT
+    || ! (CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'I', \"I\")
+	  || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'K', \"K\")
+	  || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[1]), 'M', \"M\")))
+   && reload_completed
+   && GET_CODE (operands[1]) != HIGH && GET_CODE (operands[1]) != LO_SUM"
+  [(pc)]
+{
+  if (!ncpu32k_expand_symbol_ref(SImode, operands))
+    {
+      emit_insn (gen_movsi_high (operands[0], operands[1]));
+      emit_insn (gen_movsi_lo_sum (operands[0], operands[0], operands[1]));
+    }
+  DONE;
+}
+  [(set_attr "type" "move")
+   (set_attr "length" "2")])
+
+
+;;***************************************************************************
+;; Conditional add
+;;*************************************************************************** 
+
+(define_expand "addsicc"
+  [(match_operand:SI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:SI 2 "register_operand" "")
+   (match_operand:SI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+(define_expand "addhicc"
+  [(match_operand:HI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:HI 2 "register_operand" "")
+   (match_operand:HI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+(define_expand "addqicc"
+  [(match_operand:QI 0 "register_operand" "")
+   (match_operand 1 "comparison_operator" "")
+   (match_operand:QI 2 "register_operand" "")
+   (match_operand:QI 3 "register_operand" "")]
+  ""
+  "FAIL;")
+
+
+;;***************************************************************************
+;; conditional moves
+;;***************************************************************************
+
+(define_expand "movsicc"
+   [(set (match_operand:SI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:SI 2 "register_operand" "")
+			  (match_operand:SI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+(define_expand "movhicc"
+   [(set (match_operand:HI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:HI 2 "register_operand" "")
+			  (match_operand:HI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+(define_expand "movqicc"
+   [(set (match_operand:QI 0 "register_operand" "")
+	 (if_then_else:SI (match_operand 1 "comparison_operator" "")
+			  (match_operand:QI 2 "register_operand" "")
+			  (match_operand:QI 3 "register_operand" "")))]
+  ""
+  "
+{
+    FAIL;
+}")
+
+
+;;***************************************************************************
+;; Integer Comparisons
+;;***************************************************************************
+
+;; Integer compare insns.
+(define_insn "*cmpsi_eq"
+  [(set (reg:CCEQ CC_REG)
+	(compare:CCEQ (match_operand:SI 0 "register_operand" "r,r,J")
+		      (match_operand:SI 1 "nonmemory_operand" "r,J,r")))]
+  ""
+  "@
+   cmp \t%0,eq,%1\t# cmpsi_eq
+   cmp \t%0,eq,r0\t# cmpsi_eq_zero1
+   cmp \tr0,eq,%1\t# cmpsi_eq_zero0"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsi_gt"
+  [(set (reg:CCGT CC_REG)
+	(compare:CCGT (match_operand:SI 0 "register_operand" "r,r,J")
+		      (match_operand:SI 1 "nonmemory_operand" "r,J,r")))]
+  ""
+  "@
+   cmp \t%0,gt,%1\t# cmpsi_gt
+   cmp \t%0,gt,r0\t# cmpsi_gt_zero1
+   cmp \tr0,gt,%1\t# cmpsi_gt_zero0"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsi_gtu"
+  [(set (reg:CCGTU CC_REG)
+	(compare:CCGTU (match_operand:SI 0 "register_operand" "r,r,J")
+		       (match_operand:SI 1 "nonmemory_operand" "r,J,r")))]
+  ""
+  "@
+   cmp \t%0,gtu,%1\t# cmpsi_gtu
+   cmp \t%0,gtu,r0\t# cmpsi_gtu_zero1
+   cmp \tr0,gtu,%1\t# cmpsi_gtu_zero0"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsi_lt"
+  [(set (reg:CCLT CC_REG)
+	(compare:CCLT (match_operand:SI 0 "register_operand" "r,J,r")
+		      (match_operand:SI 1 "nonmemory_operand" "r,r,J")))]
+  ""
+  "@
+   cmp \t%1,gt,%0\t# cmpsi_lt
+   cmp \t%1,gt,r0\t# cmpsi_lt_zero0
+   cmp \tr0,gt,%0\t# cmpsi_lt_zero1"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsi_ltu"
+  [(set (reg:CCLTU CC_REG)
+	(compare:CCLTU (match_operand:SI 0 "register_operand" "r,J,r")
+		       (match_operand:SI 1 "nonmemory_operand" "r,r,J")))]
+  ""
+  "@
+   cmp \t%1,gtu,%0\t# cmpsi_ltu
+   cmp \t%1,gtu,r0\t# cmpsi_ltu_zero0
+   cmp \tr0,gtu,%0\t# cmpsi_ltu_zero1"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; Conditional branch
+;;***************************************************************************
+
+(define_expand "cbranchsi4"
+  [(match_operator 0 "comparison_operator"
+    [(match_operand:SI 1 "register_operand")
+     (match_operand:SI 2 "register_operand")])
+   (match_operand 3 "")]
+   ""
+   {
+   ncpu32k_expand_cbranch (operands, SImode);
+   DONE;
+   })
+
+(define_expand "cbranchsf4"
+  [(match_operator 0 "comparison_operator"
+    [(match_operand:SF 1 "register_operand")
+     (match_operand:SF 2 "register_operand")])
+   (match_operand 3 "")]
+   "TARGET_HARD_FLOAT"
+   {
+   ncpu32k_expand_cbranch (operands, SFmode);
+   DONE;
+   })
+
+(define_insn "*bf"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+				      [(match_operand 2 "cc_reg_operand" "")
+				       (const_int 0)]
+		      )
+		      (label_ref (match_operand 0 "" ""))
+		      (pc))
+    )]
+  ""
+  "*
+   return ncpu32k_output_bcc(operands);
+  "
+  [(set_attr "type" "branch")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; move float/double
+;;***************************************************************************
+
+(define_insn_and_split "movdi"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=r, r, m, r")
+	(match_operand:DI 1 "general_operand"      " r, m, r, n"))]
+  ""
+  "*
+    return ncpu32k_output_move_double (operands);
+  "
+  "&& reload_completed && CONSTANT_P (operands[1])"
+  [(set (match_dup 2) (match_dup 3)) (set (match_dup 4) (match_dup 5))]
+  "operands[2] = operand_subword (operands[0], 0, 0, DImode);
+   operands[3] = operand_subword (operands[1], 0, 0, DImode);
+   operands[4] = operand_subword (operands[0], 1, 0, DImode);
+   operands[5] = operand_subword (operands[1], 1, 0, DImode);"
+  [(set_attr "length" "2,2,2,3")])
+
+;; Moving double and single precision floating point values
+
+
+(define_insn "movdf"
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=r, r, m, r")
+	(match_operand:DF 1 "general_operand"      " r, m, r, i"))]
+  ""
+  "*
+    return ncpu32k_output_move_double (operands);
+  "
+  [(set_attr "length" "2,2,2,3")])
+
+
+(define_insn "movsf"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,m")
+        (match_operand:SF 1 "general_operand"  "r,m,r"))]
+  ""
+  "@
+   or \t%0,%1,0\t# movsf
+   ldwu \t%0,%1\t# movsf
+   stw \t%0,%1\t# movsf"
+  [(set_attr "type" "move,load,store")
+   (set_attr "length" "1,1,1")])
+
+
+;;***************************************************************************
+;; extendqisi2
+;;***************************************************************************
+
+(define_expand "extendqisi2"
+  [(use (match_operand:SI 0 "register_operand" ""))
+   (use (match_operand:QI 1 "nonimmediate_operand" ""))]
+  ""
+  "
+{
+  if ( GET_CODE(operands[1]) == MEM ) {
+    emit_insn (gen_extendqisi2_ext_mem(operands[0], operands[1]));
+  }
+  else {
+    emit_insn (gen_extendqisi2_ext_reg(operands[0], operands[1]));
+  }
+ DONE;
+}")
+
+(define_insn "extendqisi2_ext_mem"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (sign_extend:SI (match_operand:QI 1 "memory_operand" "m")))]
+  ""
+  "ldb \t%0,%1\t# extendqisi2_ext_mem"
+  [(set_attr "length" "1")
+   (set_attr "type" "load")])
+
+(define_expand "extendqisi2_ext_reg"
+  [(set (match_dup 2)
+	(ashift:SI (match_operand:QI 1 "register_operand" "")
+		   (const_int 24)))
+   (set (match_operand:SI 0 "register_operand" "")
+	(ashiftrt:SI (match_dup 2)
+		     (const_int 24)))]
+  ""
+  "
+{
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  operands[2] = gen_reg_rtx (SImode);
+}")
+
+;;***************************************************************************
+;; extendhisi2
+;;***************************************************************************
+
+(define_expand "extendhisi2"
+  [(use (match_operand:SI 0 "register_operand" ""))
+   (use (match_operand:HI 1 "nonimmediate_operand" ""))]
+  ""
+  "
+{
+  if ( GET_CODE(operands[1]) == MEM ) {
+    emit_insn (gen_extendhisi2_ext_mem(operands[0], operands[1]));
+  }
+  else {
+    emit_insn (gen_extendhisi2_ext_reg(operands[0], operands[1]));
+  }
+ DONE;
+}")
+
+(define_insn "extendhisi2_ext_mem"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (sign_extend:SI (match_operand:HI 1 "memory_operand" "m")))]
+  ""
+  "ldw \t%0,%1\t# extendhisi2_ext_mem"
+  [(set_attr "length" "1")
+   (set_attr "type" "load")])
+
+(define_expand "extendhisi2_ext_reg"
+  [(set (match_dup 2)
+	(ashift:SI (match_operand:HI 1 "register_operand" "")
+		   (const_int 16)))
+   (set (match_operand:SI 0 "register_operand" "")
+	(ashiftrt:SI (match_dup 2)
+		     (const_int 16)))]
+  ""
+  "
+{
+  operands[1] = gen_lowpart (SImode, operands[1]);
+  operands[2] = gen_reg_rtx (SImode);
+}")
+
+
+;;***************************************************************************
+;; zero_extend<m><n>2
+;;***************************************************************************
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   and \t%0,%1,0xff\t# zero_extendqisi2
+   ldbu \t%0,%1\t# zero_extendqisi2"
+  [(set_attr "type" "logic,load")
+   (set_attr "length" "1,1")])
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "@
+   and \t%0,%1,0x3fff\t# zero_extendqisi2
+   ldhu \t%0,%1\t# zero_extendqisi2"
+  [(set_attr "type" "logic,load")
+   (set_attr "length" "1,1")])
+
+;;***************************************************************************
+;; Shift/rotate operations
+;;***************************************************************************
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashift:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   lsl \t%0,%1,%2\t# ashlsi3
+   lsl \t%0,%1,%2\t# ashlsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   asr \t%0,%1,%2\t# ashrsi3
+   asr \t%0,%1,%2\t# ashrsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "r,r")
+                   (match_operand:SI 2 "nonmemory_operand" "r,L")))]
+  ""
+  "@
+   lsr \t%0,%1,%2\t# lshrsi3
+   lsr \t%0,%1,%2\t# lshrsi3"
+  [(set_attr "type" "shift,shift")
+   (set_attr "length" "1,1")])
+
+;;***************************************************************************
+;; Logical bitwise operations
+;;***************************************************************************
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(and:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,K")))]
+  ""
+  "@
+   and \t%0,%1,%2\t# andsi3: r
+   and \t%0,%1,%2\t# andsi3: K"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,K")))]
+  ""
+  "@
+   or \t%0,%1,%2\t# iorsi3: r
+   or \t%0,%1,%2\t# iorsi3: K"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "%r,r")
+		(match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   xor \t%0,%1,%2\t# xorsi3: r
+   xor \t%0,%1,%2\t# xorsi3: I"
+  [(set_attr "type" "logic,logic")
+   (set_attr "length" "1,1")])
+
+(define_insn "one_cmplqi2"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(not:QI (match_operand:QI 1 "register_operand" "r")))]
+  ""
+  "xor \t%0,%1,0x00ff\t# one_cmplqi2"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(not:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "xor \t%0,%1,0x3fff\t# one_cmplsi2"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; Arithmetic add/sub 
+;;***************************************************************************
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "sub \t%0,r0,%1\t# negsi2"
+  [(set_attr "type" "add")
+   (set_attr "length" "1")])
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(plus:SI (match_operand:SI 1 "register_operand" "%r,r")
+		 (match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   add \t%0,%1,%2\t# addsi3: r
+   add \t%0,%1,%2\t# addsi3: I"
+  [(set_attr "type" "add,add")
+   (set_attr "length" "1,1")])
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(minus:SI (match_operand:SI 1 "register_operand" "r,r")
+		  (match_operand:SI 2 "nonmemory_operand" "r,I")))]
+  ""
+  "@
+   sub \t%0,%1,%2\t# subsi3: r
+   add \t%0,%1,%n2\t# subsi3: I"
+  [(set_attr "type" "add,add")]
+)
+
+;;***************************************************************************
+;; Arithmetic mul/div
+;;***************************************************************************
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (mult:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MUL"
+  "mul \t%0,%1,%2\t# mulsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+(define_insn "divsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (div:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_DIV"
+  "div \t%0,%1,%2\t# divsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (udiv:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_DIV"
+  "divu \t%0,%1,%2\t# udivsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+   
+(define_insn "modsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (mod:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MOD"
+  "mod \t%0,%1,%2\t# modsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+   
+(define_insn "umodsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (umod:SI (match_operand:SI 1 "register_operand" "r")
+                 (match_operand:SI 2 "register_operand" "r")))]
+  "TARGET_HARD_MOD"
+  "modu \t%0,%1,%2\t# umodsi3"
+  [(set_attr "type" "mul")
+   (set_attr "length" "1")])
+
+;;***************************************************************************
+;; Jumps
+;;***************************************************************************
+
+(define_expand "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "
+{
+  emit_jump_insn (gen_jump_internal (operands[0]));
+  DONE;
+}")
+
+(define_insn "jump_internal"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "jmp \tr0,%l0\t# jump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect jump
+
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "
+{
+  emit_jump_insn (gen_indirect_jump_internal (operands[0]));
+  DONE;
+
+}")
+
+(define_insn "indirect_jump_internal"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jmp \tr0,%0\t# indirect_jump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; table jump
+
+(define_expand "tablejump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+   ""
+  "
+{
+  if (CASE_VECTOR_PC_RELATIVE || flag_pic)
+    operands[0]
+      = force_reg (Pmode,
+		   gen_rtx_PLUS (Pmode, operands[0],
+				 gen_rtx_LABEL_REF (Pmode, operands[1])));
+  emit_jump_insn (gen_tablejump_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "tablejump_internal"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jmp \tr0,%0\t# tablejump_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; Calls
+;;***************************************************************************
+
+(define_expand "call"
+  [(parallel [(call (match_operand:SI 0 "sym_ref_mem_operand" "")
+		    (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "call_internal"
+[(parallel [(call (match_operand:SI 0 "sym_ref_mem_operand" "")
+                  (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  {
+    if (flag_pic)
+      {
+	crtl->uses_pic_offset_table = 1;
+	return "jmp \tlnk,plt(%S0)\t# call_internal%(";
+      }
+
+    return "jmp \tlnk,%S0\t# call_internal%(";
+  }
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; call value
+
+(define_expand "call_value"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+		   (call (match_operand:SI 1 "sym_ref_mem_operand" "")
+			 (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_value_internal (operands[0], operands[1], operands[2]));
+  DONE;
+}")
+
+(define_insn "call_value_internal"
+[(parallel [(set (match_operand 0 "register_operand" "=r")
+                  (call (match_operand:SI 1 "sym_ref_mem_operand" "")
+                        (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  {
+    if (flag_pic)
+      {
+	crtl->uses_pic_offset_table = 1;
+	return "jmp \tlnk,plt(%S1)\t# call_value_internal%(";
+      }
+    return "jmp \tlnk,%S1\t# call_value_internal%(";
+  }
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect call value 
+
+(define_expand "call_value_indirect"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+                   (call (mem:SI (match_operand:SI 1 "register_operand" "r"))
+                         (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_value_indirect_internal (operands[0], operands[1], operands[2]));
+  DONE;
+}")
+
+(define_insn "call_value_indirect_internal"
+  [(parallel [(set (match_operand 0 "register_operand" "=r")
+                   (call (mem:SI (match_operand:SI 1 "register_operand" "r"))
+                         (match_operand 2 "" "i")))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "jmp \tlnk,%1\t# call_value_indirect_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+;; indirect call
+
+(define_expand "call_indirect"
+  [(parallel [(call (mem:SI (match_operand:SI 0 "register_operand" "r"))
+		    (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "
+{
+  emit_call_insn (gen_call_indirect_internal (operands[0], operands[1]));
+  DONE;
+}")
+
+(define_insn "call_indirect_internal"
+[(parallel [(call (mem:SI (match_operand:SI 0 "register_operand" "r"))
+                  (match_operand 1 "" "i"))
+            (clobber (reg:SI LNK_REG))
+            (use (reg:SI GOT_REG))])]
+  ""
+  "jmp \tlnk,%0 # call_indirect_internal%("
+  [(set_attr "type" "jump")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; no-op
+;;***************************************************************************
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "type" "logic")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; Floating Point
+;;***************************************************************************
+
+(define_insn "addsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (plus:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fadds \t%0,%1,%2\t# addsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+   
+(define_insn "subsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (minus:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fsubs \t%0,%1,%2\t# subsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+(define_insn "mulsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (mult:SF (match_operand:SF 1 "register_operand" "r")
+                 (match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fmuls \t%0,%1,%2\t# mulsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+(define_insn "divsf3"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+        (div:SF (match_operand:SF 1 "register_operand" "r")
+		(match_operand:SF 2 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fdivs \t%0,%1,%2\t# divsf3"
+  [(set_attr "type"     "fp")
+   (set_attr "length"   "1")])
+
+
+;; Conversion between fixed point and floating point.
+
+(define_insn "floatsisf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(float:SF (match_operand:SI 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fitfs \t%0, %1\t# floatsisf2"
+  [(set_attr "type" "fp")
+   (set_attr "length" "1")])
+
+;; FIXME! not working 
+(define_insn "fixunssfsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(fix:SI (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fftis \t%0, %1\t# fixunssfsi2"
+  [(set_attr "type" "fp")
+   (set_attr "length" "1")])
+
+
+;; Single precision floating point comparision instructions
+
+(define_insn "*cmpsf_eq"
+  [(set (reg:CCEQ CC_REG)
+	(compare:CCEQ (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,eq,%1\t# cmpsf_eq"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsf_gt"
+  [(set (reg:CCGT CC_REG)
+	(compare:CCGT (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,%gt,1\t# cmpsf_gt"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+(define_insn "*cmpsf_lt"
+  [(set (reg:CCLT CC_REG)
+	(compare:CCLT (match_operand:SF 0 "register_operand" "r")
+		      (match_operand:SF 1 "register_operand" "r")))]
+  "TARGET_HARD_FLOAT"
+  "fcmps \t%0,gt,%1\t# cmpsf_lt"
+  [(set_attr "type" "compare")
+   (set_attr "length" "1")])
+
+
+;;***************************************************************************
+;; set GOT.
+;;***************************************************************************
+
+(define_insn "set_got"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(unspec:SI [(const_int 0)] UNSPEC_SET_GOT))
+   (clobber (reg:SI LNK_REG))
+   (clobber (reg:SI GOT_REG))]
+  ""
+    "jmp \tr0,8
+    \tmhi \trgot, gotpchi(_GLOBAL_OFFSET_TABLE_-4)
+    \tor \trgot,rgot, gotpclo(_GLOBAL_OFFSET_TABLE_+0)
+    \tadd \trgot,rgot, lnk"
+  [(set_attr "length" "16")])
+
+(define_expand "atomic_compare_and_swap<mode>"
+  [(match_operand:SI 0 "register_operand")   ;; bool output
+   (match_operand:AI 1 "register_operand")   ;; val output
+   (match_operand:AI 2 "memory_operand")     ;; memory
+   (match_operand:AI 3 "register_operand")   ;; expected
+   (match_operand:AI 4 "register_operand")   ;; desired
+   (match_operand:SI 5 "const_int_operand")  ;; is_weak
+   (match_operand:SI 6 "const_int_operand")  ;; mod_s
+   (match_operand:SI 7 "const_int_operand")] ;; mod_f
+  ""
+{
+  if (<MODE>mode == SImode)
+    emit_insn (gen_cmpxchg (operands[0], operands[1], operands[2], operands[3],
+                            operands[4]));
+  else
+    ncpu32k_expand_cmpxchg_qihi (operands[0], operands[1], operands[2],
+                              operands[3], operands[4], INTVAL (operands[5]),
+                              (enum memmodel) INTVAL (operands[6]),
+                              (enum memmodel) INTVAL (operands[7]));
+  DONE;
+})
+
+;;***************************************************************************
+;; Atmoic
+;;***************************************************************************
+
+(define_insn "cmpxchg"
+   [(set (match_operand:SI 0 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_operand:SI 2 "memory_operand" "+m")]
+          UNSPEC_CMPXCHG))
+    (set (match_dup 2)
+         (unspec_volatile:SI [(match_operand:SI 3 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+    (set (match_operand:SI 1 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_dup 2) (match_dup 3)
+                             (match_operand:SI 4 "register_operand" "r")]
+          UNSPEC_CMPXCHG))]
+  ""
+    "
+    ldwa \t%1,%2\t# cmpxchg: load
+    cmp %1,eq,%3\t# cmpxchg:cmp
+    bf \t1f\t# cmpxchg: b
+    or \t%0,r0,0\t# cmpxchg: result = 0
+    stwa \t%2,%4\t# cmpxchg: store new
+    bf \t1f\t# cmpxchg: done
+    nop
+    or \t%0,r0,1\t# cmpxchg: result = 1
+  1:
+  "
+)
+
+(define_insn "cmpxchg_mask"
+   [(set (match_operand:SI 0 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_operand:SI 2 "memory_operand" "+m")]
+          UNSPEC_CMPXCHG))
+    (set (match_dup 2)
+         (unspec_volatile:SI [(match_operand:SI 3 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+    (set (match_operand:SI 1 "register_operand" "=&r")
+         (unspec_volatile:SI [(match_dup 2) (match_dup 3)
+                             (match_operand:SI 4 "register_operand" "r")
+                             (match_operand:SI 5 "register_operand" "r")]
+          UNSPEC_CMPXCHG))
+   (clobber (match_scratch:SI 6 "=&r"))]
+  ""
+  "
+   ldwa \t%6,%2\t# cmpxchg: load
+   and \t%1,%6,%5\t# cmpxchg: mask old
+   and \t%4,%4,%5\t# cmpxchg: mask set
+   cmp %1,eq,%3\t# cmpxchg: cmp
+   bf \t1f\t# cmpxchg: b
+   or \t%0,r0,0\t# cmpxchg: result = 0
+   xor \t%6,%6,%1\t# cmpxchg: clear
+   or \t%6,%6,%4\t# cmpxchg: set
+   stwa \t%2,%6\t# cmpxchg: store new
+   bf 1f\t# cmpxchg: done
+   nop
+   or \t%0,r0,1\t# cmpxchg: result = 1
+  1:
+  "
+)
+
+(define_expand "atomic_fetch_<op_name><mode>"
+  [(match_operand:AI 0 "register_operand")
+   (match_operand:AI 1 "memory_operand")
+   (match_operand:AI 2 "register_operand")
+   (match_operand:SI 3 "const_int_operand")
+   (atomic_op:AI (match_dup 0) (match_dup 1))]
+  ""
+{
+  rtx ret = gen_reg_rtx (<MODE>mode);
+  if (<MODE>mode != SImode)
+    ncpu32k_expand_fetch_op_qihi (operands[0], operands[1], operands[2], ret,
+                               gen_fetch_and_<op_name>_mask);
+  else
+    emit_insn (gen_fetch_and_<op_name> (operands[0], operands[1], operands[2],
+                                        ret));
+  DONE;
+})
+
+(define_expand "atomic_<op_name>_fetch<mode>"
+  [(match_operand:AI 0 "register_operand")
+   (match_operand:AI 1 "memory_operand")
+   (match_operand:AI 2 "register_operand")
+   (match_operand:SI 3 "const_int_operand")
+   (atomic_op:AI (match_dup 0) (match_dup 1))]
+  ""
+{
+  rtx ret = gen_reg_rtx (<MODE>mode);
+  if (<MODE>mode != SImode)
+    ncpu32k_expand_fetch_op_qihi (ret, operands[1], operands[2], operands[0],
+                               gen_fetch_and_<op_name>_mask);
+  else
+    emit_insn (gen_fetch_and_<op_name> (ret, operands[1], operands[2],
+                                        operands[0]));
+  DONE;
+})
+
+(define_insn "fetch_and_<op_name>"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+        (match_operand:SI 1 "memory_operand" "+m"))
+   (set (match_operand:SI 3 "register_operand" "=&r")
+        (unspec_volatile:SI [(match_dup 1)
+                             (match_operand:SI 2 "register_operand" "r")]
+         UNSPEC_FETCH_AND_OP))
+   (set (match_dup 1)
+        (match_dup 3))
+   (atomic_op:SI (match_dup 0) (match_dup 1))]
+  ""
+    "
+1:
+   ldwa \t%0,%1\t# fetch_<op_name>: load
+   <op_insn>\t%3,%0,%2\t# fetch_<op_name>: logic
+   <post_op_insn>
+   stwa \t%1,%3\t# fetch_<op_name>: store new
+   bf 1b\t# fetch_<op_name>: done
+   nop
+")
+
+(define_insn "fetch_and_<op_name>_mask"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+        (match_operand:SI 1 "memory_operand" "+m"))
+   (set (match_operand:SI 3 "register_operand" "=&r")
+        (unspec_volatile:SI [(match_dup 1)
+                             (match_operand:SI 2 "register_operand" "r")
+                             (match_operand:SI 4 "register_operand" "r")]
+         UNSPEC_FETCH_AND_OP))
+   (set (match_dup 1)
+        (unspec_volatile:SI [(match_dup 3) (match_dup 4)] UNSPEC_FETCH_AND_OP))
+   (clobber (match_scratch:SI 5 "=&r"))
+   (atomic_op:SI (match_dup 0) (match_dup 1))]
+  ""
+    "
+1:
+   ldwa \t%0,%1\t# fetch_<op_name>: load
+   and \t%5,%0,%4\t# fetch_<op_name>: mask
+   xor \t%5,%0,%5\t# fetch_<op_name>: clear
+   <op_insn>\t%3,%0,%2\t# fetch_<op_name>: logic
+   <post_op_insn>
+   and \t%3,%3,%4\t# fetch_<op_name>: mask result
+   or \t%3,%5,%3\t# fetch_<op_name>: set
+   stwa \t%1,%3\t# fetch_<op_name>: store new
+   bf 1b\t# fetch_<op_name>: done
+   nop
+")
+
+;; Local variables:
+;; mode:emacs-lisp
+;; comment-start: ";; "
+;; eval: (set-syntax-table (copy-sequence (syntax-table)))
+;; eval: (modify-syntax-entry ?[ "(]")
+;; eval: (modify-syntax-entry ?] ")[")
+;; eval: (modify-syntax-entry ?{ "(}")
+;; eval: (modify-syntax-entry ?} "){")
+;; eval: (setq indent-tabs-mode t)
+;; End:
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-modes.def	2019-09-29 16:32:24.709765544 +0800
@@ -0,0 +1,39 @@
+/* Definitions of target machine for GNU compiler, for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 2, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the
+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA.  */
+
+/* Add any extra modes needed to represent the condition code.
+ */
+
+CC_MODE (CCEQ);
+CC_MODE (CCNE);
+
+CC_MODE (CCLE);
+CC_MODE (CCGE);
+CC_MODE (CCLT);
+CC_MODE (CCGT);
+
+CC_MODE (CCLEU);
+CC_MODE (CCGEU);
+CC_MODE (CCLTU);
+CC_MODE (CCGTU);
+
+CC_MODE(CCFP);
+CC_MODE(CCUNS);
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.opt gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.opt
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k.opt	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k.opt	2020-01-16 15:00:51.711584944 +0800
@@ -0,0 +1,66 @@
+; Options for the nano-cpu32k port of the compiler
+; Copyright (C) 2019 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+HeaderInclude
+config/ncpu32k/ncpu32k-opts.h
+
+mboard=
+Target RejectNegative Joined
+Link with libgloss configuration suitable for this board
+
+mnewlib
+Target Report RejectNegative
+Compile for the Linux/Gnu/newlib based toolchain
+
+mredzone=
+Target RejectNegative Joined UInteger Var(ncpu32k_redzone) Init(128)
+Set the size of the stack below sp that is assumed to be safe from interrupts.
+
+mhard-mod
+Target RejectNegative Mask(HARD_MOD)
+Use hardware modulo.
+
+msoft-mod
+Target RejectNegative InverseMask(HARD_MOD)
+Do not use hardware modulo.
+
+mhard-mul
+Target RejectNegative Mask(HARD_MUL)
+Use hardware multiplication
+
+msoft-mul
+Target RejectNegative InverseMask(HARD_MUL)
+Do not use hardware multiplication
+
+mhard-div
+Target RejectNegative Mask(HARD_DIV)
+Use hardware division
+
+msoft-div
+Target RejectNegative InverseMask(HARD_DIV)
+Do not use hardware division
+
+mhard-float
+Target RejectNegative Mask(HARD_FLOAT)
+Use hardware floating point
+
+msoft-float
+Target RejectNegative InverseMask(HARD_FLOAT)
+Do not use hardware floating point
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-opts.h	2019-09-21 16:59:06.990196970 +0800
@@ -0,0 +1,4 @@
+#ifndef NCPU32K_OPTS_H
+#define NCPU32K_OPTS_H
+
+#endif
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h
--- gcc-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/ncpu32k-protos.h	2020-02-03 16:24:10.789487492 +0800
@@ -0,0 +1,70 @@
+/* Definitions of target machine for GNU compiler, nano-cpu32k version.
+
+   Copyright (C) 2019 Free Software Foundation, Inc
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_NCPU32K_PROTOS_H
+#define GCC_NCPU32K_PROTOS_H
+
+/* The following are for general support. */
+extern int         ncpu32k_trampoline_code_size (void);
+
+/* The following are only needed when handling the machine definition. */
+#ifdef RTX_CODE
+extern void        ncpu32k_init_expanders (void);
+extern void        ncpu32k_expand_prologue (void);
+extern void        ncpu32k_expand_epilogue (void);
+extern bool        ncpu32k_expand_move (enum machine_mode mode, rtx operands[]);
+extern const char *ncpu32k_output_move_double (rtx *operands);
+extern void        ncpu32k_expand_cbranch (rtx *operands, enum machine_mode  mode);
+extern enum machine_mode ncpu32k_select_cc_mode (enum rtx_code op);
+extern const char *ncpu32k_output_bcc (rtx * operands);
+extern const char *ncpu32k_output_cmov (rtx * operands);
+extern int ncpu32k_emit_cmov (rtx  dest,
+               rtx  op,
+               rtx  true_cond,
+               rtx  false_cond);
+extern void        ncpu32k_emit_set_const32 (rtx  op0,
+                                          rtx  op1);
+extern void        ncpu32k_emit_set_const16 (rtx  op0,
+                                          rtx  op1);
+extern bool        ncpu32k_expand_symbol_ref (enum machine_mode mode,
+                                           rtx operands[]);
+extern void        ncpu32k_expand_cmpxchg_qihi (rtx bval, rtx retval,
+                        rtx mem, rtx oldval, rtx newval, int is_weak,
+                        enum memmodel success_mode, enum memmodel failure_mode);
+extern void  ncpu32k_expand_fetch_op_qihi (rtx oldval, rtx mem, rtx operand,
+                                        rtx newval, rtx (*generator)(rtx, rtx, rtx, rtx, rtx));
+#endif
+
+extern int ncpu32k_struct_alignment (tree);
+extern int ncpu32k_data_alignment (tree, int);
+
+extern int ncpu32k_initial_elimination_offset (int, int);
+extern bool ncpu32k_save_reg_p_cached (int regno);
+extern void ncpu32k_print_jump_restore (rtx jump_address);
+extern rtx ncpu32k_eh_return_handler_rtx (void);
+extern rtx ncpu32k_return_addr_rtx (int, rtx);
+
+extern int ncpu32k_legitimate_pic_operand_p (rtx x);
+
+/* For RETURN_ADDR_RTX */
+extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);
+
+#endif /* GCC_NCPU32K_PROTOS_H */
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/predicates.md gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/predicates.md
--- gcc-5.4.0/gcc/config/ncpu32k/predicates.md	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/predicates.md	2019-09-28 18:14:26.506608285 +0800
@@ -0,0 +1,120 @@
+;; Predicate definitions for nano-cpu32k
+;; Copyright (C) 2019 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+(define_predicate "cc_reg_operand"
+  (match_code "subreg,reg")
+{
+  register_operand (op, mode);
+
+  if (GET_CODE (op) == REG && REGNO (op) == CC_REG)
+    return 1;
+
+  return 0;
+})
+
+(define_predicate "input_operand"
+  (match_code "subreg,reg,const_int,mem,const")
+{
+  /* If both modes are non-void they must be the same.  */
+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))
+    return 0;
+
+  /* Allow any one instruction integer constant, and all CONST_INT
+     variants when we are working in DImode and !arch64.  */
+  if (GET_MODE_CLASS (mode) == MODE_INT
+      && ((GET_CODE (op) == CONST_INT)
+	  && (satisfies_constraint_K (op)
+	      || satisfies_constraint_M (op)
+	      || satisfies_constraint_I (op))))
+    return 1;
+
+  if (register_operand (op, mode))
+    return 1;
+
+  /* If this is a SUBREG, look inside so that we handle
+     paradoxical ones.  */
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+
+
+  /* Check for valid MEM forms.  */
+  if (GET_CODE (op) == MEM)
+    return memory_address_p (mode, XEXP (op, 0));
+
+  return 0;
+})
+
+(define_predicate "sym_ref_mem_operand"
+  (match_code "mem")
+{
+  if (GET_CODE (op) == MEM)
+    {
+      rtx t1 = XEXP (op, 0);
+      if (GET_CODE (t1) == SYMBOL_REF)
+	return 1;
+    }
+  return 0;
+})
+
+;; True iff OP is a symbolic operand.
+
+(define_predicate "symbolic_operand"
+  (match_code "symbol_ref,label_ref,const")
+{
+  switch (GET_CODE (op))
+    {
+    case SYMBOL_REF:
+      return !SYMBOL_REF_TLS_MODEL (op);
+    case LABEL_REF:
+      return true;
+    case CONST:
+      op = XEXP (op, 0);
+      return (GET_CODE (op) == PLUS
+	      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF
+		   && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))
+		  || GET_CODE (XEXP (op, 0)) == LABEL_REF)
+	      && GET_CODE (XEXP (op, 1)) == CONST_INT);
+    default:
+      break;
+    }
+  return false;
+})
+
+;; Return true if OP is a symbolic operand for the TLS Global Dynamic model.
+(define_predicate "tgd_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_GLOBAL_DYNAMIC")))
+
+;; Return true if OP is a symbolic operand for the TLS Local Dynamic model.
+
+(define_predicate "tld_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_DYNAMIC")))
+
+;; Return true if OP is a symbolic operand for the TLS Initial Exec model.
+
+(define_predicate "tie_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_INITIAL_EXEC")))
+
+;; Return true if OP is a symbolic operand for the TLS Local Exec model.
+
+(define_predicate "tle_symbolic_operand"
+  (and (match_code "symbol_ref")
+       (match_test "SYMBOL_REF_TLS_MODEL (op) == TLS_MODEL_LOCAL_EXEC")))
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/t-linux gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-linux
--- gcc-5.4.0/gcc/config/ncpu32k/t-linux	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-linux	2019-09-29 16:32:45.553766061 +0800
@@ -0,0 +1,3 @@
+MULTILIB_DIRNAMES =
+EXTRA_MULTILIB_PARTS = crti.o crtbegin.o crtend.o crtn.o
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config/ncpu32k/t-ncpu32k gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-ncpu32k
--- gcc-5.4.0/gcc/config/ncpu32k/t-ncpu32k	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config/ncpu32k/t-ncpu32k	2019-09-29 16:34:12.809768225 +0800
@@ -0,0 +1,6 @@
+# not support -g so don't use it
+LIBGCC2_DEBUG_CFLAGS =
+
+MULTILIB_OPTIONS =
+MULTILIB_DIRNAMES =
+MULTILIB_MATCHES =
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/config.gcc gcc-ncpu32k-5.4.0/gcc/config.gcc
--- gcc-5.4.0/gcc/config.gcc	2015-09-10 22:17:53.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/config.gcc	2019-09-21 16:29:54.582153519 +0800
@@ -417,6 +417,9 @@
 	extra_headers="loongson.h"
 	extra_options="${extra_options} g.opt mips/mips-tables.opt"
 	;;
+ncpu32k-*-*)
+	cpu_type=ncpu32k
+	;;
 nds32*)
 	cpu_type=nds32
 	extra_headers="nds32_intrinsic.h"
@@ -2207,6 +2210,17 @@
 	cxx_target_objs="msp430-c.o"
 	tmake_file="${tmake_file} msp430/t-msp430"
 	;;
+ncpu32k-*-elf*)
+	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h ${cpu_type}/elf.h"
+	extra_parts="crti.o crtbegin.o crtend.o crtn.o"
+	tmake_file=ncpu32k/t-ncpu32k
+	tm_defines="${tm_defines}"
+	;;
+ncpu32k-*-linux-*)
+	tm_file="${tm_file} dbxelf.h elfos.h ncpu32k/elf.h gnu-user.h linux.h ncpu32k/linux-gas.h ncpu32k/linux-elf.h uclibc-stdint.h"
+	tmake_file="ncpu32k/t-ncpu32k ncpu32k/t-linux ${tmake_file}"
+	tm_defines="${tm_defines}"
+	;;
 nds32le-*-*)
 	target_cpu_default="0"
 	tm_defines="${tm_defines}"
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/configure gcc-ncpu32k-5.4.0/gcc/configure
--- gcc-5.4.0/gcc/configure	2019-09-21 15:11:35.942037013 +0800
+++ gcc-ncpu32k-5.4.0/gcc/configure	2019-09-29 16:39:51.309776618 +0800
@@ -23650,6 +23650,20 @@
 	tls_first_minor=19
 	tls_as_opt='--fatal-warnings'
 	;;
+  ncpu32k*-*-*)
+      conftest_s='
+	.section ".tdata","awT",%progbits
+foo:	.long	25
+	.text
+	mhi 	v0,tlsgdhi(foo)
+	or 	v0,tlsgdlo(foo)
+
+	jmpl	__tls_get_addr
+	nop'
+	tls_first_major=2
+	tls_first_minor=23
+	tls_as_opt='--fatal-warnings'
+	;;
   nios2-*-*)
       conftest_s='
 	.section ".tdata","awT",@progbits'
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/gcc/configure.ac gcc-ncpu32k-5.4.0/gcc/configure.ac
--- gcc-5.4.0/gcc/configure.ac	2016-05-21 16:35:25.000000000 +0800
+++ gcc-ncpu32k-5.4.0/gcc/configure.ac	2019-09-21 16:34:19.986160099 +0800
@@ -3170,6 +3170,20 @@
 	tls_first_minor=19
 	tls_as_opt='--fatal-warnings'
 	;;
+  ncpu32k*-*-*)
+      conftest_s='
+	.section ".tdata","awT",%progbits
+foo:	.long	25
+	.text
+	mhi  v0, tlsgdhi(foo)
+	or   v0, tlsgdlo(foo)
+
+	jmpl    __tls_get_addr
+	nop'
+	tls_first_major=2
+	tls_first_minor=23
+	tls_as_opt='--fatal-warnings'
+	;;
   nios2-*-*)
       conftest_s='
 	.section ".tdata","awT",@progbits'
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/crti.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crti.S
--- gcc-5.4.0/libgcc/config/ncpu32k/crti.S	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crti.S	2020-02-03 20:12:53.488715460 +0800
@@ -0,0 +1,14 @@
+# Start .init and .fini sections.
+.section .init
+.global	_init
+nop
+_init:
+	add sp,sp,-4
+	stw 0(sp),lnk
+
+.section .fini
+.global	_fini
+_fini:
+	add sp,sp,-4
+	stw 0(sp),lnk
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/crtn.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S
--- gcc-5.4.0/libgcc/config/ncpu32k/crtn.S	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S	2020-02-03 20:12:58.744715164 +0800
@@ -0,0 +1,12 @@
+# End .init and .fini sections.
+
+.section .init
+	ldwu lnk,0(sp)
+ 	add sp,sp,4
+	jmp r0,lnk
+  
+.section .fini
+	ldwu lnk,0(sp)
+	add sp,sp,4
+	jmp r0,lnk
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/crtn.S~ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S~
--- gcc-5.4.0/libgcc/config/ncpu32k/crtn.S~	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/crtn.S~	2019-09-29 19:50:43.546060582 +0800
@@ -0,0 +1,14 @@
+#include "openpx64k-asm.inc"
+
+# End .init and .fini sections.
+
+.section .init
+	ldwu lnk,0(sp)
+ 	add sp,sp,4
+	jmp r0,lnk
+  
+.section .fini
+	ldwu lnk,0(sp)
+	add sp,sp,4
+	jmp r0,lnk
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/linux-unwind.h gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/linux-unwind.h
--- gcc-5.4.0/libgcc/config/ncpu32k/linux-unwind.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/linux-unwind.h	2019-09-29 19:54:02.858065524 +0800
@@ -0,0 +1,78 @@
+/* DWARF2 EH unwinding support for nano-cpu32k.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef inhibit_libc
+
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <linux/unistd.h>
+
+#define NCPU32K_GPR_SP 2 /* r2 */
+
+#define MD_FALLBACK_FRAME_STATE_FOR ncpu32k_fallback_frame_state
+
+static _Unwind_Reason_Code
+ncpu32k_fallback_frame_state (struct _Unwind_Context *context,
+			      _Unwind_FrameState *fs)
+{
+  struct rt_sigframe {
+    siginfo_t info;
+    struct ucontext uc;
+  } *frame = context->cfa;
+
+  struct sigcontext *sc;
+  unsigned char *pc = context->ra;
+  long new_cfa;
+  int i;
+
+  /*
+   * Note: These have to be the same as in the kernel.
+   * Please see arch/ncpu32k/kernel/signal.c
+   */
+  if (!(*(unsigned short *)(pc + 0) == 0xa960
+      && *(unsigned short *)(pc + 2) == __NR_rt_sigreturn
+      && *(unsigned long *)(pc + 4) == 0x20000001
+      && *(unsigned long *)(pc + 8) == 0x15000000)) //FIXME!
+    return _URC_END_OF_STACK;
+
+  sc = (struct sigcontext *) &frame->uc.uc_mcontext;
+
+  new_cfa = sc->regs.gpr[NCPU32K_GPR_SP];
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  for (i = 0; i < 32; ++i)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset = (long)&sc->regs.gpr[i] - new_cfa;
+    }
+
+  fs->retaddr_column = 9; //FIXME!
+  fs->signal_frame = 1;
+
+  return _URC_NO_REASON;
+}
+
+#endif /* ifdef inhibit_libc  */
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/ncpu32k.S gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/ncpu32k.S
--- gcc-5.4.0/libgcc/config/ncpu32k/ncpu32k.S	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/ncpu32k.S	2020-02-03 20:17:29.184699949 +0800
@@ -0,0 +1,196 @@
+#define ENTRY(symbol)	\
+	.align 4	;\
+	.global symbol	;\
+	.type	symbol, @function ;\
+symbol:
+
+#ifdef L__mulsi3
+ENTRY(__mulsi3)
+	add          rv,nil,0x0
+	cmp          v0,eq,rv
+	or           v2,v0,0x0
+	bt 3f
+	add          v3,nil,0x0
+1:
+	and          v0,v2,0x1
+	cmp          v0,eq,v3
+	lsr          v2,v2,0x1
+	bt 2f
+	add          rv,rv,v1
+2:
+	cmp          v2,eq,v3
+	lsl          v1,v1,0x1
+	bf 1b
+3:
+	jmp nil, lnk
+
+.size __mulsi3,.-__mulsi3
+#endif
+
+#ifdef L__udivsi3
+.global __udivsi3_internal
+.hidden __udivsi3_internal
+__udivsi3_internal:
+ENTRY(__udivsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	add          rv,nil,0
+	add          v5,v1,0
+	add          v2,v0,0
+	cmp          v5,eq,rv
+	add          v4,nil,0
+	bt           4f
+	cmp          v5,gtu,v2
+	bt           5f
+	cmp          v5,eq,v2
+	bt           6f
+	cmp          v5,gtu,rv
+	add          r13,nil,32
+	bf 2f
+    
+	mhi          lnk,hi(0x80000000)
+	add          v3,nil,-1
+1:
+	and          v0,v2,lnk
+	lsl          v1,v4,1
+	add          r15,v2,0
+	lsr          v0,v0,31
+	add          r13,r13,v3
+	or           v4,v1,v0
+	cmp          v5,gtu,v4
+	lsl          v2,v2,1
+	bt 1b
+
+2:
+	lsr          v4,v4,1
+	add          r13,r13,1
+	add          lnk,nil,0
+	cmp          r13,gtu,lnk
+	add          v2,r15,0
+	bf 4f
+	mhi          r15,hi(0x80000000)
+	add          r17,nil,0
+3:
+	and          v0,v2,r15
+	lsl          v1,v4,1
+	lsr          v0,v0,31
+	or           v4,v1,v0
+	sub          v3,v4,v5
+	and          v0,v3,r15
+	lsr          v0,v0,31
+	add          v1,nil,0
+	cmp          v0,eq,v1
+	lsl          v0,rv,1
+	bf 1f
+    
+	add          v1,nil,1
+1:
+	lsl          v2,v2,1
+	cmp          v1,eq,r17
+	or           rv,v0,v1
+	bt 2f
+
+	add          v4,v3,0
+2:
+	add          lnk,lnk,1
+	cmp          r13,gtu,lnk
+	bt 3b
+	jmp r0, 4f
+
+6:
+	add          rv,nil,1
+	jmp r0, 4f
+
+5:
+	add          v4,v2,0
+4:
+	ldwu         lnk,0(sp)
+	add          sp,sp,4
+	jmp r0, lnk
+
+.size __udivsi3,.-__udivsi3
+#endif
+
+
+#ifdef L__divsi3
+ENTRY(__divsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	add          v2,v0,0
+	add          r13,nil,0
+	cmp          nil,gt,v2
+	add          v0,nil,0
+	bf 1f
+
+	add          r13,nil,1
+	sub          v2,nil,v2
+1:
+	cmp          nil,gt,v1
+	bf 1f
+
+	add          r13,r13,1
+	sub          v1,nil,v1
+1:
+	add          v0,v2,0
+	jmp          lnk, __udivsi3_internal
+	add          r17,r0,1
+	cmp          r13,eq,r17
+	bf 1f
+
+	sub          rv,nil,rv
+1:
+	ldwu         lnk,0(sp)
+	add          sp,sp,4
+	jmp          nil, lnk
+
+.size __divsi3,.-__divsi3
+#endif
+
+
+#ifdef L__umodsi3
+ENTRY(__umodsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	jmp lnk,__udivsi3_internal
+
+	add          rv,v4,0
+	ldwu         lnk,0(sp)
+
+	add          sp,sp,4
+	jmp nil, lnk
+
+.size __umodsi3,.-__umodsi3
+#endif
+
+
+#ifdef L__modsi3
+ENTRY(__modsi3)
+	add          sp,sp,-4
+	stw          0(sp),lnk
+	add          r13,nil,0
+	cmp          nil,gt,v0
+	bf 1f
+    
+	add          r13,nil,1
+	sub          v0,nil,v0
+1:
+	cmp          nil,gt,v1
+	bf 1f
+    
+	sub          v1,nil,v1
+1:
+	jmp lnk, __udivsi3_internal
+	add          r17,r0,1
+	cmp          r13,eq,r17
+	add          rv,v4,0
+	bf 1f
+    
+	sub          rv,nil,rv
+1:
+	ldwu         lnk,0(sp)
+	add          sp,sp,4
+	jmp nil, lnk
+
+.size __modsi3,.-__modsi3
+#endif
+
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/sfp-machine.h gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/sfp-machine.h
--- gcc-5.4.0/libgcc/config/ncpu32k/sfp-machine.h	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/sfp-machine.h	2020-01-16 09:49:48.064703111 +0800
@@ -0,0 +1,54 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+#define _FP_QNANNEGATEDP 0
+
+/* FIXME!  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define	__LITTLE_ENDIAN	1234
+#define	__BIG_ENDIAN	4321
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#define _FP_TININESS_AFTER_ROUNDING 0
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-crtstuff gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-crtstuff
--- gcc-5.4.0/libgcc/config/ncpu32k/t-crtstuff	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-crtstuff	2018-10-20 15:50:53.299743000 +0800
@@ -0,0 +1,3 @@
+# This will prevent gcc from appending data to .eh_frame.
+CRTSTUFF_T_CFLAGS += -fno-dwarf2-cfi-asm
+CRTSTUFF_T_CFLAGS_S += -fno-dwarf2-cfi-asm
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-linux gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-linux
--- gcc-5.4.0/libgcc/config/ncpu32k/t-linux	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-linux	2018-10-25 19:52:45.343057000 +0800
@@ -0,0 +1,2 @@
+MULTILIB_DIRNAMES = le
+EXTRA_MULTILIB_PARTS = crti.o crtbegin.o crtend.o crtn.o
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config/ncpu32k/t-ncpu32k gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-ncpu32k
--- gcc-5.4.0/libgcc/config/ncpu32k/t-ncpu32k	1970-01-01 08:00:00.000000000 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config/ncpu32k/t-ncpu32k	2020-02-03 20:10:48.996722464 +0800
@@ -0,0 +1,2 @@
+LIB1ASMSRC = ncpu32k/ncpu32k.S
+LIB1ASMFUNCS = __mulsi3 __udivsi3 __divsi3 __umodsi3 __modsi3
diff -Nur -x tags -x build -x .cproject -x .project -x .settings gcc-5.4.0/libgcc/config.host gcc-ncpu32k-5.4.0/libgcc/config.host
--- gcc-5.4.0/libgcc/config.host	2019-09-21 15:11:25.950036765 +0800
+++ gcc-ncpu32k-5.4.0/libgcc/config.host	2019-09-29 19:48:27.570057211 +0800
@@ -156,6 +156,9 @@
 	fi
 	tmake_file="${tmake_file} t-softfp"
 	;;
+ncpu32k-*-*)
+	cpu_type=ncpu32k
+	;;
 nds32*-*)
 	cpu_type=nds32
 	;;
@@ -920,6 +923,15 @@
 msp430*-*-elf)
 	tmake_file="$tm_file t-crtstuff t-fdpbit msp430/t-msp430"
 	;;
+ncpu32k*-*-*)
+	tmake_file="$tmake_file ncpu32k/t-ncpu32k ncpu32k/t-linux ncpu32k/t-crtstuff t-softfp-sfdf t-softfp"
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o crti.o crtn.o"
+	;;
+ncpu32k*-*-linux*)
+	tmake_file="$tmake_file ncpu32k/t-ncpu32k ncpu32k/t-linux ncpu32k/t-crtstuff t-softfp-sfdf t-softfp"
+	md_unwind_header=ncpu32k/linux-unwind.h
+	extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o crti.o crtn.o"
+	;;
 nds32*-elf*)
 	# Basic makefile fragment and extra_parts for crt stuff.
 	# We also append c-isr library implementation.
